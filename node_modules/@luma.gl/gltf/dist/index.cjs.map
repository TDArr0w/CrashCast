{
  "version": 3,
  "sources": ["../src/index.ts", "../src/pbr/pbr-environment.ts", "../src/parsers/parse-pbr-material.ts", "../src/webgl-to-webgpu/convert-webgl-sampler.ts", "../src/parsers/parse-gltf.ts", "../src/webgl-to-webgpu/convert-webgl-topology.ts", "../src/gltf/create-gltf-model.ts", "../src/gltf/gltf-animator.ts", "../src/gltf/animations/interpolate.ts", "../src/webgl-to-webgpu/convert-webgl-attribute.ts", "../src/parsers/parse-gltf-animations.ts", "../src/utils/deep-copy.ts", "../src/gltf/create-scenegraph-from-gltf.ts"],
  "sourcesContent": ["// luma.gl, MIT license\n\nexport {loadPBREnvironment, type PBREnvironment} from './pbr/pbr-environment';\nexport {type ParsedPBRMaterial} from './pbr/pbr-material';\nexport {parsePBRMaterial, type ParsePBRMaterialOptions} from './parsers/parse-pbr-material';\nexport {} from './pbr/pbr-environment';\n\n// glTF Scenegraph Instantiator\nexport {createScenegraphsFromGLTF} from './gltf/create-scenegraph-from-gltf';\nexport {GLTFAnimator} from './gltf/gltf-animator';\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, SamplerProps} from '@luma.gl/core';\nimport {AsyncTexture} from '@luma.gl/engine';\nimport {loadImageTexture} from '@loaders.gl/textures';\n\n/** Environment textures for PBR module */\nexport type PBREnvironment = {\n  /** Bi-directional Reflectance Distribution Function (BRDF) lookup table */\n  brdfLutTexture: AsyncTexture;\n  diffuseEnvSampler: AsyncTexture;\n  specularEnvSampler: AsyncTexture;\n};\n\nexport type PBREnvironmentProps = {\n  brdfLutUrl: string;\n  getTexUrl: (name: string, dir: number, level: number) => string;\n  specularMipLevels?: number;\n};\n\n/** Loads textures for PBR environment */\nexport function loadPBREnvironment(device: Device, props: PBREnvironmentProps): PBREnvironment {\n  const brdfLutTexture = new AsyncTexture(device, {\n    id: 'brdfLUT',\n    sampler: {\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'linear',\n      magFilter: 'linear'\n    } as const satisfies SamplerProps,\n    // Texture accepts a promise that returns an image as data (Async Textures)\n    data: loadImageTexture(props.brdfLutUrl)\n  });\n\n  const diffuseEnvSampler = makeCube(device, {\n    id: 'DiffuseEnvSampler',\n    getTextureForFace: dir => loadImageTexture(props.getTexUrl('diffuse', dir, 0)),\n    sampler: {\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'linear',\n      magFilter: 'linear'\n    } as const satisfies SamplerProps\n  });\n\n  const specularEnvSampler = makeCube(device, {\n    id: 'SpecularEnvSampler',\n    getTextureForFace: (dir: number) => {\n      const imageArray: Promise<any>[] = [];\n      // @ts-ignore\n      for (let lod = 0; lod <= props.specularMipLevels - 1; lod++) {\n        imageArray.push(loadImageTexture(props.getTexUrl('specular', dir, lod)));\n      }\n      return imageArray;\n    },\n    sampler: {\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'linear', // [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n      magFilter: 'linear'\n    } as const satisfies SamplerProps\n  });\n\n  return {\n    brdfLutTexture,\n    diffuseEnvSampler,\n    specularEnvSampler\n  };\n}\n\n// TODO put somewhere common\nconst FACES = [0, 1, 2, 3, 4, 5];\n\nfunction makeCube(\n  device: Device,\n  {\n    id,\n    getTextureForFace,\n    sampler\n  }: {\n    id: string;\n    getTextureForFace: (dir: number) => Promise<any> | Promise<any>[];\n    sampler: SamplerProps;\n  }\n): AsyncTexture {\n  const data = {};\n  FACES.forEach(face => {\n    // @ts-ignore TODO\n    data[String(face)] = getTextureForFace(face);\n  });\n  return new AsyncTexture(device, {\n    id,\n    dimension: 'cube',\n    mipmaps: false,\n    sampler,\n    // @ts-expect-error\n    data\n  });\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device, Texture} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\nimport {log} from '@luma.gl/core';\nimport {type ParsedPBRMaterial} from '../pbr/pbr-material';\nimport {type PBREnvironment} from '../pbr/pbr-environment';\nimport {type PBRMaterialBindings} from '@luma.gl/shadertools';\nimport {convertSampler} from '../webgl-to-webgpu/convert-webgl-sampler';\n\n// TODO - synchronize the GLTF... types with loaders.gl\n// TODO - remove the glParameters, use only parameters\n\n/* eslint-disable camelcase */\n\ntype GLTFTexture = {\n  id: string;\n  texture: {source: {image: any}; sampler: {parameters: any}};\n  uniformName?: string;\n  // is this on all textures?\n  scale?: number;\n  // is this on all textures?\n  strength?: number;\n};\n\ntype GLTFPBRMetallicRoughness = {\n  baseColorTexture?: GLTFTexture;\n  baseColorFactor?: [number, number, number, number];\n  metallicRoughnessTexture?: GLTFTexture;\n  metallicFactor?: number;\n  roughnessFactor?: number;\n};\n\ntype GLTFPBRMaterial = {\n  unlit?: boolean;\n  pbrMetallicRoughness?: GLTFPBRMetallicRoughness;\n  normalTexture?: GLTFTexture;\n  occlusionTexture?: GLTFTexture;\n  emissiveTexture?: GLTFTexture;\n  emissiveFactor?: [number, number, number];\n  alphaMode?: 'MASK' | 'BLEND';\n  alphaCutoff?: number;\n};\n\nexport type ParsePBRMaterialOptions = {\n  /** Debug PBR shader */\n  pbrDebug?: boolean;\n  /** Enable lights */\n  lights?: any;\n  /** Use tangents */\n  useTangents?: boolean;\n  /** provide an image based (texture cube) lighting environment */\n  imageBasedLightingEnvironment?: PBREnvironment;\n};\n\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(\n  device: Device,\n  material: GLTFPBRMaterial,\n  attributes: Record<string, any>,\n  options: ParsePBRMaterialOptions\n): ParsedPBRMaterial {\n  const parsedMaterial: ParsedPBRMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: true,\n      SRGB_FAST_APPROXIMATION: true\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n\n  // TODO - always available\n  parsedMaterial.defines['USE_TEX_LOD'] = true;\n\n  const {imageBasedLightingEnvironment} = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler =\n      imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler =\n      imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n\n  if (options?.pbrDebug) {\n    parsedMaterial.defines['PBR_DEBUG'] = true;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n\n  if (attributes['NORMAL']) parsedMaterial.defines['HAS_NORMALS'] = true;\n  if (attributes['TANGENT'] && options?.useTangents) parsedMaterial.defines['HAS_TANGENTS'] = true;\n  if (attributes['TEXCOORD_0']) parsedMaterial.defines['HAS_UV'] = true;\n\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines['USE_IBL'] = true;\n  if (options?.lights) parsedMaterial.defines['USE_LIGHTS'] = true;\n\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n\n  return parsedMaterial;\n}\n\n/** Parse GLTF material record */\nfunction parseMaterial(\n  device: Device,\n  material: GLTFPBRMaterial,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(\n      device,\n      material.normalTexture,\n      'pbr_normalSampler',\n      'HAS_NORMALMAP',\n      parsedMaterial\n    );\n\n    const {scale = 1} = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(\n      device,\n      material.occlusionTexture,\n      'pbr_occlusionSampler',\n      'HAS_OCCLUSIONMAP',\n      parsedMaterial\n    );\n\n    const {strength = 1} = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(\n      device,\n      material.emissiveTexture,\n      'pbr_emissiveSampler',\n      'HAS_EMISSIVEMAP',\n      parsedMaterial\n    );\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n\n  switch (material.alphaMode || 'MASK') {\n    case 'MASK':\n      const {alphaCutoff = 0.5} = material;\n      parsedMaterial.defines['ALPHA_CUTOFF'] = true;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n\n      // WebGPU style parameters\n      parsedMaterial.parameters.blend = true;\n\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n\n      // GL parameters\n      // TODO - remove in favor of parameters\n      parsedMaterial.glParameters['blend'] = true;\n      parsedMaterial.glParameters['blendEquation'] = GL.FUNC_ADD;\n      parsedMaterial.glParameters['blendFunc'] = [\n        GL.SRC_ALPHA,\n        GL.ONE_MINUS_SRC_ALPHA,\n        GL.ONE,\n        GL.ONE_MINUS_SRC_ALPHA\n      ];\n\n      break;\n  }\n}\n\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(\n  device: Device,\n  pbrMetallicRoughness: GLTFPBRMetallicRoughness,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.baseColorTexture,\n      'pbr_baseColorSampler',\n      'HAS_BASECOLORMAP',\n      parsedMaterial\n    );\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.metallicRoughnessTexture,\n      'pbr_metallicRoughnessSampler',\n      'HAS_METALROUGHNESSMAP',\n      parsedMaterial\n    );\n  }\n  const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(\n  device: Device,\n  gltfTexture: GLTFTexture,\n  uniformName: keyof PBRMaterialBindings,\n  define: string,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n\n  if (image.compressed) {\n    textureOptions = image;\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {data: image};\n  }\n\n  const gltfSampler = {\n    wrapS: 10497, // default REPEAT S (U) wrapping mode.\n    wrapT: 10497, // default REPEAT T (V) wrapping mode.\n    ...gltfTexture?.texture?.sampler\n  } as any;\n\n  const texture: Texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    sampler: convertSampler(gltfSampler),\n    ...textureOptions\n  });\n\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = true;\n  parsedMaterial.generatedTextures.push(texture);\n}\n\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: true,\n      SRGB_FAST_APPROXIMATION: true\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = true;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = true;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO: convert in loaders.gl?\n\nimport type {SamplerProps} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\ntype GLTFSampler = {\n  wrapS?: GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT;\n  wrapT?: GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT;\n  magFilter?: GL.NEAREST | GL.LINEAR;\n  minFilter?:\n    | GL.NEAREST\n    | GL.LINEAR\n    | GL.NEAREST_MIPMAP_NEAREST\n    | GL.LINEAR_MIPMAP_NEAREST\n    | GL.NEAREST_MIPMAP_LINEAR\n    | GL.LINEAR_MIPMAP_LINEAR;\n};\n\nexport function convertSampler(gltfSampler: GLTFSampler): SamplerProps {\n  return {\n    addressModeU: convertSamplerWrapMode(gltfSampler.wrapS),\n    addressModeV: convertSamplerWrapMode(gltfSampler.wrapT),\n    magFilter: convertSamplerMagFilter(gltfSampler.magFilter),\n    ...convertSamplerMinFilter(gltfSampler.minFilter)\n  };\n}\n\nfunction convertSamplerWrapMode(\n  mode: GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT | undefined\n): 'clamp-to-edge' | 'repeat' | 'mirror-repeat' | undefined {\n  switch (mode) {\n    case GL.CLAMP_TO_EDGE:\n      return 'clamp-to-edge';\n    case GL.REPEAT:\n      return 'repeat';\n    case GL.MIRRORED_REPEAT:\n      return 'mirror-repeat';\n    default:\n      return undefined;\n  }\n}\n\nfunction convertSamplerMagFilter(\n  mode: GL.NEAREST | GL.LINEAR | undefined\n): 'nearest' | 'linear' | undefined {\n  switch (mode) {\n    case GL.NEAREST:\n      return 'nearest';\n    case GL.LINEAR:\n      return 'linear';\n    default:\n      return undefined;\n  }\n}\n\nfunction convertSamplerMinFilter(\n  mode:\n    | GL.NEAREST\n    | GL.LINEAR\n    | GL.NEAREST_MIPMAP_NEAREST\n    | GL.LINEAR_MIPMAP_NEAREST\n    | GL.NEAREST_MIPMAP_LINEAR\n    | GL.LINEAR_MIPMAP_LINEAR\n    | undefined\n): {minFilter?: 'nearest' | 'linear'; mipmapFilter?: 'nearest' | 'linear'} {\n  switch (mode) {\n    case GL.NEAREST:\n      return {minFilter: 'nearest'};\n    case GL.LINEAR:\n      return {minFilter: 'linear'};\n    case GL.NEAREST_MIPMAP_NEAREST:\n      return {minFilter: 'nearest', mipmapFilter: 'nearest'};\n    case GL.LINEAR_MIPMAP_NEAREST:\n      return {minFilter: 'linear', mipmapFilter: 'nearest'};\n    case GL.NEAREST_MIPMAP_LINEAR:\n      return {minFilter: 'nearest', mipmapFilter: 'linear'};\n    case GL.LINEAR_MIPMAP_LINEAR:\n      return {minFilter: 'linear', mipmapFilter: 'linear'};\n    default:\n      return {};\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, type PrimitiveTopology} from '@luma.gl/core';\nimport {Geometry, GeometryAttribute, GroupNode, ModelNode, type ModelProps} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\nimport {\n  type GLTFMeshPostprocessed,\n  type GLTFNodePostprocessed,\n  type GLTFPostprocessed\n} from '@loaders.gl/gltf';\nimport {type GLTFScenePostprocessed} from '@loaders.gl/gltf/dist/lib/types/gltf-postprocessed-schema';\n\nimport {type PBREnvironment} from '../pbr/pbr-environment';\nimport {convertGLDrawModeToTopology} from '../webgl-to-webgpu/convert-webgl-topology';\nimport {createGLTFModel} from '../gltf/create-gltf-model';\n\nimport {parsePBRMaterial} from './parse-pbr-material';\n\nexport type ParseGLTFOptions = {\n  modelOptions?: Partial<ModelProps>;\n  pbrDebug?: boolean;\n  imageBasedLightingEnvironment?: PBREnvironment;\n  lights?: boolean;\n  useTangents?: boolean;\n};\n\nconst defaultOptions: Required<ParseGLTFOptions> = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: undefined!,\n  lights: true,\n  useTangents: false\n};\n\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport function parseGLTF(\n  device: Device,\n  gltf: GLTFPostprocessed,\n  options_: ParseGLTFOptions = {}\n): GroupNode[] {\n  const options = {...defaultOptions, ...options_};\n  const sceneNodes = gltf.scenes.map(gltfScene =>\n    createScene(device, gltfScene, gltf.nodes, options)\n  );\n  return sceneNodes;\n}\n\nfunction createScene(\n  device: Device,\n  gltfScene: GLTFScenePostprocessed,\n  gltfNodes: GLTFNodePostprocessed[],\n  options: Required<ParseGLTFOptions>\n): GroupNode {\n  const gltfSceneNodes = gltfScene.nodes || [];\n  const nodes = gltfSceneNodes.map(node => createNode(device, node, gltfNodes, options));\n  const sceneNode = new GroupNode({\n    id: gltfScene.name || gltfScene.id,\n    children: nodes\n  });\n  return sceneNode;\n}\n\nfunction createNode(\n  device: Device,\n  gltfNode: GLTFNodePostprocessed & {_node?: GroupNode},\n  gltfNodes: GLTFNodePostprocessed[],\n  options: Required<ParseGLTFOptions>\n): GroupNode {\n  if (!gltfNode._node) {\n    const gltfChildren = gltfNode.children || [];\n    const children = gltfChildren.map(child => createNode(device, child, gltfNodes, options));\n\n    // Node can have children nodes and meshes at the same time\n    if (gltfNode.mesh) {\n      children.push(createMesh(device, gltfNode.mesh, options));\n    }\n\n    const node = new GroupNode({\n      id: gltfNode.name || gltfNode.id,\n      children\n    });\n\n    if (gltfNode.matrix) {\n      node.setMatrix(gltfNode.matrix);\n    } else {\n      node.matrix.identity();\n\n      if (gltfNode.translation) {\n        node.matrix.translate(gltfNode.translation);\n      }\n\n      if (gltfNode.rotation) {\n        const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n        node.matrix.multiplyRight(rotationMatrix);\n      }\n\n      if (gltfNode.scale) {\n        node.matrix.scale(gltfNode.scale);\n      }\n    }\n    gltfNode._node = node;\n  }\n\n  // Copy _node so that gltf-animator can access\n  const topLevelNode = gltfNodes.find(node => node.id === gltfNode.id) as any;\n  topLevelNode._node = gltfNode._node;\n\n  return gltfNode._node;\n}\n\nfunction createMesh(\n  device: Device,\n  gltfMesh: GLTFMeshPostprocessed & {_mesh?: GroupNode},\n  options: Required<ParseGLTFOptions>\n): GroupNode {\n  // TODO: avoid changing the gltf\n  if (!gltfMesh._mesh) {\n    const gltfPrimitives = gltfMesh.primitives || [];\n    const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n      createPrimitive(device, gltfPrimitive, i, gltfMesh, options)\n    );\n    const mesh = new GroupNode({\n      id: gltfMesh.name || gltfMesh.id,\n      children: primitives\n    });\n    gltfMesh._mesh = mesh;\n  }\n\n  return gltfMesh._mesh;\n}\n\nfunction createPrimitive(\n  device: Device,\n  gltfPrimitive: any,\n  i: number,\n  gltfMesh: GLTFMeshPostprocessed,\n  options: Required<ParseGLTFOptions>\n): ModelNode {\n  const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n  const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n  const vertexCount = gltfPrimitive.indices\n    ? gltfPrimitive.indices.count\n    : getVertexCount(gltfPrimitive.attributes);\n\n  const geometry = createGeometry(id, gltfPrimitive, topology);\n\n  const parsedPPBRMaterial = parsePBRMaterial(\n    device,\n    gltfPrimitive.material,\n    geometry.attributes,\n    options\n  );\n\n  const modelNode = createGLTFModel(device, {\n    id,\n    geometry: createGeometry(id, gltfPrimitive, topology),\n    parsedPPBRMaterial,\n    modelOptions: options.modelOptions,\n    vertexCount\n  });\n\n  modelNode.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n  // TODO this holds on to all the CPU side texture and attribute data\n  // modelNode.material =  gltfPrimitive.material;\n\n  return modelNode;\n}\n\nfunction getVertexCount(attributes: any) {\n  throw new Error('getVertexCount not implemented');\n}\n\nfunction createGeometry(id: string, gltfPrimitive: any, topology: PrimitiveTopology): Geometry {\n  const attributes: Record<string, GeometryAttribute> = {};\n  for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n    const {components, size, value} = attribute as GeometryAttribute;\n\n    attributes[attributeName] = {size: size ?? components, value};\n  }\n\n  return new Geometry({\n    id,\n    topology,\n    indices: gltfPrimitive.indices.value,\n    attributes\n  });\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PrimitiveTopology} from '@luma.gl/core';\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nexport enum GLEnum {\n  POINTS = 0x0,\n  LINES = 0x1,\n  LINE_LOOP = 0x2,\n  LINE_STRIP = 0x3,\n  TRIANGLES = 0x4,\n  TRIANGLE_STRIP = 0x5,\n  TRIANGLE_FAN = 0x6\n}\n\nexport function convertGLDrawModeToTopology(\n  drawMode:\n    | GLEnum.POINTS\n    | GLEnum.LINES\n    | GLEnum.LINE_STRIP\n    | GLEnum.LINE_LOOP\n    | GLEnum.TRIANGLES\n    | GLEnum.TRIANGLE_STRIP\n    | GLEnum.TRIANGLE_FAN\n): PrimitiveTopology {\n  // prettier-ignore\n  switch (drawMode) {\n    case GLEnum.POINTS: return 'point-list';\n    case GLEnum.LINES: return 'line-list';\n    case GLEnum.LINE_STRIP: return 'line-strip';\n    case GLEnum.TRIANGLES: return 'triangle-list';\n    case GLEnum.TRIANGLE_STRIP: return 'triangle-strip';\n    default: throw new Error(String(drawMode));\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, type RenderPipelineParameters, log} from '@luma.gl/core';\nimport {pbrMaterial, ShaderModule} from '@luma.gl/shadertools';\nimport {Geometry, Model, ModelNode, type ModelProps} from '@luma.gl/engine';\nimport {type ParsedPBRMaterial} from '../pbr/pbr-material';\n\nconst SHADER = /* WGSL */ `\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = /* glsl */ `\\\n#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n`;\n\nconst fs = /* glsl */ `\\\n#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\nexport type CreateGLTFModelOptions = {\n  id?: string;\n  vertexCount?: number;\n  geometry: Geometry;\n  parsedPPBRMaterial: ParsedPBRMaterial;\n  modelOptions?: Partial<ModelProps>;\n};\n\n/** Creates a luma.gl Model from GLTF data*/\nexport function createGLTFModel(device: Device, options: CreateGLTFModelOptions): ModelNode {\n  const {id, geometry, parsedPPBRMaterial, vertexCount, modelOptions = {}} = options;\n\n  log.info(4, 'createGLTFModel defines: ', parsedPPBRMaterial.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources: any[] = [];\n  // managedResources.push(...parsedMaterial.generatedTextures);\n  // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n\n  const parameters: RenderPipelineParameters = {\n    depthWriteEnabled: true,\n    depthCompare: 'less',\n    depthFormat: 'depth24plus',\n    cullMode: 'back'\n  };\n\n  const modelProps: ModelProps = {\n    id,\n    source: SHADER,\n    vs,\n    fs,\n    geometry,\n    topology: geometry.topology,\n    vertexCount,\n    modules: [pbrMaterial as unknown as ShaderModule],\n    ...modelOptions,\n\n    defines: {...parsedPPBRMaterial.defines, ...modelOptions.defines},\n    parameters: {...parameters, ...parsedPPBRMaterial.parameters, ...modelOptions.parameters}\n  };\n\n  const model = new Model(device, modelProps);\n\n  const {camera, ...pbrMaterialProps} = {\n    ...parsedPPBRMaterial.uniforms,\n    ...modelOptions.uniforms,\n    ...parsedPPBRMaterial.bindings,\n    ...modelOptions.bindings\n  };\n\n  model.shaderInputs.setProps({pbrMaterial: pbrMaterialProps, pbrProjection: {camera}});\n  return new ModelNode({managedResources, model});\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {GLTFNodePostprocessed} from '@loaders.gl/gltf';\nimport {log} from '@luma.gl/core';\nimport {GroupNode} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\nimport {GLTFAnimation} from './animations/animations';\nimport {interpolate} from './animations/interpolate';\n\ntype GLTFSingleAnimatorProps = {\n  animation: GLTFAnimation;\n  startTime?: number;\n  playing?: boolean;\n  speed?: number;\n};\n\nclass GLTFSingleAnimator {\n  animation: GLTFAnimation;\n  startTime: number = 0;\n  playing: boolean = true;\n  speed: number = 1;\n\n  constructor(props: GLTFSingleAnimatorProps) {\n    this.animation = props.animation;\n    this.animation.name ||= 'unnamed';\n    Object.assign(this, props);\n  }\n\n  setTime(timeMs: number) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.animation.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, (target as any)._node as GroupNode);\n    });\n  }\n}\n\nexport type GLTFAnimatorProps = {\n  animations: GLTFAnimation[];\n};\n\nexport class GLTFAnimator {\n  animations: GLTFSingleAnimator[];\n\n  constructor(props: GLTFAnimatorProps) {\n    this.animations = props.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      return new GLTFSingleAnimator({\n        animation: {name, channels: animation.channels}\n      });\n    });\n  }\n\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time: number): void {\n    log.warn('GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead')();\n    this.setTime(time);\n  }\n\n  setTime(time: number): void {\n    this.animations.forEach(animation => animation.setTime(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n\n// TODO: share with GLTFInstantiator\nconst scratchMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode: GLTFNodePostprocessed, node: GroupNode) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = scratchMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n", "import {GLTFNodePostprocessed} from '@loaders.gl/gltf';\nimport {log} from '@luma.gl/core';\nimport {Quaternion} from '@math.gl/core';\nimport {GLTFAnimationChannel, GLTFAnimationSampler} from './animations';\n\nconst scratchQuaternion = new Quaternion();\n\nexport function interpolate(\n  time: number,\n  {input, interpolation, output}: GLTFAnimationSampler,\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path']\n) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex] as number[]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(\n          target,\n          path,\n          output[previousIndex] as number[],\n          output[nextIndex] as number[],\n          ratio\n        );\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1] as number[];\n        const outTangent0 = output[3 * previousIndex + 2] as number[];\n        const inTangent1 = output[3 * nextIndex + 0] as number[];\n        const p1 = output[3 * nextIndex + 1] as number[];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nfunction linearInterpolate(\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path'],\n  start: number[],\n  stop: number[],\n  ratio: number\n) {\n  if (!target[path]) {\n    throw new Error();\n  }\n\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    scratchQuaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < scratchQuaternion.length; i++) {\n      target[path][i] = scratchQuaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path'],\n  {\n    p0,\n    outTangent0,\n    inTangent1,\n    p1,\n    tDiff,\n    ratio: t\n  }: {\n    p0: number[];\n    outTangent0: number[];\n    inTangent1: number[];\n    p1: number[];\n    tDiff: number;\n    ratio: number;\n  }\n) {\n  if (!target[path]) {\n    throw new Error();\n  }\n\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path'],\n  value: number[]\n) {\n  if (!target[path]) {\n    throw new Error();\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO: convert in loaders.gl?\nimport type {TypedArray} from '@math.gl/types';\n\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS: Record<string, number> = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY: Record<number, any> = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\ntype GLTFAccessor = {\n  componentType: number;\n  type: string;\n  count: number;\n  bufferView?: {data: {buffer: ArrayBuffer; byteOffset?: number}};\n  byteOffset?: number;\n};\n\nexport function accessorToTypedArray(accessor: GLTFAccessor): {\n  typedArray: TypedArray;\n  components: number;\n} {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const length = components * accessor.count;\n  const {buffer, byteOffset = 0} = accessor.bufferView?.data ?? {};\n\n  const typedArray = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n  return {typedArray, components};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {type GLTFAccessorPostprocessed, type GLTFPostprocessed} from '@loaders.gl/gltf';\nimport {\n  type GLTFAnimation,\n  type GLTFAnimationChannel,\n  type GLTFAnimationSampler\n} from '../gltf/animations/animations';\n\nimport {accessorToTypedArray} from '..//webgl-to-webgpu/convert-webgl-attribute';\n\nexport function parseGLTFAnimations(gltf: GLTFPostprocessed): GLTFAnimation[] {\n  const gltfAnimations = gltf.animations || [];\n  return gltfAnimations.map((animation, index) => {\n    const name = animation.name || `Animation-${index}`;\n    const samplers: GLTFAnimationSampler[] = animation.samplers.map(\n      ({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]) as number[],\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      })\n    );\n    const channels: GLTFAnimationChannel[] = animation.channels.map(({sampler, target}) => ({\n      sampler: samplers[sampler],\n      target: gltf.nodes[target.node ?? 0],\n      path: target.path as GLTFAnimationChannel['path']\n    }));\n    return {name, channels};\n  });\n}\n\n//\n\nfunction accessorToJsArray(\n  accessor: GLTFAccessorPostprocessed & {_animation?: number[] | number[][]}\n): number[] | number[][] {\n  if (!accessor._animation) {\n    const {typedArray: array, components} = accessorToTypedArray(accessor);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray: number[][] = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n", "/** Deeply copies a JS data structure */\nexport function deepCopy(object: any): any {\n  // don't copy binary data\n  if (\n    ArrayBuffer.isView(object) ||\n    object instanceof ArrayBuffer ||\n    object instanceof ImageBitmap\n  ) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result: typeof object = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '@luma.gl/core';\nimport {GroupNode} from '@luma.gl/engine';\nimport {GLTFPostprocessed} from '@loaders.gl/gltf';\nimport {parseGLTF, type ParseGLTFOptions} from '../parsers/parse-gltf';\nimport {GLTFAnimator} from './gltf-animator';\nimport {parseGLTFAnimations} from '../parsers/parse-gltf-animations';\nimport {deepCopy} from '../utils/deep-copy';\n\nexport function createScenegraphsFromGLTF(\n  device: Device,\n  gltf: GLTFPostprocessed,\n  options?: ParseGLTFOptions\n): {\n  scenes: GroupNode[];\n  animator: GLTFAnimator;\n} {\n  gltf = deepCopy(gltf);\n  const scenes = parseGLTF(device, gltf, options);\n  // Note: There is a nasty dependency on injected nodes in the glTF\n  const animations = parseGLTFAnimations(gltf);\n  const animator = new GLTFAnimator({animations});\n  return {scenes, animator};\n}\n"],
  "mappings": "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",
  "names": ["import_constants", "import_engine", "import_core", "GLEnum", "import_core", "import_engine", "import_core", "import_core"]
}
