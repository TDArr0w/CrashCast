{"version":3,"file":"OrthogonalLine.js","sourceRoot":"","sources":["../../../../../src/.internal/core/render/OrthogonalLine.ts"],"names":[],"mappings":"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","sourcesContent":["import { Graphics, IGraphicsSettings, IGraphicsPrivate } from \"./Graphics\";\nimport type { IPoint } from \"../util/IPoint\";\n\nexport interface IOrthogonalLineSettings extends IGraphicsSettings {\n\n\t/**\n\t * A list of [[IPoint]] (x/y coordinates) points for the Orthogonal Line.\n\t */\n\tpoints?: Array<IPoint>;\n\n\t/**\n\t * Corner radius between segments.\n\t */\n\tcornerRadius?: number;\n}\n\nexport interface IOrthogonalLinePrivate extends IGraphicsPrivate {\n}\n\n/**\n * Draws an Orthogonal line.\n *\n * @important\n * @since 5.14.0\n */\nexport class OrthogonalLine extends Graphics {\n\n\tdeclare public _settings: IOrthogonalLineSettings;\n\tdeclare public _privateSettings: IOrthogonalLinePrivate;\n\n\tpublic static className: string = \"OrthogonalLine\";\n\tpublic static classNames: Array<string> = Graphics.classNames.concat([OrthogonalLine.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"points\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tpublic static makeOrthogonal(points: Array<IPoint>): Array<IPoint> {\n\t\t// Insert intermediate points to ensure only orthogonal (horizontal/vertical) segments\n\t\tif (points.length > 1) {\n\t\t\tconst orthogonalPoints: Array<IPoint> = [];\n\t\t\tfor (let i = 0; i < points.length - 1; i++) {\n\t\t\t\tconst curr = points[i];\n\t\t\t\tconst next = points[i + 1];\n\t\t\t\torthogonalPoints.push(curr);\n\n\t\t\t\t// If the segment is not orthogonal, insert an intermediate point\n\t\t\t\tif (curr.x !== next.x && curr.y !== next.y) {\n\t\t\t\t\torthogonalPoints.push({ x: next.x, y: curr.y });\n\t\t\t\t}\n\t\t\t}\n\t\t\torthogonalPoints.push(points[points.length - 1]);\n\t\t\tpoints = orthogonalPoints;\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Handles changes and redraws the orthogonal line with optional rounded corners.\n\t */\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this._clear) {\n\t\t\tconst display = this._display;\n\t\t\tlet points: Array<IPoint> = this.get(\"points\", []);\n\n\n\t\t\t// Early exit if no points\n\t\t\tif (points.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpoints = OrthogonalLine.makeOrthogonal(points);\n\n\t\t\tdisplay.moveTo(points[0].x, points[0].y);\n\n\t\t\t// Draw the orthogonal line with optional rounded corners\n\t\t\tfor (let i = 1; i < points.length; i++) {\n\t\t\t\tlet cornerRadius = this.get(\"cornerRadius\", 0);\n\t\t\t\tconst prev = points[i - 1];\n\t\t\t\tconst curr = points[i];\n\t\t\t\tconst next = points[i + 1];\n\n\t\t\t\tconst isHorizontal = curr.y === prev.y && curr.x !== prev.x;\n\t\t\t\tconst isVertical = curr.x === prev.x && curr.y !== prev.y;\n\n\t\t\t\t// Only add rounded corners if direction changes\n\t\t\t\tconst directionChanged =\n\t\t\t\t\tnext &&\n\t\t\t\t\t((isHorizontal && next.y !== curr.y) ||\n\t\t\t\t\t\t(isVertical && next.x !== curr.x));\n\n\t\t\t\tif (\n\t\t\t\t\tcornerRadius > 0 &&\n\t\t\t\t\tnext &&\n\t\t\t\t\tdirectionChanged\n\t\t\t\t) {\n\t\t\t\t\tif (isVertical) {\n\t\t\t\t\t\tcornerRadius = Math.min(cornerRadius, Math.abs(curr.x - next.x) / 2, Math.abs(curr.y - prev.y) / 2);\n\t\t\t\t\t\tconst signY = Math.sign(curr.y - prev.y);\n\t\t\t\t\t\tdisplay.lineTo(curr.x, curr.y - cornerRadius * signY);\n\n\t\t\t\t\t\tconst signX = next.x < curr.x ? -1 : 1;\n\t\t\t\t\t\tdisplay.arcTo(\n\t\t\t\t\t\t\tcurr.x,\n\t\t\t\t\t\t\tcurr.y,\n\t\t\t\t\t\t\tcurr.x + cornerRadius * signX,\n\t\t\t\t\t\t\tcurr.y,\n\t\t\t\t\t\t\tcornerRadius\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (isHorizontal) {\n\t\t\t\t\t\tcornerRadius = Math.min(cornerRadius, Math.abs(curr.y - next.y) / 2, Math.abs(curr.x - prev.x) / 2);\n\t\t\t\t\t\tconst signX = Math.sign(curr.x - prev.x);\n\t\t\t\t\t\tdisplay.lineTo(curr.x - cornerRadius * signX, curr.y);\n\n\t\t\t\t\t\tconst signY = next.y < curr.y ? -1 : 1;\n\t\t\t\t\t\tdisplay.arcTo(\n\t\t\t\t\t\t\tcurr.x,\n\t\t\t\t\t\t\tcurr.y,\n\t\t\t\t\t\t\tcurr.x,\n\t\t\t\t\t\t\tcurr.y + cornerRadius * signY,\n\t\t\t\t\t\t\tcornerRadius\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Draw straight segment\n\t\t\t\t\tdisplay.lineTo(curr.x, curr.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n}\n"]}