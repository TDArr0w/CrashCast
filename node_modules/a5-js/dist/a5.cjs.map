{"version":3,"sources":["../modules/index.ts","../node_modules/gl-matrix/esm/common.js","../node_modules/gl-matrix/esm/mat2.js","../node_modules/gl-matrix/esm/mat3.js","../node_modules/gl-matrix/esm/quat.js","../node_modules/gl-matrix/esm/vec3.js","../node_modules/gl-matrix/esm/vec4.js","../node_modules/gl-matrix/esm/vec2.js","../modules/core/constants.ts","../modules/geometry/pentagon.ts","../modules/core/pentagon.ts","../modules/projections/authalic.ts","../modules/core/coordinate-transforms.ts","../modules/core/dodecahedron-quaternions.ts","../modules/core/origin.ts","../modules/projections/gnomonic.ts","../modules/utils/vector.ts","../modules/geometry/spherical-polygon.ts","../modules/geometry/spherical-triangle.ts","../modules/projections/polyhedral.ts","../modules/core/hilbert.ts","../modules/core/tiling.ts","../modules/projections/crs.ts","../modules/projections/dodecahedron.ts","../modules/core/serialization.ts","../modules/core/cell.ts","../modules/core/hex.ts","../modules/core/cell-info.ts"],"sourcesContent":["// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport {glMatrix} from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\n\n// PUBLIC API\n// Indexing\nexport {cellToBoundary, cellToLonLat, lonLatToCell} from './core/cell';\nexport {hexToU64, u64ToHex} from './core/hex';\n\n// Hierarchy\nexport {cellToParent, cellToChildren, getResolution, getRes0Cells} from './core/serialization';\nexport {getNumCells, cellArea} from './core/cell-info';\n\n// Types\nexport type {Degrees, Radians} from './core/coordinate-systems';\nexport type {A5Cell} from './core/utils';","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\n\nexport function fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\n\nexport function set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the source matrix\n * @returns {mat2} out\n */\n\nexport function adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\n * Calculates the determinant of a mat2\n *\n * @param {ReadonlyMat2} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nexport function rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\n\nexport function scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat2} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\n * Returns a string representation of a mat2\n *\n * @param {ReadonlyMat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {ReadonlyMat2} L the lower triangular matrix\n * @param {ReadonlyMat2} D the diagonal matrix\n * @param {ReadonlyMat2} U the upper triangular matrix\n * @param {ReadonlyMat2} a the input matrix to factorize\n */\n\nexport function LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @returns {mat2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat2} a The first matrix.\n * @param {ReadonlyMat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {ReadonlyMat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {ReadonlyMat2} a the first operand\n * @param {ReadonlyMat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\n\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\n\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\n * Returns a string representation of a quatenion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var clone = vec4.clone;\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var fromValues = vec4.fromValues;\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nexport var copy = vec4.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nexport var set = vec4.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nexport var add = vec4.add;\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nexport var scale = vec4.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nexport var dot = vec4.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\n\nexport var lerp = vec4.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport var length = vec4.length;\n/**\n * Alias for {@link quat.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nexport var normalize = vec4.normalize;\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat} a The first vector.\n * @param {ReadonlyQuat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var equals = vec4.equals;\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport type { Radians } from \"./coordinate-systems\";\n\n// Golden ratio\nexport const φ = (1 + Math.sqrt(5)) / 2;\n\nexport const TWO_PI = 2 * Math.PI as Radians;\nexport const TWO_PI_OVER_5 = 2 * Math.PI / 5 as Radians;\nexport const PI_OVER_5 = Math.PI / 5 as Radians;\nexport const PI_OVER_10 = Math.PI / 10 as Radians;\n\n// Angles between faces\nexport const dihedralAngle = 2 * Math.atan(φ) as Radians; // Angle between pentagon faces (radians) = 116.565°\nexport const interhedralAngle = Math.PI - dihedralAngle as Radians; // Angle between pentagon faces (radians) = 63.435°\nexport const faceEdgeAngle = -0.5 * Math.PI + Math.acos(-1 / Math.sqrt(3 - φ)) as Radians; // = 58.28252558853899\n\n// Distance from center to edge of pentagon face\nexport const distanceToEdge = (Math.sqrt(5) - 1) / 2; // φ - 1;\nexport const distanceToVertex = 3 - Math.sqrt(5); // 2 * (2 - φ);\n\n// Dodecahedron sphere radii (normalized to unit radius for inscribed sphere)\n/**\n * Radius of the inscribed sphere in dodecahedron\n */\nexport const Rinscribed = 1;\n\n/**\n * Radius of the sphere that touches the dodecahedron's edge midpoints\n */\nexport const Rmidedge = Math.sqrt(3 - φ);\n\n/**\n * Radius of the circumscribed sphere for dodecahedron\n */\nexport const Rcircumscribed = Math.sqrt(3) * Rmidedge / φ;","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport {vec2, mat2, mat2d, glMatrix} from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport type { Face } from '../core/coordinate-systems';\n\nexport type Pentagon = [Face, Face, Face, Face, Face];\n\nexport class PentagonShape {\n  private vertices: Pentagon;\n\n  constructor(vertices: Pentagon) {\n    this.vertices = vertices;\n    if (!this.isWindingCorrect()) {\n      this.vertices.reverse();\n    }\n  }\n\n  getArea(): number {\n    let signedArea = 0;\n    const N = this.vertices.length;\n    for (let i = 0; i < N; i++) {\n      const j = (i + 1) % N;\n      signedArea += (this.vertices[j][0] - this.vertices[i][0]) * (this.vertices[j][1] + this.vertices[i][1]);\n    }\n    return signedArea;\n  }\n\n  private isWindingCorrect(): boolean {\n    return this.getArea() >= 0;\n  }\n\n  getVertices(): Pentagon {\n    return this.vertices;\n  }\n\n  scale(scale: number): PentagonShape {\n    for (const vertex of this.vertices) {\n      vec2.scale(vertex, vertex, scale);\n    }\n    return this;\n  }\n\n  /**\n   * Rotates the pentagon 180 degrees (equivalent to negating x & y)\n   * @returns The rotated pentagon\n   */\n  rotate180(): PentagonShape {\n    for (const vertex of this.vertices) {\n      vec2.negate(vertex, vertex);\n    }\n    return this;\n  }\n\n  /**\n   * Reflects the pentagon over the x-axis (equivalent to negating y)\n   * and reverses the winding order to maintain consistent orientation\n   * @returns The reflected pentagon\n   */\n  reflectY(): PentagonShape {\n    // First reflect all vertices\n    for (const vertex of this.vertices) {\n      vertex[1] = -vertex[1];\n    }\n    \n    // Then reverse the winding order to maintain consistent orientation\n    this.vertices.reverse();\n    \n    return this;\n  }\n\n  translate(translation: vec2): PentagonShape {\n    for (const vertex of this.vertices) {\n      vec2.add(vertex, vertex, translation);\n    }\n    return this;\n  }\n\n  transform(transform: mat2): PentagonShape {\n    for (const vertex of this.vertices) {\n      vec2.transformMat2(vertex, vertex, transform);\n    }\n    return this;\n  }\n\n  transform2d(transform: mat2d): PentagonShape {\n    for (const vertex of this.vertices) {\n      vec2.transformMat2d(vertex, vertex, transform);\n    }\n    return this;\n  }\n\n  clone(): PentagonShape {\n    const newPentagon = new PentagonShape(this.vertices.map(v => vec2.clone(v)) as Pentagon);\n    return newPentagon;\n  }\n\n  getCenter(): Face {\n    const n = this.vertices.length;\n    const sum = this.vertices.reduce((sum, v) => [sum[0] + v[0] / n, sum[1] + v[1] / n], [0, 0]);\n    return sum as Face;\n  }\n\n  /**\n   * Tests if a point is inside the pentagon by checking if it's on the correct side of all edges.\n   * Assumes consistent winding order (counter-clockwise).\n   * @param point The point to test\n   * @returns 1 if point is inside, otherwise a negative value proportional to the distance from the point to the edge\n   */\n  containsPoint(point: vec2): number {\n    // TODO later we can likely remove this, but for now it's useful for debugging\n    if (!this.isWindingCorrect()) {\n      throw new Error(\"Pentagon is not counter-clockwise\");\n    }\n\n    const N = this.vertices.length;\n    let dMax = 1;\n    for (let i = 0; i < N; i++) {\n      const v1 = this.vertices[i];\n      const v2 = this.vertices[(i + 1) % N];\n      \n      // Calculate the cross product to determine which side of the line the point is on\n      // (v1 - v2) × (point - v1)\n      const dx = v1[0] - v2[0];\n      const dy = v1[1] - v2[1];\n      const px = point[0] - v1[0];\n      const py = point[1] - v1[1];\n      \n      // Cross product: dx * py - dy * px\n      // If positive, point is on the wrong side\n      // If negative, point is on the correct side\n      const crossProduct = (dx * py - dy * px);\n      if (crossProduct < 0) {\n        // Only normalize by distance of point to edge as we can assume the edges of the\n        // pentagon are all the same length\n        const pLength = Math.sqrt(px * px + py * py);\n        dMax = Math.min(dMax, crossProduct / pLength);\n      }\n    }\n    \n    return dMax;\n  }\n\n  /**\n   * Splits each edge of the pentagon into the specified number of segments\n   * @param segments Number of segments to split each edge into\n   * @returns A new PentagonShape with more vertices, or the original PentagonShape if segments <= 1\n   */\n  splitEdges(segments: number): PentagonShape {\n    if (segments <= 1) {\n      return this;\n    }\n\n    const newVertices: Face[] = [];\n    const N = this.vertices.length;\n    \n    for (let i = 0; i < N; i++) {\n      const v1 = this.vertices[i];\n      const v2 = this.vertices[(i + 1) % N];\n      \n      // Add the current vertex\n      newVertices.push(vec2.clone(v1) as Face);\n      \n      // Add interpolated points along the edge (excluding the endpoints)\n      for (let j = 1; j < segments; j++) {\n        const t = j / segments;\n        const interpolated = vec2.create();\n        vec2.lerp(interpolated, v1, v2, t);\n        newVertices.push(interpolated as Face);\n      }\n    }\n    \n    return new PentagonShape(newVertices as Pentagon);\n  }\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { vec2, mat2, glMatrix } from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport {distanceToEdge, PI_OVER_10, PI_OVER_5} from './constants';    \nimport {PentagonShape} from '../geometry/pentagon';\nimport type { Face, Degrees } from \"./coordinate-systems\";\n\n// Pentagon vertex angles\nconst A = 72 as Degrees;\nconst B = 127.94543761193603 as Degrees;\nconst C = 108 as Degrees;\nconst D = 82.29202980963508 as Degrees;\nconst E = 149.7625318412527 as Degrees;\n\nlet a: Face = [0, 0] as Face;\nlet b: Face = [0, 1] as Face;\n// c & d calculated by circle intersections. Perhaps can obtain geometrically.\nlet c: Face = [0.7885966681787006, 1.6149108024237764] as Face;\nlet d: Face = [1.6171013659387945, 1.054928690397459] as Face;\nlet e: Face = [Math.cos(PI_OVER_10), Math.sin(PI_OVER_10)] as Face;\n\n// Distance to edge midpoint\nconst edgeMidpointD = 2 * vec2.length(c) * Math.cos(PI_OVER_5);\n\n// Lattice growth direction is AC, want to rotate it so that it is parallel to x-axis\nconst BASIS_ROTATION = PI_OVER_5 - Math.atan2(c[1], c[0]); // -27.97 degrees\n\n// Scale to match unit sphere\nconst scale = 2 * distanceToEdge / edgeMidpointD;\n[a,b,c,d,e].forEach(v => {\n  vec2.scale(v, v, scale);\n  vec2.rotate(v, v, [0, 0], BASIS_ROTATION);\n});\n\n/**\n * Definition of pentagon used for tiling the plane.\n * While this pentagon is not equilateral, it forms a tiling with 5 fold\n * rotational symmetry and thus can be used to tile a regular pentagon.\n */\nconst PENTAGON = new PentagonShape([a, b, c, d, e]);\n\nconst bisectorAngle = Math.atan2(c[1], c[0]) - PI_OVER_5;\n\n// Define triangle also, as UVW\nconst u: Face = [0, 0] as Face;\nconst L = distanceToEdge / Math.cos(PI_OVER_5);\n\nconst V = bisectorAngle + PI_OVER_5;\nconst v: Face = [L * Math.cos(V), L * Math.sin(V)] as Face;\n\nconst W = bisectorAngle - PI_OVER_5;\nconst w: Face = [L * Math.cos(W), L * Math.sin(W)] as Face;\nconst TRIANGLE = new PentagonShape([u, v, w] as any);\n\n/**\n * Basis vectors used to layout primitive unit\n */\nconst BASIS: mat2 = mat2.fromValues(v[0], v[1], w[0], w[1]);\nconst BASIS_INVERSE: mat2 = mat2.invert(mat2.create(), BASIS);\n\nexport {A, B, C, D, E, a, b, c, d, e, PENTAGON, u, v, w, V, TRIANGLE, BASIS, BASIS_INVERSE};\n","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport type { Radians } from \"../core/coordinate-systems\";\n\n// Authalic conversion coefficients obtained from: https://arxiv.org/pdf/2212.05818\n// See: authalic_constants.py for the derivation of the coefficients\nconst GEODETIC_TO_AUTHALIC = new Float64Array([\n  -2.2392098386786394e-03,\n  2.1308606513250217e-06,\n  -2.5592576864212742e-09,\n  3.3701965267802837e-12,\n  -4.6675453126112487e-15,\n  6.6749287038481596e-18\n]);\n\nconst AUTHALIC_TO_GEODETIC = new Float64Array([\n  2.2392089963541657e-03,\n  2.8831978048607556e-06,\n  5.0862207399726603e-09,\n  1.0201812377816100e-11,\n  2.1912872306767718e-14,\n  4.9284235482523806e-17\n]);\n\n// Adaptation of applyCoefficients from DGGAL project: authalic.ec\n//\n// BSD 3-Clause License\n// \n// Copyright (c) 2014-2025, Ecere Corporation\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n// \n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n// \n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n// \n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nexport class AuthalicProjection {\n  /**\n   * Applies coefficients using Clenshaw summation algorithm (order 6)\n   * @param phi Angle in radians\n   * @param C Array of coefficients\n   * @returns Transformed angle in radians\n   */\n  private applyCoefficients(phi: Radians, C: Float64Array): Radians {\n    const sinPhi = Math.sin(phi);\n    const cosPhi = Math.cos(phi);\n    const X = 2 * (cosPhi - sinPhi) * (cosPhi + sinPhi);\n    let u0, u1;\n\n    u0 = X * C[5] + C[4];\n    u1 = X * u0 + C[3];\n    u0 = X * u1 - u0 + C[2];\n    u1 = X * u0 - u1 + C[1];\n    u0 = X * u1 - u0 + C[0];\n\n    return phi + 2 * sinPhi * cosPhi * u0 as Radians;\n  }\n\n  /**\n   * Converts geodetic latitude to authalic latitude\n   * @param phi Geodetic latitude in radians\n   * @returns Authalic latitude in radians\n   */\n  forward(phi: Radians): Radians {\n    return this.applyCoefficients(phi, GEODETIC_TO_AUTHALIC);\n  }\n\n  /**\n   * Converts authalic latitude to geodetic latitude\n   * @param phi Authalic latitude in radians\n   * @returns Geodetic latitude in radians\n   */\n  inverse(phi: Radians): Radians {\n    return this.applyCoefficients(phi, AUTHALIC_TO_GEODETIC);\n  }\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { vec2, quat, vec3, glMatrix } from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport type { Degrees, Radians, Face, Polar, IJ, Cartesian, Spherical, LonLat, Barycentric, FaceTriangle } from \"./coordinate-systems\";\nimport { BASIS_INVERSE, BASIS } from \"./pentagon\";\nimport { AuthalicProjection } from \"../projections/authalic\";\n\nconst authalic = new AuthalicProjection();\n\nexport type Contour = LonLat[];\n\nexport function degToRad(deg: Degrees): Radians {\n  return deg * (Math.PI / 180) as Radians;\n}\nexport function radToDeg(rad: Radians): Degrees {\n  return rad * (180 / Math.PI) as Degrees;\n}\n\nexport function toPolar(xy: Face): Polar {\n  const rho = vec2.length(xy); // Radial distance from face center\n  const gamma = Math.atan2(xy[1], xy[0]) as Radians; // Azimuthal angle\n  return [rho, gamma] as Polar;\n}\n\nexport function toFace([rho, gamma]: Polar): Face {\n  const x = rho * Math.cos(gamma);\n  const y = rho * Math.sin(gamma);\n  return [x, y] as Face;\n}\n\nexport function FaceToIJ(face: Face): IJ {\n  return vec2.transformMat2(vec2.create(), face, BASIS_INVERSE) as IJ;\n}\n\nexport function IJToFace(ij: IJ): Face {\n  return vec2.transformMat2(vec2.create(), ij, BASIS) as Face;\n}\n\n/**\n * Convert face coordinates to barycentric coordinates\n */\nexport function faceToBarycentric(p: Face, [p1, p2, p3]: FaceTriangle): Barycentric {\n  const d31: [number, number] = [p1[0] - p3[0], p1[1] - p3[1]];\n  const d23: [number, number] = [p3[0] - p2[0], p3[1] - p2[1]];\n  const d3p: [number, number] = [p[0] - p3[0], p[1] - p3[1]];\n  \n  const det = d23[0] * d31[1] - d23[1] * d31[0];\n  const b0 = (d23[0] * d3p[1] - d23[1] * d3p[0]) / det;\n  const b1 = (d31[0] * d3p[1] - d31[1] * d3p[0]) / det;\n  const b2 = 1 - (b0 + b1);\n  return [b0, b1, b2] as Barycentric;\n}\n\n/**\n * Convert barycentric coordinates to face coordinates\n */\nexport function barycentricToFace(b: Barycentric, [p1, p2, p3]: FaceTriangle): Face {\n  return [\n    b[0] * p1[0] + b[1] * p2[0] + b[2] * p3[0],\n    b[0] * p1[1] + b[1] * p2[1] + b[2] * p3[1]\n  ] as Face;\n}\n\nexport function toSpherical(xyz: Cartesian): Spherical {\n  const theta = Math.atan2(xyz[1], xyz[0]);\n  const r = Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);\n  const phi = Math.acos(xyz[2] / r);\n  return [theta, phi] as Spherical;\n}\n\nexport function toCartesian([theta, phi]: Spherical): Cartesian {\n  const sinPhi = Math.sin(phi);\n  const x = sinPhi * Math.cos(theta);\n  const y = sinPhi * Math.sin(theta);\n  const z = Math.cos(phi);\n  return [x, y, z] as Cartesian;\n}\n\n/**\n * Determine the offset longitude for the spherical coordinate system\n * This is the angle between the Greenwich meridian and vector between the centers\n * of the first two origins (dodecahedron face centers)\n * \n * It is chosen such that the majority of the world's population, around 99.9% (and thus land mass) is located\n * in the first 8.5 dodecahedron faces, and thus come first along the Hilbert curve.\n */\nconst LONGITUDE_OFFSET = 93 as Degrees;\n\n/**\n * Convert longitude/latitude to spherical coordinates\n * @param lon Longitude in degrees (0 to 360)\n * @param lat Latitude in degrees (-90 to 90)\n * @returns [theta, phi] in radians\n */\nexport function fromLonLat([longitude, latitude]: LonLat): Spherical {\n  const theta = degToRad(longitude + LONGITUDE_OFFSET as Degrees);\n  \n  const geodeticLat = degToRad(latitude as Degrees);\n  const authalicLat = authalic.forward(geodeticLat);\n  const phi = (Math.PI / 2 - authalicLat) as Radians;\n  return [theta, phi] as Spherical;\n}\n\n/**\n * Convert spherical coordinates to longitude/latitude\n * @param theta Longitude in radians (0 to 2π)\n * @param phi Colatitude in radians (0 to π)\n * @returns [longitude, latitude] in degrees\n */\nexport function toLonLat([theta, phi]: Spherical): LonLat {\n  const longitude = radToDeg(theta) - LONGITUDE_OFFSET as Degrees;\n\n  const authalicLat = Math.PI / 2 - phi as Radians;\n  const geodeticLat = authalic.inverse(authalicLat);\n  const latitude = radToDeg(geodeticLat) as Degrees;\n  return [longitude, latitude] as LonLat;\n}\n\n/**\n * Normalizes longitude values in a contour to handle antimeridian crossing\n * @param contour Array of [longitude, latitude] points\n * @returns Normalized contour with consistent longitude values\n */\nexport function normalizeLongitudes(contour: Contour): Contour {\n  // Calculate center in Cartesian space to avoid poles & antimeridian crossing issues\n  const points = contour.map(lonLat => toCartesian(fromLonLat(lonLat)));\n  const center = vec3.create() as Cartesian;\n  for (const point of points) {\n    vec3.add(center, center, point);\n  }\n  vec3.normalize(center, center);\n  let [centerLon, centerLat] = toLonLat(toSpherical(center));\n  if (centerLat > 89.99 || centerLat < -89.99) {\n    // Near poles, use first point's longitude\n    centerLon = contour[0][0] as Degrees;\n  }\n\n  // Normalize center longitude to be in the range -180 to 180\n  centerLon = ((centerLon + 180) % 360 + 360) % 360 - 180 as Degrees;\n  \n  // Normalize each point relative to center\n  return contour.map(point => {\n    let [longitude, latitude] = point;\n    \n    // Adjust longitude to be closer to center\n    while (longitude - centerLon > 180) longitude = longitude - 360 as Degrees;\n    while (longitude - centerLon < -180) longitude = longitude + 360 as Degrees;\n    return [longitude, latitude] as LonLat;\n  });\n}","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { quat, vec2, glMatrix } from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\n\nconst SQRT5 = Math.sqrt(5);\nconst INV_SQRT5 = Math.sqrt(0.2);\n\n// Dodecahedron face centers (origins) can be defined exactly using trigonometry\n// The north and south poles are just at z=1 and z=-1\n// Then there are two rings at z = ±INV_SQRT5, with radius 2 * INV_SQRT5\n\n// Exact values for defining a regular pentagon (with radius 1). It is correct to use a radius\n// of 1 as we want to obtain the axes of rotations, so the vectors need to be normalized.\n// cos0 = 0;\n// cos36 = (SQRT5 + 1) / 4;\n// cos72 = (SQRT5 - 1) / 4;\n// sin0 = 0;\n// sin36 = Math.sqrt(10 - 2 * SQRT5) / 4;\n// sin72 = Math.sqrt(10 + 2 * SQRT5) / 4;\n//\n// To compute the quaternion use the equation:\n// q = [...sin(alpha) * axis, cos(alpha)]\n// where alpha is the half-angle of rotation from the pole to the face center.\n\n// Sin/cosine of half angle (alpha) of rotation from pole to first ring\n// For the second ring sin -> cos and cos -> -sin by (pi / 2 - x) identities\nconst sinAlpha = Math.sqrt((1 - INV_SQRT5) / 2);\nconst cosAlpha = Math.sqrt((1 + INV_SQRT5) / 2);\n\n// The resulting value simplify a set of expressions. It is much better to compute\n// these directly than using trigonometry\nconst A = 0.5; // sin72 * sinAlpha or sin36 * cosAlpha \nconst B = Math.sqrt((2.5 - SQRT5) / 10); // cos72 * sinAlpha \nconst C = Math.sqrt((2.5 + SQRT5) / 10); // cos36 * cosAlpha\nconst D = Math.sqrt((1 + INV_SQRT5) / 8); // cos36 * sinAlpha\nconst E = Math.sqrt((1 - INV_SQRT5) / 8); // cos72 * cosAlpha\nconst F = Math.sqrt((3 - SQRT5) / 8); // sin36 * sinAlpha\nconst G = Math.sqrt((3 + SQRT5) / 8); // sin72 * cosAlpha\n\n// Face centers projected onto the z=0 plane & normalized\n// 0: North pole,\n// 1-5: First pentagon ring\n// 6-10: Second pentagon ring\n// 11: South pole\nconst faceCenters = [\n  [0, 0], // Doesn't actually matter as rotation is 0\n\n  // First ring: five vertices, CCW, multiplied by sinAlpha\n  [sinAlpha, 0], // [cos0, sin0]\n  [B, A], // [cos72, sin72]\n  [-D, F], // [-cos36, sin36]\n  [-D, -F], // [-cos36, -sin36]\n  [B, -A], // [cos72, -sin72]\n\n  // Second ring: the same five vertices but negated (180deg rotation), multiplied by cosAlpha\n  [-cosAlpha, 0], // [-cos0, -sin0]\n  [-E, -G], // [-cos72, -sin72]\n  [C, -A], // [cos36, -sin36]\n  [C, A], // [cos36, sin36]\n  [-E, G], // [-cos72, sin72]\n\n  [0, 0]\n] as vec2[];\n\n// Obtain by cross product with the z-axis\nconst axes = faceCenters.map(([x, y]) => [-y, x]) as vec2[];\n\n// Quaternions are obtained from axis of rotation & angle of rotation\nconst quaternions = axes.map((axis, i) => {\n  if (i === 0) return [0, 0, 0, 1];\n  if (i === 11) return [0, -1, 0, 0]; // TODO better to use 1, 0, 0, 0?\n  return [...axis, 0, i < 6 ? cosAlpha : sinAlpha];\n}) as quat[];\n\nexport { quaternions };","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { quat, glMatrix } from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport type { Radians, Spherical } from \"./coordinate-systems\";\nimport { interhedralAngle, PI_OVER_5, TWO_PI_OVER_5 } from './constants';\nimport { Orientation } from \"./hilbert\";\nimport type { Origin, OriginId } from './utils';\nimport { quaternions } from './dodecahedron-quaternions';\n\n// Quintant layouts (clockwise & counterclockwise)\nexport const clockwiseFan = ['vu', 'uw', 'vw', 'vw', 'vw'] as Orientation[];\nexport const clockwiseStep = ['wu', 'uw', 'vw', 'vu', 'uw'] as Orientation[];\nexport const counterStep = ['wu', 'uv', 'wv', 'wu', 'uw'] as Orientation[];\nexport const counterJump = ['vu', 'uv', 'wv', 'wu', 'uw'] as Orientation[];\n\nconst QUINTANT_ORIENTATIONS: Orientation[][] = [\n  clockwiseFan,   // 0 Arctic\n  counterJump,    // 1 North America\n  counterStep,    // 2 South America\n\n  clockwiseStep,  // 3 North Atlantic & Western Europe & Africa\n  counterStep,    // 4 South Atlantic & Africa\n  counterJump,    // 5 Europe, Middle East & CentralAfrica\n  \n  counterStep,    // 6 Indian Ocean\n  clockwiseStep,  // 7 Asia\n  clockwiseStep,  // 8 Australia\n\n  clockwiseStep,  // 9 North Pacific\n  counterJump,    // 10 South Pacific\n  counterJump,    // 11 Antarctic\n];\n\n// Within each face, these are the indices of the first quintant\nconst QUINTANT_FIRST = [4, 2, 3,  2, 0, 4,  3, 2, 2,  0, 3, 0];\n\n// Placements of dodecahedron faces along the Hilbert curve\nconst ORIGIN_ORDER = [0, 1, 2,  4, 3, 5,  7, 8, 6,  11, 10, 9];\n\nconst origins: Origin[] = [];\nfunction generateOrigins(): void {\n  // North pole\n  addOrigin([0, 0] as Spherical, 0 as Radians, quaternions[0]);\n\n  // Middle band\n  for (let i = 0; i < 5; i++) {\n    const alpha = i * TWO_PI_OVER_5 as Radians;\n    const alpha2 = alpha + PI_OVER_5 as Radians;\n    addOrigin([alpha, interhedralAngle] as Spherical, PI_OVER_5, quaternions[i + 1]);\n    addOrigin([alpha2, Math.PI - interhedralAngle] as Spherical, PI_OVER_5, quaternions[(i + 3) % 5 + 6]);\n  }\n\n  // South pole\n  addOrigin([0, Math.PI] as Spherical, 0 as Radians, quaternions[11]);\n}\n\nlet originId: OriginId = 0;\nfunction addOrigin(axis: Spherical, angle: Radians, quaternion: quat) {\n  if (originId > 11) {\n    throw new Error(`Too many origins: ${originId}`);\n  }\n  const inverseQuat = quat.create() as quat;\n  quat.conjugate(inverseQuat, quaternion); // quaternion is a unit quaternion, so conjugate is the inverse\n  const origin: Origin = {\n    id: originId,\n    axis,\n    quat: quaternion,\n    inverseQuat,\n    angle,\n    orientation: QUINTANT_ORIENTATIONS[originId],\n    firstQuintant: QUINTANT_FIRST[originId]\n  };\n  origins.push(origin);\n  originId++;\n}\ngenerateOrigins();\n\n// Reorder origins to match the order of the hilbert curve\norigins.sort((a, b) => ORIGIN_ORDER.indexOf(a.id) - ORIGIN_ORDER.indexOf(b.id));\norigins.forEach((origin, i) => origin.id = i as OriginId);\n\nexport { origins };\n\nexport function quintantToSegment(quintant: number, origin: Origin): {segment: number, orientation: Orientation} {\n  // Lookup winding direction of this face\n  const layout = origin.orientation;\n  const step = (layout === clockwiseFan || layout === clockwiseStep) ? -1 : 1;\n\n  // Find (CCW) delta from first quintant of this face\n  const delta = (quintant - origin.firstQuintant + 5) % 5;\n\n  // To look up the orientation, we need to use clockwise/counterclockwise counting\n  const faceRelativeQuintant = (step * delta + 5) % 5;\n  const orientation = layout[faceRelativeQuintant];\n  const segment = (origin.firstQuintant + faceRelativeQuintant) % 5;\n\n  return {segment, orientation};\n}\n\nexport function segmentToQuintant(segment: number, origin: Origin): {quintant: number, orientation: Orientation} {\n  // Lookup winding direction of this face\n  const layout = origin.orientation;\n  const step = (layout === clockwiseFan || layout === clockwiseStep) ? -1 : 1;\n\n  const faceRelativeQuintant = (segment - origin.firstQuintant + 5) % 5;\n  const orientation = layout[faceRelativeQuintant];\n  const quintant = (origin.firstQuintant + step * faceRelativeQuintant + 5) % 5;\n\n  return {quintant, orientation};\n}\n\n/**\n * Find the nearest origin to a point on the sphere\n * Uses haversine formula to calculate great-circle distance\n */\nexport function findNearestOrigin(point: Spherical): Origin {\n  let minDistance = Infinity;\n  let nearest = origins[0];\n  for (const origin of origins) {\n    const distance = haversine(point, origin.axis);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearest = origin;\n    }\n  }\n\n  return nearest;\n}\n\nexport function isNearestOrigin(point: Spherical, origin: Origin): boolean {\n  return haversine(point, origin.axis) > 0.49999999;\n}\n\n/**\n * Modified haversine formula to calculate great-circle distance.\n * Retruns the \"angle\" between the two points. We need to minimize this to find the nearest origin\n * TODO figure out derivation!\n * @param point The point to calculate distance from\n * @param axis The axis to calculate distance to\n * @returns The \"angle\" between the two points\n */ \nexport function haversine(point: Spherical, axis: Spherical): number {\n  const [theta, phi] = point;\n  const [theta2, phi2] = axis;\n  const dtheta = theta2 - theta as Radians;\n  const dphi = phi2 - phi as Radians;\n  const A1 = Math.sin(dphi / 2);\n  const A2 = Math.sin(dtheta / 2);\n  const angle = A1 * A1 + A2 * A2 * Math.sin(phi) * Math.sin(phi2);\n  return angle;\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport type { Polar, Spherical } from '../core/coordinate-systems';\n\nexport class GnomonicProjection {\n  /**\n   * Projects spherical coordinates to polar coordinates using gnomonic projection\n   * @param spherical Spherical coordinates [theta, phi]\n   * @returns Polar coordinates [rho, gamma]\n   */\n  forward([theta, phi]: Spherical): Polar {\n    return [Math.tan(phi), theta] as Polar;\n  }\n\n  /**\n   * Unprojects polar coordinates to spherical coordinates using gnomonic projection\n   * @param polar Polar coordinates [rho, gamma]\n   * @returns Spherical coordinates [theta, phi]\n   */\n  inverse([rho, gamma]: Polar): Spherical {\n    return [gamma, Math.atan(rho)] as Spherical;\n  }\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { vec3 } from 'gl-matrix';\nimport type { Cartesian } from '../core/coordinate-systems';\n\nconst midpointAB = vec3.create() as Cartesian;\nconst crossCD = vec3.create();\nconst scaledA = vec3.create();\nconst scaledB = vec3.create();\n\n/**\n * Returns a difference measure between two vectors, a - b\n * D = sqrt(1 - dot(a,b)) / sqrt(2)\n * D = 1: a and b are perpendicular\n * D = 0: a and b are the same\n * D = NaN: a and b are opposite (shouldn't happen in IVEA as we're using normalized vectors in the same hemisphere)\n * \n * D is a measure of the angle between the two vectors. sqrt(2) can be ignored when comparing ratios.\n * \n * @param A - The first vector\n * @param B - The second vector\n * @returns The difference between the two vectors\n */\nexport function vectorDifference(A: Cartesian, B: Cartesian): number {\n  // Original implementation is unstable for small angles as dot(A, B) approaches 1\n  //return Math.sqrt(1 - vec3.dot(A, B));\n\n  // dot(A, B) = cos(x) as A and B are normalized\n  // Using double angle formula for cos(2x) = 1 - 2sin(x)^2, can rewrite as:\n  // 1 - cos(x) = 2 * sin(x/2)^2)\n  //            = 2 * sin(x/2)^2\n  // ⇒ sqrt(1 - cos(x)) = sqrt(2) * sin(x/2) \n  // Angle x/2 can be obtained as the angle between A and the normalized midpoint of A and B\n  // ⇒ sin(x/2) = |cross(A, midpointAB)|\n  vec3.lerp(midpointAB, A, B, 0.5);\n  vec3.normalize(midpointAB, midpointAB);\n  vec3.cross(midpointAB, A, midpointAB);\n  const D = vec3.length(midpointAB);\n\n  // Math.sin(x) = x for x < 1e-8\n  if (D < 1e-8) {\n    // When A and B are close or equal sin(x/2) ≈ x/2, just take the half-distance between A and B\n    const AB = vec3.subtract(vec3.create(), A, B);\n    const halfDistance = 0.5 * vec3.length(AB);\n    return halfDistance;\n  }\n  return D;\n}\n\n/**\n * Computes the triple product of four vectors\n * @param A - The first vector\n * @param B - The second vector\n * @param C - The third vector\n * @returns The scalar result\n */\nexport function tripleProduct(A: Cartesian, B: Cartesian, C: Cartesian): number {\n  vec3.cross(crossCD, B, C);\n  return vec3.dot(A, crossCD);\n}\n\n/**\n * Computes the quadruple product of four vectors\n * @param out - The target vector to write the result to\n * @param A - The first vector\n * @param B - The second vector\n * @param C - The third vector\n * @param D - The fourth vector\n * @returns The result vector (same as out)\n */\nexport function quadrupleProduct(out: Cartesian, A: Cartesian, B: Cartesian, C: Cartesian, D: Cartesian): Cartesian {\n  vec3.cross(crossCD, C, D);\n  const tripleProductACD = vec3.dot(A, crossCD);\n  const tripleProductBCD = vec3.dot(B, crossCD);\n  vec3.scale(scaledA, A, tripleProductBCD);\n  vec3.scale(scaledB, B, tripleProductACD);\n  return vec3.sub(out, scaledB, scaledA) as Cartesian;\n}\n\n/**\n * Spherical linear interpolation between two vectors\n * @param out - The target vector to write the result to\n * @param A - The first vector\n * @param B - The second vector\n * @param t - The interpolation parameter (0 to 1)\n * @returns The interpolated vector (same as out)\n */\nexport function slerp(out: Cartesian, A: Cartesian, B: Cartesian, t: number): Cartesian {\n  const gamma = vec3.angle(A, B);\n  if (gamma < 1e-12) {\n    return vec3.lerp(out, A, B, t) as Cartesian;\n  }\n  const weightA = Math.sin((1 - t) * gamma) / Math.sin(gamma);\n  const weightB = Math.sin(t * gamma) / Math.sin(gamma);\n  const scaledA = vec3.scale(vec3.create(), A, weightA);\n  const scaledB = vec3.scale(vec3.create(), B, weightB);\n  return vec3.add(out, scaledA, scaledB) as Cartesian;\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport {vec3, glMatrix, quat} from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport type { Cartesian, Radians } from '../core/coordinate-systems';\nimport { slerp, tripleProduct } from '../utils/vector';\n\n// Pre-allocated vectors for midpoints. midA is the midpoint opposite the vertex A\nconst midA = vec3.create() as Cartesian;\nconst midB = vec3.create() as Cartesian;\nconst midC = vec3.create() as Cartesian;\nconst center = vec3.create() as Cartesian;\n\n// Use Cartesian system for all calculations for greater accuracy\n// Using [x, y, z] gives equal precision in all directions, unlike spherical coordinates\nexport type SphericalPolygon = Cartesian[];\n\nexport class SphericalPolygonShape {\n  protected vertices: SphericalPolygon;\n  private _area: Radians | null = null;\n\n  constructor(vertices: SphericalPolygon) {\n    this.vertices = vertices;\n    // this.isWindingCorrect();\n    Object.freeze(this.vertices);\n  }\n\n  /**\n   * \n   * @param nSegments Returns a closed boundary of the polygon, with nSegments points per edge\n   * @returns SphericalPolygon\n   */\n  getBoundary(nSegments: number = 1, closedRing: boolean = true): SphericalPolygon {\n    const points: SphericalPolygon = [];\n    const N = this.vertices.length;\n    for (let s = 0; s < N * nSegments; s++) {\n      const t = s / nSegments;\n      points.push(this.slerp(t));\n    }\n    if (closedRing) {\n      points.push(points[0]);\n    }\n    \n    return points;\n  }\n\n  /**\n   * Interpolates along boundary of polygon. Pass t = 1.5 to get the midpoint between 2nd and 3rd vertices\n   * @param t \n   * @returns Cartesian coordinate\n   */\n  slerp(t: number): Cartesian {\n    const N = this.vertices.length;\n    const f = t % 1;\n    const i = Math.floor(t % N);\n    const j = (i + 1) % N;\n    return slerp(vec3.create() as Cartesian, this.vertices[i], this.vertices[j], f);\n  }\n\n  /**\n   * Returns the vertex given by index t, along with the vectors:\n   * - VA: Vector from vertex to point A\n   * - VB: Vector from vertex to point B\n   * @param t \n   * @returns \n   */\n  getTransformedVertices(t: number): [Cartesian, Cartesian, Cartesian] {\n    const N = this.vertices.length;\n    const i = Math.floor(t % N);\n    const j = (i + 1) % N;\n    const k = (i + N - 1) % N;\n\n    // Points A & B (vertex before and after)\n    const V = vec3.clone(this.vertices[i]) as Cartesian;\n    const VA = vec3.clone(this.vertices[j]) as Cartesian;\n    const VB = vec3.clone(this.vertices[k]) as Cartesian;\n    vec3.sub(VA, VA, V);\n    vec3.sub(VB, VB, V);\n    return [V, VA, VB];\n  }\n\n  containsPoint(point: Cartesian): number {\n    // Adaption of algorithm from:\n    // 'Locating a point on a spherical surface relative to a spherical polygon'\n    // Using only the condition of 'necessary strike'\n    const N = this.vertices.length;\n    let thetaDeltaMin = Infinity;\n\n    for (let i = 0; i < N; i++) {\n      // Transform point and neighboring vertices into coordinate system centered on vertex\n      const [V, VA, VB] = this.getTransformedVertices(i);\n      const VP = vec3.sub(vec3.create(), point, V);\n\n      // Normalize to obtain unit direction vectors\n      vec3.normalize(VP, VP);\n      vec3.normalize(VA, VA);\n      vec3.normalize(VB, VB);\n\n      // Cross products will point away from the center of the sphere when\n      // point P is within arc formed by VA and VB\n      const crossAP = vec3.cross(vec3.create(), VA, VP);\n      const crossPB = vec3.cross(vec3.create(), VP, VB);\n\n      // Dot product will be positive when point P is within arc formed by VA and VB\n      // The magnitude of the dot product is the sine of the angle between the two vectors\n      // which is the same as the angle for small angles.\n      const sinAP = vec3.dot(V, crossAP);\n      const sinPB = vec3.dot(V, crossPB);\n\n      // By returning the minimum value we find the arc where the point is closest to being outside\n      thetaDeltaMin = Math.min(thetaDeltaMin, sinAP, sinPB);\n    }\n\n    // If point is inside all arcs, will return a position value\n    // If point is on edge of arc, will return 0\n    // If point is outside all arcs, will return -1, the further away from 0, the further away from the arc\n    return thetaDeltaMin;\n  }\n\n  /**\n   * Calculate the area of a spherical triangle given three vertices\n   * @param v1 First vertex\n   * @param v2 Second vertex  \n   * @param v3 Third vertex\n   * @returns Area of the spherical triangle in radians\n   */\n  private getTriangleArea(v1: Cartesian, v2: Cartesian, v3: Cartesian): Radians {\n    // Calculate midpoints\n    vec3.lerp(midA, v2, v3, 0.5);\n    vec3.lerp(midB, v3, v1, 0.5);\n    vec3.lerp(midC, v1, v2, 0.5);\n    vec3.normalize(midA, midA);\n    vec3.normalize(midB, midB);\n    vec3.normalize(midC, midC);\n    \n    // Calculate area using asin of dot product, clamped to valid range\n    const S = tripleProduct(midA, midB, midC);\n    const clamped = Math.max(-1.0, Math.min(1.0, S));\n    \n    // sin(x) = x for x < 1e-8\n    if (Math.abs(clamped) < 1e-8) {\n      return 2 * clamped as Radians;\n    } else {\n      return Math.asin(clamped) * 2 as Radians;\n    }\n  }\n\n  /**\n   * Calculate the area of the spherical polygon by decomposing it into a fan of triangles\n   * @returns The area of the spherical polygon in radians\n   */\n  getArea(): Radians {\n    // Memoize the result since vertices are immutable\n    if (this._area === null) {\n      this._area = this._getArea();\n    }\n    return this._area;\n  }\n\n  private _getArea(): Radians {\n    if (this.vertices.length < 3) {\n      return 0 as Radians;\n    }\n\n    if (this.vertices.length === 3) {\n      this._area = this.getTriangleArea(this.vertices[0], this.vertices[1], this.vertices[2]);\n      return this._area;\n    }\n\n    // Calculate center of polygon\n    vec3.set(center, 0, 0, 0);\n    for (const vertex of this.vertices) {\n      vec3.add(center, center, vertex);\n    }\n    vec3.normalize(center, center);\n\n    // Sum fan of triangles around center\n    let area = 0;\n    for (let i = 0; i < this.vertices.length; i++) {\n      const v1 = this.vertices[i];\n      const v2 = this.vertices[(i + 1) % this.vertices.length];\n      const triArea = this.getTriangleArea(center, v1, v2);\n      if (!isNaN(triArea)) {\n        area += triArea;\n      }\n    }\n    this._area = area as Radians;\n    return this._area;\n  }\n\n  /**\n   * For debugging purposes, check if the winding order is correct\n   * In production, should always be correct\n   */\n  private isWindingCorrect(): void {\n    const area = this.getArea();\n    const isCorrect = area > 0;\n    if (!isCorrect) {\n      debugger;\n    }\n  }\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport {glMatrix} from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport type { Cartesian } from '../core/coordinate-systems';\nimport { SphericalPolygonShape } from './spherical-polygon';\n\nexport class SphericalTriangleShape extends SphericalPolygonShape {\n  constructor(vertices: Cartesian[]) {\n    if (vertices.length !== 3) {\n      throw new Error('SphericalTriangleShape requires exactly 3 vertices');\n    }\n    super(vertices);\n  }\n} ","// IVEA (Icosahedral Vertex Equal Area) projection implementation\n// Adaptation of icoVertexGreatCircle.ec from DGGAL project\n// BSD 3-Clause License\n// \n// Copyright (c) 2014-2025, Ecere Corporation\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n// \n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n// \n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n// \n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// BSD 3-Clause License\n// Copyright (c) 2024, A5 Project Contributors\n// All rights reserved.\nimport { vec3, glMatrix } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport type { Cartesian, Face, Barycentric, FaceTriangle, SphericalTriangle } from \"../core/coordinate-systems\";\nimport { faceToBarycentric, barycentricToFace } from \"../core/coordinate-transforms\";\nimport { SphericalTriangleShape } from \"../geometry/spherical-triangle\";\nimport { vectorDifference, quadrupleProduct, slerp } from \"../utils/vector\";\n\nexport class PolyhedralProjection {\n  /**\n   * Forward projection: converts a spherical point to face coordinates\n   * @param v - The spherical point to project\n   * @param sphericalTriangle - The spherical triangle vertices\n   * @param faceTriangle - The face triangle vertices\n   * @returns The face coordinates\n   */\n  forward(v: Cartesian, sphericalTriangle: SphericalTriangle, faceTriangle: FaceTriangle): Face {\n    const [A, B, C] = sphericalTriangle;\n    const triangleShape = new SphericalTriangleShape([A, B, C]);\n\n    // When v is close to A, the quadruple product is unstable.\n    // As we just need the intersection of two great circles we can use difference\n    // between A and v, as it lies in the same plane of the great circle containing A & v\n    const Z = vec3.subtract(vec3.create(), v, A) as Cartesian;\n    vec3.normalize(Z, Z);\n    const p = quadrupleProduct(vec3.create() as Cartesian, A, Z, B, C);\n    vec3.normalize(p, p);\n\n    const h = vectorDifference(A, v) / vectorDifference(A, p);\n    const Area_ABC = triangleShape.getArea();\n    const scaledArea = h / Area_ABC;\n    const b = [\n      1 - h,\n      scaledArea * new SphericalTriangleShape([A, p, C as Cartesian]).getArea(),\n      scaledArea * new SphericalTriangleShape([A, B, p as Cartesian]).getArea()\n    ] as Barycentric;\n    return barycentricToFace(b, faceTriangle);\n  }\n\n  /**\n   * Inverse projection: converts face coordinates back to spherical coordinates\n   * @param facePoint - The face coordinates\n   * @param faceTriangle - The face triangle vertices\n   * @param sphericalTriangle - The spherical triangle vertices\n   * @returns The spherical coordinates\n   */\n  inverse(facePoint: Face, faceTriangle: FaceTriangle, sphericalTriangle: SphericalTriangle): Cartesian {\n    const [A, B, C] = sphericalTriangle;\n    const triangleShape = new SphericalTriangleShape([A, B, C]);\n    const b = faceToBarycentric(facePoint, faceTriangle);\n\n    const threshold = 1 - 1e-14;\n    if (b[0] > threshold) return A;\n    if (b[1] > threshold) return B;\n    if (b[2] > threshold) return C;\n    \n    const c1 = vec3.create();\n    vec3.cross(c1, B, C);\n    const Area_ABC = triangleShape.getArea();\n    const h = 1 - b[0];\n    const R = b[2] / h;\n    const alpha = R * Area_ABC;\n    const S = Math.sin(alpha);\n    const halfC = Math.sin(alpha / 2);\n    const CC = 2 * halfC * halfC; // Half angle formula\n\n    const c01 = vec3.dot(A, B);\n    const c12 = vec3.dot(B, C);\n    const c20 = vec3.dot(C, A);\n    const s12 = vec3.length(c1);\n\n    const V = vec3.dot(A, c1); // Triple product of A, B, C. Constant??\n    const f = S * V + CC * (c01 * c12 - c20);\n    const g = CC * s12 * (1 + c01);\n    const q = (2 / Math.acos(c12)) * Math.atan2(g, f);\n    const P = slerp(vec3.create() as Cartesian, B, C, q);\n    const K = vectorDifference(A, P);\n    const t = this.safeAcos(h * K) / this.safeAcos(K);\n    const out = slerp([0, 0, 0] as Cartesian, A, P, t);\n    return out;\n  }\n\n  /**\n   * Computes acos(1 - 2 * x * x) without loss of precision for small x\n   * @param x \n   * @returns acos(1 - x)\n   */\n  private safeAcos(x: number): number {\n    if (x < 1e-3) {\n      return (2 * x + x * x * x / 3);\n    } else {\n      return Math.acos(1 - 2 * x * x);\n    }\n  }\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { vec2, glMatrix } from 'gl-matrix';\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport { IJ, KJ } from './coordinate-systems';\n\nexport type Quaternary = 0 | 1 | 2 | 3;\nexport const YES = -1 as const;\nexport const NO = 1 as const;\nexport type Flip = typeof YES | typeof NO;\nexport type Anchor = { k: Quaternary, offset: IJ; flips: [flipX: Flip, flipY: Flip]; }\n\n// Anchor offset is specified in ij units, the eigenbasis of the Hilbert curve\n// Define k as the vector i + j, as it means vectors u & v are of unit length\nexport const IJToKJ = ([i, j]: IJ): KJ => {\n  return vec2.fromValues(i + j, j) as KJ;\n}\n\nexport const KJToIJ = ([k, j]: KJ): IJ => {\n  return vec2.fromValues(k - j, j) as IJ;\n}\n\n/**\n * Orientation of the Hilbert curve. The curve fills a space defined by the triangle with vertices\n * u, v & w. The orientation describes which corner the curve starts and ends at, e.g. wv is a\n * curve that starts at w and ends at v.\n */\nexport type Orientation = 'uv' | 'vu' | 'uw' | 'wu' | 'vw' | 'wv';\n\n// Using KJ allows simplification of definitions\nconst kPos = vec2.fromValues(1, 0) as KJ; // k\nconst jPos = vec2.fromValues(0, 1) as KJ; // j\nconst kNeg = vec2.negate(vec2.create(), kPos) as KJ;\nconst jNeg = vec2.negate(vec2.create(), jPos) as KJ;\nconst ZERO = vec2.fromValues(0, 0) as KJ;\n\nexport const quaternaryToKJ = (n: Quaternary, [flipX, flipY]: [Flip, Flip]): KJ => {\n  // Indirection to allow for flips\n  let p: KJ = ZERO;\n  let q: KJ = ZERO;\n  \n  if (flipX === NO && flipY === NO) {\n    p = kPos;\n    q = jPos;\n  } else if (flipX === YES && flipY === NO) {\n    // Swap and negate\n    p = jNeg;\n    q = kNeg;\n  } else if (flipX === NO && flipY === YES) {\n    // Swap only\n    p = jPos;\n    q = kPos;\n  } else if (flipX === YES && flipY === YES) {\n    // Negate only\n    p = kNeg;\n    q = jNeg;\n  }\n\n  switch(n) {\n    case 0:\n      return ZERO; // Length 0\n    case 1:\n      return p; // Length 1\n    case 2:\n      return vec2.add(vec2.create(), q, p) as KJ; // Length SQRT2\n    case 3:\n      return vec2.scaleAndAdd(vec2.create(), q, p, 2) as KJ // Length SQRT5\n    default:\n      throw new Error(`Invalid Quaternary value: ${n}`);\n  }\n}\n\nexport const quaternaryToFlips = (n: Quaternary): [Flip, Flip] => {\n  return [[NO, NO], [NO, YES], [NO, NO], [YES, NO]][n] as [Flip, Flip];\n}\n\nconst FLIP_SHIFT = vec2.fromValues(-1, 1) as IJ;\n\n\n// Patterns used to rearrange the cells when shifting. This adjusts the layout so that\n// children always overlap with their parent cells.\nfunction reversePattern(pattern: number[]): number[] {\n  return Array.from({length: pattern.length}, (_, i) => pattern.indexOf(i));\n}\n\nconst PATTERN = [0, 1, 3, 4, 5, 6, 7, 2];\nconst PATTERN_FLIPPED = [0, 1, 2, 7, 3, 4, 5, 6];\nconst PATTERN_REVERSED = reversePattern(PATTERN);\nconst PATTERN_FLIPPED_REVERSED = reversePattern(PATTERN_FLIPPED);\n\nconst _shiftDigits = (\n  digits: Quaternary[],\n  i: number,\n  flips: [Flip, Flip],\n  invertJ: boolean,\n  pattern: number[]\n): void => {\n  if (i <= 0) return;\n\n  const parentK = digits[i] || 0;\n  const childK = digits[i - 1];\n  const F = flips[0] + flips[1];\n\n  // Detect when cells need to be shifted\n  let needsShift: boolean = true;\n  let first: boolean = true;\n\n  // The value of F which cells need to be shifted\n  // The rule is flipped depending on the orientation, specifically on the value of invertJ\n  if (invertJ !== (F === 0)) {\n    needsShift = parentK === 1 || parentK === 2; // Second & third pentagons only\n    first = parentK === 1; // Second pentagon is first\n  } else {\n    needsShift = parentK < 2; // First two pentagons only\n    first = parentK === 0; // First pentagon is first\n  }\n  if (!needsShift) return;\n  \n  // Apply the pattern by setting the digits based on the value provided\n  const src = first ? childK : childK + 4;\n  const dst = pattern[src];\n  digits[i - 1] = dst % 4 as Quaternary;\n  digits[i] = (parentK + 4 + Math.floor(dst / 4) - Math.floor(src / 4)) % 4 as Quaternary;\n}\n\nexport const sToAnchor = (s: number | bigint, resolution: number, orientation: Orientation): Anchor => {\n  let input = BigInt(s);\n  const reverse = orientation === 'vu' || orientation === 'wu' || orientation === 'vw';\n  const invertJ = orientation === 'wv' || orientation === 'vw';\n  const flipIJ = orientation === 'wu' || orientation === 'uw';\n  if (reverse) {\n    input = (1n << BigInt(2 * resolution)) - input - 1n;\n  }\n  const anchor = _sToAnchor(input, resolution, invertJ, flipIJ);\n  if (flipIJ) {\n    const { offset: [_i, _j], flips: [flipX, flipY] } = anchor;\n    anchor.offset = [_j, _i] as IJ;\n\n    // The flips moved the origin of the cell, shift to compensate\n    if (flipX === YES) vec2.add(anchor.offset, anchor.offset, FLIP_SHIFT);\n    if (flipY === YES) vec2.subtract(anchor.offset, anchor.offset, FLIP_SHIFT);\n  }\n  if (invertJ) {\n    const { offset: [i, _j], flips } = anchor;\n\n    const j = (1 << resolution) - (i + _j);\n    flips[0] = -flips[0] as Flip;\n    anchor.offset[1] = j;\n    anchor.flips = flips;\n  }\n  return anchor;\n}\n\nexport const _sToAnchor = (s: number | bigint, resolution: number, invertJ: boolean, flipIJ: boolean): Anchor => {\n  const offset = vec2.create() as KJ;\n  const flips = [NO, NO] as [Flip, Flip];\n  let input = BigInt(s);\n  \n  // Get all quaternary digits first\n  const digits: Quaternary[] = [];\n  while (input > 0n || digits.length < resolution) {\n    digits.push(Number(input % 4n) as Quaternary);\n    input = input >> 2n;\n  }\n\n  const pattern = flipIJ ? PATTERN_FLIPPED : PATTERN;\n\n  // Process digits from left to right (most significant first)\n  for (let i = digits.length - 1; i >= 0; i--) {\n    _shiftDigits(digits, i, flips, invertJ, pattern);\n    vec2.multiply(flips, flips, quaternaryToFlips(digits[i]));\n  }\n\n  flips[0] = NO; flips[1] = NO; // Reset flips for the next loop\n  for (let i = digits.length - 1; i >= 0; i--) {\n    // Scale up existing anchor\n    vec2.scale(offset, offset, 2);\n\n    // Get child anchor and combine with current anchor\n    const childOffset = quaternaryToKJ(digits[i], flips);\n    vec2.add(offset, offset, childOffset);\n    vec2.multiply(flips, flips, quaternaryToFlips(digits[i]));\n  }\n\n  const k = digits[0] || 0 as Quaternary;\n\n  return {flips, k, offset: KJToIJ(offset)};\n}\n\n// Get the number of digits needed to represent the offset\n// As we don't know the flips we need to add 2 to include the next row\nexport const getRequiredDigits = (offset: vec2): number => {\n  const indexSum = Math.ceil(offset[0]) + Math.ceil(offset[1]); // TODO perhaps use floor instead\n  if (indexSum === 0) return 1;\n  return 1 + Math.floor(Math.log2(indexSum));\n}\n\n// This function uses the ij basis, unlike its inverse!\nexport const IJtoQuaternary = ([u, v]: IJ, flips: [Flip, Flip]): Quaternary => {\n  let digit: Quaternary = 0;\n\n  // Boundaries to compare against\n  let a = flips[0] === YES ? -(u + v) : u + v;\n  let b = flips[1] === YES ? -u : u;\n  let c = flips[0] === YES ? -v : v;\n\n  // Only one flip\n  if (flips[0] + flips[1] === 0) {\n    if (c < 1) { digit = 0; }\n    else if (b > 1) { digit = 3; }\n    else if (a > 1) { digit = 2; }\n    else { digit = 1 }\n  // No flips or both\n  } else {\n    if (a < 1) { digit = 0; }\n    else if (b > 1) { digit = 3; }\n    else if (c > 1) { digit = 2; }\n    else { digit = 1; }\n  }\n\n  return digit;\n}\n\nexport const IJToS = (input: IJ, resolution: number, orientation: Orientation = 'uv'): bigint => {\n  const reverse = orientation === 'vu' || orientation === 'wu' || orientation === 'vw';\n  const invertJ = orientation === 'wv' || orientation === 'vw';\n  const flipIJ = orientation === 'wu' || orientation === 'uw';\n  \n  let ij = [...input] as IJ;\n  if (flipIJ) {\n    ij[0] = input[1];\n    ij[1] = input[0];\n  }\n  if (invertJ) {\n    const [i, j] = ij;\n    ij[1] = (1 << resolution) - (i + j);\n  }\n  \n  let S = _IJToS(ij, invertJ, flipIJ, resolution);\n  if (reverse) {\n    S = (1n << BigInt(2 * resolution)) - S - 1n;\n  }\n  return S;\n}\n\nexport const _IJToS = (input: IJ, invertJ: boolean, flipIJ: boolean, resolution: number): bigint => {\n  // Get number of digits we need to process\n  const numDigits = resolution;\n  const digits: Quaternary[] = new Array(numDigits);\n\n  const flips: [Flip, Flip] = [NO, NO];\n  const pivot = vec2.create() as IJ;\n\n  // Process digits from left to right (most significant first)\n  for (let i = numDigits - 1; i >= 0; i--) {\n    const relativeOffset = vec2.subtract(vec2.create(), input, pivot) as IJ;\n\n    const scale = 1 << i;\n    const scaledOffset = vec2.scale(vec2.create(), relativeOffset, 1 / scale) as IJ;\n\n    const digit = IJtoQuaternary(scaledOffset, flips);\n    digits[i] = digit;\n\n    // Update running state\n    const childOffset = KJToIJ(quaternaryToKJ(digit, flips));\n    const upscaledChildOffset = vec2.scale(vec2.create(), childOffset, scale);\n    vec2.add(pivot, pivot, upscaledChildOffset);\n    vec2.multiply(flips, flips, quaternaryToFlips(digit));\n  }\n\n  const pattern = flipIJ ? PATTERN_FLIPPED_REVERSED : PATTERN_REVERSED;\n\n  for (let i = 0; i < digits.length; i++) {\n    vec2.multiply(flips, flips, quaternaryToFlips(digits[i]));\n    _shiftDigits(digits, i, flips, invertJ, pattern);\n  }\n\n  let output = 0n;\n  for (let i = numDigits - 1; i >= 0; i--) {\n    const scale = 1n << BigInt(2 * i);\n    output += BigInt(digits[i]) * scale;\n  }\n\n  return output;\n}","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { mat2, vec2, glMatrix } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport { Pentagon, PentagonShape } from \"../geometry/pentagon\";\nimport { BASIS, PENTAGON, TRIANGLE, v, w } from \"./pentagon\";\nimport { TWO_PI_OVER_5 } from \"./constants\";\nimport { NO, Anchor, YES } from \"./hilbert\";\nimport { Polar } from \"./coordinate-systems\";\n\nconst TRIANGLE_MODE = false;\n\nconst shiftRight = vec2.clone(w);\nconst shiftLeft = vec2.negate(vec2.create(), w);\n\n/**\n * Define transforms for each pentagon in the primitive unit\n * Using pentagon vertices and angle as the basis for the transform\n */ \nconst QUINTANT_ROTATIONS = [0, 1, 2, 3, 4].map(quintant => {\n  const rotation = mat2.create();\n  mat2.fromRotation(rotation, TWO_PI_OVER_5 * quintant);\n  return rotation;\n});\n\nconst translation = vec2.create();\n\n/**\n * Get pentagon vertices\n * @param resolution The resolution level\n * @param quintant The quintant index (0-4)\n * @param anchor The anchor information\n * @returns A pentagon shape with transformed vertices\n */\nexport function getPentagonVertices(resolution: number, quintant: number, anchor: Anchor): PentagonShape {\n  const pentagon = (TRIANGLE_MODE ? TRIANGLE : PENTAGON).clone();\n  \n  vec2.transformMat2(translation, anchor.offset, BASIS);\n\n  // Apply transformations based on anchor properties\n  if (anchor.flips[0] === NO && anchor.flips[1] === YES) {\n    pentagon.rotate180();\n  }\n\n  const {k} = anchor;\n  const F = anchor.flips[0] + anchor.flips[1];\n  if (\n    // Orient last two pentagons when both or neither flips are YES\n    ((F === -2 || F === 2) && k > 1) ||\n    // Orient first & last pentagons when only one of flips is YES\n    (F === 0 && (k === 0 || k === 3))\n  ) {\n    pentagon.reflectY();\n  }\n\n  if (anchor.flips[0] === YES && anchor.flips[1] === YES) {\n    pentagon.rotate180();\n  } else if (anchor.flips[0] === YES) {\n    pentagon.translate(shiftLeft);\n  } else if (anchor.flips[1] === YES) {\n    pentagon.translate(shiftRight);\n  }\n\n  // Position within quintant\n  pentagon.translate(translation);\n  pentagon.scale(1 / (2 ** resolution));\n  pentagon.transform(QUINTANT_ROTATIONS[quintant]);\n\n  return pentagon;\n}\n\n// TODO: memoize these two functions?\nexport function getQuintantVertices(quintant: number): PentagonShape {\n  const triangle = TRIANGLE.clone();\n  triangle.transform(QUINTANT_ROTATIONS[quintant]);\n  return triangle;\n}\n\nexport function getFaceVertices(): PentagonShape {\n  const vertices: vec2[] = [];\n  for (const rotation of QUINTANT_ROTATIONS) {\n    vertices.push(vec2.transformMat2(vec2.create(), v, rotation));\n  }\n\n  // Need to reverse to obtain correct winding order\n  vertices.reverse();\n  return new PentagonShape(vertices as Pentagon);\n}\n\nexport function getQuintantPolar([_, gamma]: Polar): number {\n  return (Math.round(gamma / TWO_PI_OVER_5) + 5) % 5;\n}","import { vec3, glMatrix } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport { distanceToEdge, distanceToVertex } from \"../core/constants\";\nimport type { Cartesian, Radians, Spherical } from \"../core/coordinate-systems\";\nimport { toCartesian } from \"../core/coordinate-transforms\";\nimport { origins } from \"../core/origin\";\n\n/**\n * The Coordinate Reference System (CRS) of the dodecahedron is a set of 62 vertices:\n * - 12 face centers\n * - 20 vertices\n * - 30 edge midpoints\n * \n * The vertices are used as a rigid frame of reference for the dodecahedron in the\n * dodecahedron projection. By constructing them once, we can avoid recalculating\n * and be sure of their correctness.\n */\nexport class CRS {\n  private vertices: Cartesian[] = [];\n  private invocations = 0;\n\n  constructor() {\n    this.addFaceCenters(); // 12 centers\n    this.addVertices(); // 20 vertices\n    this.addMidpoints(); // 30 midpoints\n    if (this.vertices.length !== 62) {\n      throw new Error(\"Failed to construct CRS: vertices length is not 62\");\n    }\n    Object.freeze(this.vertices);\n  }\n\n  getVertex(point: Cartesian): Cartesian {\n    this.invocations++;\n    if (this.invocations === 10000) {\n      console.warn('Too many CRS invocations, results should be cached');\n    }\n    for (const vertex of this.vertices) {\n      if (vec3.distance(point, vertex) < 1e-5) {\n        return vertex;\n      }\n    }\n\n    throw new Error(\"Failed to find vertex in CRS\");\n  }\n\n  private addFaceCenters(): void {\n    origins.forEach(origin => this.add(toCartesian(origin.axis)));\n  }\n\n  private addVertices(): void {\n    const phiVertex = Math.atan(distanceToVertex) as Radians;\n\n    for (const origin of origins) {\n      for (let i = 0; i < 5; i++) {\n        const thetaVertex = (2 * i + 1) * Math.PI / 5 as Radians;\n        const vertex = toCartesian([thetaVertex + origin.angle, phiVertex] as Spherical);\n        vec3.transformQuat(vertex, vertex, origin.quat);\n        this.add(vertex);\n      }\n    }\n  }\n\n  private addMidpoints(): void {\n    const phiMidpoint = Math.atan(distanceToEdge) as Radians;\n\n    for (const origin of origins) {\n      for (let i = 0; i < 5; i++) {\n        const thetaMidpoint = (2 * i) * Math.PI / 5 as Radians;\n        const midpoint = toCartesian([thetaMidpoint + origin.angle, phiMidpoint] as Spherical);\n        vec3.transformQuat(midpoint, midpoint, origin.quat);\n        this.add(midpoint);\n      }\n    }\n  }\n\n  private add(newVertex: Cartesian): boolean {\n    const normalized = vec3.normalize(vec3.create(), newVertex) as Cartesian;\n    const existingVertex = this.vertices.find(existingVertex => vec3.distance(normalized, existingVertex) < 1e-5);\n    if (existingVertex) {\n      return false;\n    }\n    this.vertices.push(normalized);\n    return true;\n  }\n}","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { vec2, vec3, quat, glMatrix } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Float64Array as any);\nimport { toCartesian, toSpherical, toFace, toPolar } from \"../core/coordinate-transforms\";\nimport type { Radians, Spherical, Cartesian, Polar, Face } from \"../core/coordinate-systems\";\nimport { GnomonicProjection } from './gnomonic';\nimport { origins } from \"../core/origin\";\nimport { distanceToEdge, interhedralAngle, PI_OVER_5, TWO_PI_OVER_5 } from '../core/constants';\nimport { PolyhedralProjection } from \"./polyhedral\";\nimport { getQuintantVertices } from \"../core/tiling\";\nimport { OriginId } from \"a5/core/utils\";\nimport { CRS } from \"./crs\";\n\ntype FaceTriangleIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\ntype FaceTriangle = [Face, Face, Face];\nimport type { SphericalTriangle } from '../core/coordinate-systems';\n\nconst crs = new CRS();\n\nexport class DodecahedronProjection {\n  private faceTriangles: FaceTriangle[] = [];\n  private sphericalTriangles: SphericalTriangle[] = [];\n  private polyhedral: PolyhedralProjection;\n  private gnomonic: GnomonicProjection;\n\n  constructor() {\n    this.polyhedral = new PolyhedralProjection();\n    this.gnomonic = new GnomonicProjection();\n  }\n  \n  /**\n   * Projects spherical coordinates to face coordinates using dodecahedron projection\n   * @param spherical Spherical coordinates [theta, phi]\n   * @param originId Origin ID\n   * @returns Face coordinates [x, y]\n   */\n  forward(spherical: Spherical, originId: OriginId): Face {\n    const origin = origins[originId];\n\n    // Transform back origin space\n    const unprojected = toCartesian(spherical);\n    const out = vec3.create() as Cartesian;\n    vec3.transformQuat(out, unprojected, origin.inverseQuat);\n\n    // Unproject gnomonically to polar coordinates in origin space\n    const projectedSpherical = toSpherical(out);\n    const polar = this.gnomonic.forward(projectedSpherical);\n\n    // Rotate around face axis to remove origin rotation\n    polar[1] = (polar[1] - origin.angle) as Radians;\n    const faceTriangleIndex = this.getFaceTriangleIndex(polar);\n\n    const reflect = this.shouldReflect(polar);\n    let faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflect, false);\n    let sphericalTriangle = this.getSphericalTriangle(faceTriangleIndex, originId, reflect);\n    return this.polyhedral.forward(unprojected, sphericalTriangle, faceTriangle);\n  }\n\n  /**\n   * Unprojects face coordinates to spherical coordinates using dodecahedron projection\n   * @param face Face coordinates [x, y]\n   * @param originId Origin ID\n   * @returns Spherical coordinates [theta, phi]\n   */\n  inverse(face: Face, originId: OriginId): Spherical {\n    const polar = toPolar(face);\n    const faceTriangleIndex = this.getFaceTriangleIndex(polar);\n\n    const reflect = this.shouldReflect(polar);\n    const faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflect, false);\n    const sphericalTriangle = this.getSphericalTriangle(faceTriangleIndex, originId, reflect);\n    const unprojected = this.polyhedral.inverse(face, faceTriangle, sphericalTriangle);\n    return toSpherical(unprojected);\n  }\n\n  /**\n   * Detects when point is beyond the edge of the dodecahedron face\n   * In the standard case (reflect = false), the face and spherical triangle can be\n   * used directly.\n   * In the reflected case (reflect = true), the point is beyond the edge of the dodecahedron face,\n   * and so the face triangle is squashed to unproject correctly onto the neighboring dodecahedron face.\n   * @param polar Polar coordinates\n   * @returns True if point is beyond the edge of the dodecahedron face\n   */\n  private shouldReflect(polar: Polar): boolean {\n    const [rho, gamma] = polar;\n    const D = toFace([rho, this.normalizeGamma(gamma)] as Polar)[0];\n    return D > distanceToEdge;\n  }\n\n  /**\n   * Given a polar coordinate, returns the index of the face triangle it belongs to\n   * @param polar Polar coordinates\n   * @returns Face triangle index, value from 0 to 9\n   */\n  private getFaceTriangleIndex([_, gamma]: Polar): FaceTriangleIndex {\n    return (Math.floor(gamma / PI_OVER_5) + 10) % 10 as FaceTriangleIndex;\n  }\n\n  /**\n   * Gets the face triangle for a given polar coordinate\n   * @param faceTriangleIndex Face triangle index, value from 0 to 9\n   * @returns FaceTriangle: 3 vertices in counter-clockwise order\n   */\n  private getFaceTriangle(faceTriangleIndex: FaceTriangleIndex, reflected: boolean = false, squashed: boolean = false): FaceTriangle {\n    let index = faceTriangleIndex;\n    if (reflected) {\n      index += squashed ? 20 : 10;\n    }\n    if (this.faceTriangles[index]) {\n      return this.faceTriangles[index];\n    }\n\n    this.faceTriangles[index] = reflected ?\n      this._getReflectedFaceTriangle(faceTriangleIndex, squashed) :\n      this._getFaceTriangle(faceTriangleIndex);\n    Object.freeze(this.faceTriangles[index]);\n    return this.faceTriangles[index];\n  }\n\n  private _getFaceTriangle(faceTriangleIndex: FaceTriangleIndex): FaceTriangle {\n    const quintant = Math.floor((faceTriangleIndex + 1) / 2) % 5;\n\n    const [vCenter, vCorner1, vCorner2] = getQuintantVertices(quintant).getVertices();\n    //const vVertex = [distanceToEdge, distanceToEdge] as Face;\n    const vEdgeMidpoint = vec2.create() as Face;\n    vec2.lerp(vEdgeMidpoint, vCorner1, vCorner2, 0.5);\n\n    // Sign of gamma determines which triangle we want to use, and thus vertex order\n    const even = faceTriangleIndex % 2 === 0;\n\n    // Note: center & midpoint compared to DGGAL implementation are swapped\n    // as we are using a dodecahedron, rather than a icosahedron.\n    return even ? [vCenter, vEdgeMidpoint, vCorner1] : [vCenter, vCorner2, vEdgeMidpoint];\n  }\n\n  private _getReflectedFaceTriangle(faceTriangleIndex: FaceTriangleIndex, squashed: boolean = false): FaceTriangle {\n    // First obtain ordinary unreflected triangle\n    let [A, B, C] = this._getFaceTriangle(faceTriangleIndex).map(face => vec2.clone(face)) as FaceTriangle;\n\n    // Reflect dodecahedron center (A) across edge (BC)\n    const even = faceTriangleIndex % 2 === 0;\n    vec2.negate(A, A);\n    const midpoint = even ? B : C;\n\n    // Squashing is important. A squashed triangle when unprojected will yield the correct spherical triangle.\n    vec2.scaleAndAdd(A, A, midpoint, squashed ? 1 + 1 / Math.cos(interhedralAngle) : 2);\n\n    // Swap midpoint and corner to maintain correct vertex order\n    return [A, C, B] as FaceTriangle;\n  }\n\n  /**\n   * Gets the spherical triangle for a given face triangle index and origin\n   * @param faceTriangleIndex Face triangle index\n   * @param originId Origin ID\n   * @returns Spherical triangle\n   */\n  private getSphericalTriangle(faceTriangleIndex: FaceTriangleIndex, originId: OriginId, reflected: boolean = false): SphericalTriangle {\n    let index = 10 * originId + faceTriangleIndex; // 0-119\n    if (reflected) {\n      index += 120;\n    }\n    if (this.sphericalTriangles[index]) {\n      return this.sphericalTriangles[index];\n    }\n\n    this.sphericalTriangles[index] = this._getSphericalTriangle(faceTriangleIndex, originId, reflected);\n    Object.freeze(this.sphericalTriangles[index]);\n    return this.sphericalTriangles[index];\n  }\n\n\n  private _getSphericalTriangle(faceTriangleIndex: FaceTriangleIndex, originId: OriginId, reflected: boolean = false): SphericalTriangle {\n    const origin = origins[originId];\n    const faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflected, true);\n    \n    const sphericalTriangle = faceTriangle.map((face: Face) => {\n      const [rho, gamma] = toPolar(face);\n      const rotatedPolar = [rho, gamma + origin.angle] as Polar;\n      const rotated = toCartesian(this.gnomonic.inverse(rotatedPolar));\n      vec3.transformQuat(rotated, rotated, origin.quat);\n      return crs.getVertex(rotated);\n    });\n    return sphericalTriangle as SphericalTriangle;\n  }\n\n  /**\n   * Normalizes gamma to the range [-PI_OVER_5, PI_OVER_5]\n   * @param gamma The gamma value to normalize\n   * @returns Normalized gamma value\n   */\n  normalizeGamma(gamma: Radians): Radians {\n    const segment = gamma / TWO_PI_OVER_5;\n    const sCenter = Math.round(segment);\n    const sOffset = segment - sCenter;\n\n    // Azimuthal angle from triangle bisector\n    const beta = sOffset * TWO_PI_OVER_5;\n    return beta as Radians;\n  }\n} ","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { A5Cell } from \"./utils\";\nimport { Origin } from './utils';\nimport { origins } from \"./origin\";\n\nexport const FIRST_HILBERT_RESOLUTION = 2;\nexport const MAX_RESOLUTION = 30;\nexport const HILBERT_START_BIT = 58n; // 64 - 6 bits for origin & segment\n\n// First 6 bits 0, remaining 58 bits 1\nexport const REMOVAL_MASK = 0x3ffffffffffffffn;\n\n// First 6 bits 1, remaining 58 bits 0\nexport const ORIGIN_SEGMENT_MASK = 0xfc00000000000000n;\n\n// All 64 bits 1\nexport const ALL_ONES = 0xffffffffffffffffn;\n\n// Abstract cell that contains the whole world, has resolution -1 and 12 children,\n// which are the res0 cells.\nexport const WORLD_CELL = 0n;\n\nexport function getResolution(index: bigint): number {\n  // Find resolution from position of first non-00 bits from the right\n  let resolution = MAX_RESOLUTION - 1;\n  let shifted = index >> 1n; // TODO check if non-zero for point level\n  while (resolution > -1 && (shifted & 0b1n) === 0n) {\n    resolution -= 1;\n    // For non-Hilbert resolutions, resolution marker moves by 1 bit per resolution\n    // For Hilbert resolutions, resolution marker moves by 2 bits per resolution\n    shifted = shifted >> (resolution < FIRST_HILBERT_RESOLUTION ? 1n : 2n);\n  }\n\n  return resolution;\n}\n\nexport function deserialize(index: bigint): A5Cell {\n  const resolution = getResolution(index);\n\n  // Technically not a resolution, but can be useful to think of as an\n  // abstract cell that contains the whole world\n  if (resolution === -1) {\n    return { origin: origins[0], segment: 0, S: 0n, resolution };\n  }\n\n  // Extract origin*segment from top 6 bits\n  const top6Bits = Number(index >> 58n);\n  \n  // Find origin and segment that multiply to give this product\n  let origin: Origin, segment: number;\n\n  if (resolution === 0) {\n    const originId: number = top6Bits;\n    origin = origins[originId];\n    segment = 0;\n  } else {\n    const originId = Math.floor(top6Bits / 5);\n    origin = origins[originId];\n    segment = (top6Bits + origin.firstQuintant) % 5;\n  }\n\n  if (!origin) {\n    throw new Error(`Could not parse origin: ${top6Bits}`);\n  }\n\n  if (resolution < FIRST_HILBERT_RESOLUTION) {\n    return { origin, segment, S: 0n, resolution };\n  }\n\n  // Mask away origin & segment and shift away resolution and 00 bits\n  const hilbertLevels = resolution - FIRST_HILBERT_RESOLUTION + 1;\n  const hilbertBits = BigInt(2 * hilbertLevels);\n  const shift = HILBERT_START_BIT - hilbertBits;\n  const S = (index & REMOVAL_MASK) >> shift;\n  return { origin, segment, S, resolution };\n}\n\nexport function serialize(cell: A5Cell): bigint {\n  const {origin, segment, S, resolution} = cell;\n  if (resolution > MAX_RESOLUTION) {\n    throw new Error(`Resolution (${resolution}) is too large`);\n  }\n\n  if (resolution === -1) return WORLD_CELL;\n\n  // Position of resolution marker as bit shift from LSB\n  let R;\n  if (resolution < FIRST_HILBERT_RESOLUTION) {\n    // For non-Hilbert resolutions, resolution marker moves by 1 bit per resolution\n    R = BigInt(resolution + 1);\n  } else {\n    // For Hilbert resolutions, resolution marker moves by 2 bits per resolution\n    const hilbertResolution = 1 + resolution - FIRST_HILBERT_RESOLUTION;\n    R = BigInt(2 * hilbertResolution + 1);\n  }\n\n  // First 6 bits are the origin id and the segment\n  const segmentN = (segment - origin.firstQuintant + 5) % 5;\n\n  let index; \n  if (resolution === 0) {\n    index = BigInt(origin.id) << 58n;\n  } else {\n    index = BigInt(5 * origin.id + segmentN) << 58n;\n  }\n\n  if (resolution >= FIRST_HILBERT_RESOLUTION) {\n    // Number of bits required for S Hilbert curve\n    const hilbertLevels = resolution - FIRST_HILBERT_RESOLUTION + 1;\n    const hilbertBits = BigInt(2 * hilbertLevels);\n    if (BigInt(S) >= (1n << hilbertBits)) {\n      throw new Error(`S (${S}) is too large for resolution level ${resolution}`);\n    }\n    // Next (2 * hilbertResolution) bits are S (hilbert index within segment)\n    index += BigInt(S) << (HILBERT_START_BIT - hilbertBits);\n  }\n\n  // Resolution is encoded by position of the least significant 1\n  index |= 1n << (HILBERT_START_BIT - R);\n\n  return index;\n}\n\nexport function cellToChildren(index: bigint, childResolution?: number): bigint[] {\n  const {origin, segment, S, resolution: currentResolution} = deserialize(index);\n  const newResolution = childResolution ?? currentResolution + 1;\n\n  if (newResolution < currentResolution) {\n    throw new Error(`Target resolution (${newResolution}) must be equal to or greater than current resolution (${currentResolution})`);\n  }\n\n  if (newResolution > MAX_RESOLUTION) {\n    throw new Error(`Target resolution (${newResolution}) exceeds maximum resolution (${MAX_RESOLUTION})`);\n  }\n\n  // If target resolution equals current resolution, return the original cell\n  if (newResolution === currentResolution) {\n    return [index];\n  }\n\n  let newOrigins: Origin[] = [origin];\n  let newSegments: number[] = [segment];\n  if (currentResolution === -1) {\n    newOrigins = origins;\n  }\n  if (\n    (currentResolution === -1 && newResolution > 0)\n    || currentResolution === 0\n    ) {\n    newSegments = [0, 1, 2, 3, 4];\n  }\n\n  const resolutionDiff = newResolution - Math.max(currentResolution, FIRST_HILBERT_RESOLUTION - 1);\n  const childrenCount = Math.pow(4, resolutionDiff);\n  const children: bigint[] = [];\n  const shiftedS = S << BigInt(2 * resolutionDiff);\n  for (const newOrigin of newOrigins) {\n    for (const newSegment of newSegments) {\n      for (let i = 0; i < childrenCount; i++) {\n        const newS = shiftedS + BigInt(i);\n        children.push(serialize({origin: newOrigin, segment: newSegment, S: newS, resolution: newResolution}));\n      }\n    }\n  }\n  \n  return children;\n}\n\nexport function cellToParent(index: bigint, parentResolution?: number): bigint {\n  const {origin, segment, S, resolution: currentResolution} = deserialize(index);\n  const newResolution = parentResolution ?? currentResolution - 1;\n\n  if (newResolution < 0) {\n    throw new Error(`Target resolution (${newResolution}) cannot be negative`);\n  }\n\n  if (newResolution > currentResolution) {\n    throw new Error(`Target resolution (${newResolution}) must be equal to or less than current resolution (${currentResolution})`);\n  }\n\n  if (newResolution === currentResolution) {\n    return index;\n  }\n\n  const resolutionDiff = currentResolution - newResolution;\n  const shiftedS = S >> BigInt(2 * resolutionDiff);\n  return serialize({origin, segment, S: shiftedS, resolution: newResolution});\n}\n\n/**\n * Returns resolution 0 cells of the A5 system, which serve as a starting point\n * for all higher-resolution subdivisions in the hierarchy.\n * \n * @returns Array of 12 cell indices\n */\nexport function getRes0Cells(): bigint[] {\n  return cellToChildren(WORLD_CELL, 0);\n}","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nimport { mat2, vec2, glMatrix } from \"gl-matrix\";\nglMatrix.setMatrixArrayType(Float64Array as any);\n\nimport type { Face, LonLat } from \"./coordinate-systems\";\nimport { FaceToIJ, fromLonLat, toCartesian, toFace, toLonLat, toSpherical, toPolar, normalizeLongitudes } from \"./coordinate-transforms\";\nimport { findNearestOrigin, quintantToSegment, segmentToQuintant } from \"./origin\";\nimport { DodecahedronProjection } from \"../projections/dodecahedron\";\nimport { A5Cell } from \"./utils\";\nimport { PentagonShape } from \"../geometry/pentagon\";\nimport { getFaceVertices, getPentagonVertices, getQuintantPolar, getQuintantVertices } from \"./tiling\";\nimport { PI_OVER_5 } from \"./constants\";\nimport { IJToS, sToAnchor } from \"./hilbert\";\nimport { deserialize, serialize, FIRST_HILBERT_RESOLUTION } from \"./serialization\";\nimport { SphericalPolygonShape } from \"../geometry/spherical-polygon\";\n\n// Reuse these objects to avoid allocation\nconst rotation = mat2.create();\nconst dodecahedron = new DodecahedronProjection();\n\nexport function lonLatToCell(lonLat: LonLat, resolution: number): bigint {\n  if (resolution < FIRST_HILBERT_RESOLUTION) {\n    // For low resolutions there is no Hilbert curve, so we can just return as the result is exact\n    return serialize(_lonLatToEstimate(lonLat, resolution));\n  }\n\n  const hilbertResolution = 1 + resolution - FIRST_HILBERT_RESOLUTION;\n  const samples: LonLat[] = [lonLat];\n  const N = 25;\n  const scale = 50 / Math.pow(2, hilbertResolution);\n  for (let i = 0; i < N; i++) {\n    const R = (i / N) * scale;\n    const coordinate = vec2.fromValues(Math.cos(i) * R, Math.sin(i) * R);\n    vec2.add(coordinate, coordinate, lonLat);\n    samples.push(coordinate as LonLat);\n  }\n\n  // Deduplicate estimates\n  const estimateSet = new Set<bigint>();\n  const uniqueEstimates: A5Cell[] = [];\n\n  const cells: {cell: A5Cell, distance: number}[] = [];\n  for (const sample of samples) {\n    const estimate = _lonLatToEstimate(sample, resolution);\n    const estimateKey = serialize(estimate);\n    if (!estimateSet.has(estimateKey)) {\n      // Have new estimate, add to set and list\n      estimateSet.add(estimateKey);\n      uniqueEstimates.push(estimate);\n\n      // Check if we have a hit, storing distance if not\n      const distance = a5cellContainsPoint(estimate, lonLat);\n      if (distance > 0) {\n        return serialize(estimate);\n      } else {\n        cells.push({cell: estimate, distance});\n      }\n    }\n  }\n\n  // As fallback, sort cells by distance and use the closest one\n  cells.sort((a, b) => b.distance - a.distance);\n  return serialize(cells[0].cell);\n}\n\n// The IJToS function uses the triangular lattice which only approximates the pentagon lattice\n// Thus this function only returns an cell nearby, and we need to search the neighbourhood to find the correct cell\n// TODO: Implement a more accurate function\nfunction _lonLatToEstimate(lonLat: LonLat, resolution: number): A5Cell {\n  const spherical = fromLonLat(lonLat);\n  const origin = {...findNearestOrigin(spherical)};\n\n  const dodecPoint = dodecahedron.forward(spherical, origin.id);\n  const polar = toPolar(dodecPoint);\n  const quintant = getQuintantPolar(polar);\n  const {segment, orientation} = quintantToSegment(quintant, origin);\n  if (resolution < FIRST_HILBERT_RESOLUTION) {\n    // For low resolutions there is no Hilbert curve\n    return {S: 0n, segment, origin, resolution};\n  }\n\n  // Rotate into right fifth\n  if (quintant !== 0) {\n    const extraAngle = 2 * PI_OVER_5 * quintant;\n    mat2.fromRotation(rotation, -extraAngle);\n    vec2.transformMat2(dodecPoint, dodecPoint, rotation);\n  }\n\n  const hilbertResolution = 1 + resolution - FIRST_HILBERT_RESOLUTION;\n  vec2.scale(dodecPoint, dodecPoint, 2 ** hilbertResolution);\n\n  const ij = FaceToIJ(dodecPoint);\n  let S = IJToS(ij, hilbertResolution, orientation);\n  const estimate: A5Cell = {S, segment, origin, resolution};\n  return estimate;\n}\n\n// TODO move into tiling.ts\nexport function _getPentagon({S, segment, origin, resolution}: A5Cell): PentagonShape {\n  const {quintant, orientation} = segmentToQuintant(segment, origin);\n  if (resolution === (FIRST_HILBERT_RESOLUTION - 1)) {\n    const out = getQuintantVertices(quintant);\n    return out;\n  } else if (resolution === (FIRST_HILBERT_RESOLUTION - 2)) {\n    return getFaceVertices();\n  }\n\n  const hilbertResolution = resolution - FIRST_HILBERT_RESOLUTION + 1;\n  const anchor = sToAnchor(S, hilbertResolution, orientation);\n  return getPentagonVertices(hilbertResolution, quintant, anchor);\n}\n\nexport function cellToLonLat(cell: bigint): LonLat {\n  const {S, segment, origin, resolution} = deserialize(cell);\n  const pentagon = _getPentagon({S, segment, origin, resolution});\n  const point = dodecahedron.inverse(pentagon.getCenter() as Face, origin.id);\n  return toLonLat(point);\n}\n\ntype CellToBoundaryOptions = {\n  /**\n   * Pass true to close the ring with the first point\n   * @default true\n   */\n  closedRing?: boolean;\n  /**\n   * Number of segments to use for each edge. Pass 'auto' to use the resolution of the cell.\n   * @default 'auto'\n   */\n  segments?: number | 'auto';\n}\n\nexport function cellToBoundary(cellId: bigint, {closedRing = true, segments = 'auto'}: CellToBoundaryOptions = {closedRing: true, segments: 'auto'}): LonLat[] {\n  const {S, segment, origin, resolution} = deserialize(cellId);\n  if (segments === 'auto') {\n    segments = Math.max(1,  Math.pow(2, 6 - resolution));\n  }\n\n  const pentagon = _getPentagon({S, segment, origin, resolution});\n\n  // Split each edge into segments before projection\n  // Important to do before projection to obtain equal area cells\n  const splitPentagon = pentagon.splitEdges(segments);\n  const vertices = splitPentagon.getVertices();\n\n  // Unproject to obtain lon/lat coordinates\n  const unprojectedVertices = vertices.map(vertex => dodecahedron.inverse(vertex, origin.id));\n  const boundary = unprojectedVertices.map(vertex => toLonLat(vertex));\n\n  // Normalize longitudes to handle antimeridian crossing\n  const normalizedBoundary = normalizeLongitudes(boundary);\n\n  if (closedRing) {\n    normalizedBoundary.push(normalizedBoundary[0]);\n  }\n  // TODO: This is a patch to make the boundary CCW, but we should fix the winding order of the pentagon\n  // throughout the whole codebase\n  normalizedBoundary.reverse();\n  return normalizedBoundary;\n}\n\nexport function a5cellContainsPoint(cell: A5Cell, point: LonLat): number {\n  const pentagon = _getPentagon(cell);\n  const spherical = fromLonLat(point);\n  const projectedPoint = dodecahedron.forward(spherical, cell.origin.id);\n  return pentagon.containsPoint(projectedPoint);\n}","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nexport function hexToU64(hex: string): bigint {\n  return BigInt(`0x${hex}`);\n}\n  \nexport function u64ToHex(index: bigint): string {\n  return index.toString(16);\n}","// A5\n// SPDX-License-Identifier: Apache-2.0\n// Copyright (c) A5 contributors\n\nconst AUTHALIC_RADIUS = 6371007.2; // m\nconst AUTHALIC_AREA = 4 * Math.PI * AUTHALIC_RADIUS * AUTHALIC_RADIUS; // m^2\n\n/**\n * Returns the number of cells at a given resolution.\n * \n * @param resolution The resolution level (use BigInt for exact value for high resolutions, 28+)\n * @returns Number of cells at the given resolution\n */\nexport function getNumCells(resolution: number): number;\nexport function getNumCells(resolution: bigint): bigint;\nexport function getNumCells(resolution: number | bigint): number | bigint {\n  if (typeof resolution === 'bigint') {\n    if (resolution < 0n) return 0n;\n    if (resolution === 0n) return 12n;\n    return 60n * (4n ** (resolution - 1n));\n  } else {\n    if (resolution < 0) return 0;\n    if (resolution === 0) return 12;\n    return 60 * (4 ** (resolution - 1));\n  }\n}\n\n/**\n * Returns the area of a cell at a given resolution in square kilometers.\n * \n * @param resolution The resolution level\n * @returns Area of a cell in square meters\n */\nexport function cellArea(resolution: number): number {\n  if (resolution < 0) return AUTHALIC_AREA;\n  return AUTHALIC_AREA / getNumCells(resolution);\n} "],"mappings":"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","names":["a","b","equals","a","a2","b","b2","c","v","L","D","equals","scale","create","add","clone","copy","create","dot","equals","exactEquals","fromValues","identity","invert","len","length","lerp","mul","multiply","normalize","random","rotateX","rotateY","rotateZ","scale","set","sqrLen","squaredLength","str","add","clone","copy","create","equals","exactEquals","fromValues","mul","multiply","scale","set","str","sub","subtract","create","clone","a","fromValues","copy","set","add","b","subtract","multiply","scale","len","c","d","w","str","exactEquals","equals","a2","b2","sub","mul","create","clone","a","fromValues","w","copy","set","add","b","scale","a","b","length","a","w","squaredLength","normalize","a","w","len","dot","b","lerp","a","b","exactEquals","a","b","equals","a2","b2","forEach","create","a","create","identity","a","b","dot","multiply","rotateX","rotateY","rotateZ","w","scale","random","invert","a2","str","clone","fromValues","copy","set","add","mul","lerp","length","len","squaredLength","sqrLen","normalize","exactEquals","equals","c","d","add","angle","ceil","clone","copy","create","cross","dist","distance","div","divide","dot","equals","exactEquals","floor","forEach","fromValues","inverse","len","length","lerp","max","min","mul","multiply","negate","normalize","random","rotate","round","scale","scaleAndAdd","set","sqrDist","sqrLen","squaredDistance","squaredLength","str","sub","subtract","transformMat3","transformMat4","zero","create","clone","a","fromValues","copy","set","add","b","subtract","multiply","divide","ceil","floor","min","max","round","scale","scaleAndAdd","distance","squaredDistance","length","squaredLength","negate","inverse","normalize","len","dot","cross","lerp","random","transformMat3","transformMat4","rotate","angle","zero","str","exactEquals","equals","sub","mul","div","dist","sqrDist","sqrLen","forEach","scale","translation","v","sum","scale","v","C","b","center","angle","a","b","distance","angle","A","B","D","C","slerp","scaledA","scaledB","slerp","V","v","A","B","C","b","V","slerp","F","u","v","a","b","c","scale","rotation","F","existingVertex","originId","D","A","B","C","originId","scale","distance","a","b"]}