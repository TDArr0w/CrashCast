/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{baseObjectMemory as t,estimateNumberMemory as e}from"../core/memoryEstimations.js";import{decodeGeohashXY as o}from"./geohashUtils.js";import s from"../geometry/SpatialReference.js";import{convertFromPolygon as r,quantizeOptimizedGeometry as i,convertFromPoint as h}from"../layers/graphics/featureConversionUtils.js";import a from"../layers/graphics/OptimizedGeometry.js";import{project as n}from"../layers/graphics/data/projectionSupport.js";import{AAggregateCell as l}from"../views/2d/layers/features/aggregation/AAggregateCell.js";import{AccumulatedStatistics as d}from"../views/2d/layers/features/aggregation/AccumulatedStatistics.js";const c=32;class _ extends l{static create(t,e,o,s){const r=d.create(t),i=new Array(c);for(let h=0;h<i.length;h++)i[h]=null;return new _(r,e,o,s,i)}constructor(t,e,o,s,r){super(t),this.xNode=e,this.yNode=o,this.depth=s,this.children=r,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}static get estimatedMemory(){let o=0;return o+=2*t,o+=e*c,o+=d.estimatedMemory,o}get id(){return`${this.xNode}.${this.yNode}`}get containedObjectIds(){return this._objectIds}get count(){return this._count}clone(){const t=new _(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return t._count=this._count,t._xWorldTotal=this._xWorldTotal,t._yWorldTotal=this._yWorldTotal,t._xGeohashTotal=this._xGeohashTotal,t._yGeohashTotal=this._yGeohashTotal,t.next=this.next,t._objectIds=new Set(this._objectIds),t}insert(t,e,o,s,r,i){this._count+=1,this._xWorldTotal+=e,this._yWorldTotal+=o,this._xGeohashTotal+=s,this._yGeohashTotal+=r,this._statistics.insert(t,i),this._objectIds.add(t.getObjectId())}merge(t){if(0!==t._count){this._count+=t._count,this._xWorldTotal+=t._xWorldTotal,this._yWorldTotal+=t._yWorldTotal,this._xGeohashTotal+=t._xWorldTotal,this._yGeohashTotal+=t._yWorldTotal,this._statistics.merge(t._statistics);for(const e of t._objectIds.values())this._objectIds.add(e)}}getCentroid(t){throw new Error("getCentroid not supported for GeohashNode")}getGeometry(t,e){const o=this._getLngLatBounds(),[h,l,d,c]=o,_=n({rings:[[[h,l],[h,c],[d,c],[d,l],[h,l]]]},s.WGS84,t),u=r(new a,_,!1,!1);if(null!=e){return i(new a,u,!1,!1,"esriGeometryPolygon",e,!1,!1)}return u}getGeometricCentroid(t,e){const o=this._getLngLatBounds(),[r,l,d,c]=o,_=n({x:(r+d)/2,y:(l+c)/2},s.WGS84,t),u=h(new a,_);if(null!=e){return i(new a,u,!1,!1,"esriGeometryPoint",e,!1,!1)}return u}getAttributes(){const t={aggregateId:this.id};for(const e of this._statistics.values())t[e.field.name]=e.value;return t.aggregateCount=this._count,t}find(t,e,o,s,r,i){if(s>=o)return this;const h=1-s%2,a=3*h+2*(1-h),n=2*h+3*(1-h),l=30-r-a,d=30-i-n,c=((t&7*h+3*(1-h)<<l)>>l)+((e&3*h+7*(1-h)<<d)>>d)*(8*h+4*(1-h)),_=this.children[c];return null==_?null:_.find(t,e,o,s+1,r+a,i+n)}_getLngLatBounds(){const t=this.depth,e=Math.ceil(t/2),s=Math.floor(t/2),r=30-(3*e+2*s),i=30-(2*e+3*s),h=this.xNode<<r,a=this.yNode<<i;return o({geohashX:h,geohashY:a},this.depth)}}export{_ as GeohashCell};
