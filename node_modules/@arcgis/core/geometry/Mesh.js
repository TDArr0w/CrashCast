/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import{ClonableMixin as t}from"../core/Clonable.js";import r from"../core/Error.js";import{LoadableMixin as o}from"../core/Loadable.js";import s from"../core/Logger.js";import{EsriPromiseMixin as n}from"../core/Promise.js";import{throwIfAborted as i,whenOrAbort as a}from"../core/promiseUtils.js";import{watch as p}from"../core/reactiveUtils.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/RandomLCG.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import{fromValues as m}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import h from"./Geometry.js";import u from"./Point.js";import f from"./Polygon.js";import{create as d,fromBuffer as g,zero as x}from"./support/aaBoundingBox.js";import{composeAxes as y,create as v}from"./support/axisAngleDegrees.js";import j from"./support/MeshComponent.js";import{componentNotFoundMessage as S,meshNotLoadedMessage as w,invalidLocationMessage as b,invalidPolygonMessage as L,InvalidLocationError as A}from"./support/meshErrors.js";import C from"./support/MeshGeoreferencedVertexSpace.js";import M from"./support/MeshLocalVertexSpace.js";import R from"./support/MeshTransform.js";import{MeshVertexAttributes as U}from"./support/MeshVertexAttributes.js";import{vertexSpaceOriginToPoint as _,isRelativeVertexSpace as F,selectVertexSpace as P}from"./support/meshVertexSpaceUtils.js";import{triangulate as E}from"./support/triangulationUtils.js";import{centerAt as B}from"./support/meshUtils/centerAt.js";import{computeMeshExtent as G}from"./support/meshUtils/extent.js";import{loadExternal as k}from"./support/meshUtils/loadExternal.js";import{addMeshMaterialCloneContext as I,addMeshTextureCloneContext as T,getMeshCloneContext as O}from"./support/meshUtils/meshCloneUtils.js";import{Metadata as z}from"./support/meshUtils/Metadata.js";import{convertUnitGeometry as V,createUnitSizeBox as D,extractSingleFaceOfBox as N,createUnitSizeSphere as Z,createUnitSizeCylinder as H,convertPlaneSizeParameter as K,createUnitSizePlane as W}from"./support/meshUtils/primitives.js";import{rotate as q}from"./support/meshUtils/rotate.js";import{scale as J}from"./support/meshUtils/scale.js";var Q;const X={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:C,local:M}};let Y=Q=class extends(t(o(n(h)))){constructor(e){super(e),this.components=null,this.vertexSpace=new C,this.transform=null,this.metadata=new z,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new U,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.addHandles(p(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(e=>e.clone())}),()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{spatialReference:e,vertexSpace:t}=this,r=this;return G({get transform(){return r.transform},vertexSpace:t,spatialReference:e,untransformedBounds:this._untransformedBounds})}get _untransformedBounds(){const{vertexAttributes:{position:e},components:t}=this;return 0===e.length||0===t?.length?d(x):g(e)}get origin(){const e=_(this.vertexSpace,this.spatialReference);if(null!=e)return e;const{center:t,zmin:r}=this._transformedExtent;return new u({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(j.from(e)),this.notifyChange("components"))}removeComponent(e){if(this._checkIfLoaded("removeComponent()")){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}s.getLogger(this).error("removeComponent()",S)}}rotate(e,t,r,o){return y(e,t,r,$),q(this,$,o),this}offset(e,t,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:o,vertexAttributes:s}=this,n=s?.position;if(!n)return this;if(F(o)){const[s,n,i]=o.origin;o.origin=m(s+e,n+t,i+r)}else{for(let o=0;o<n.length;o+=3)n[o]+=e,n[o+1]+=t,n[o+2]+=r;this.vertexAttributesChanged()}return this}scale(e,t){return this._checkIfLoaded("scale()")?(J(this,e,t),this):this}centerAt(e,t){return this._checkIfLoaded("centerAt()")?(B(this,e,t),this):this}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(k(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(e){return super.clone(I(T(e)))}cloneShallow(){return new Q({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const[{toBinaryGLTF:t}]=await Promise.all([import("./support/meshUtils/exporters/gltf/gltfexport.js"),this.load(e)]);return i(e),await t(this,e)}get usedMemory(){return this.components?this.components.reduce((e,t)=>e+t.memoryUsage,this.vertexAttributes.usedMemory):this.vertexAttributes.usedMemory}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(e){return!!this.loaded||(s.getLogger(this).error(e,w),!1)}static createBox(e,t){if(!(e instanceof u))return s.getLogger(this.prototype).error(".createBox()",b),null;const r=new Q(V(D(),e,t));return t?.imageFace&&"all"!==t.imageFace?N(r,t.imageFace):r}static createSphere(e,t){return e instanceof u?new Q(V(Z(t?.densificationFactor||0),e,t)):(s.getLogger(this.prototype).error(".createSphere()",b),null)}static createCylinder(e,t){return e instanceof u?new Q(V(H(t?.densificationFactor||0),e,t)):(s.getLogger(this.prototype).error(".createCylinder()",b),null)}static createPlane(e,t){if(!(e instanceof u))return s.getLogger(this.prototype).error(".createPlane()",b),null;const r=t?.facing??"up",o=K(r,t?.size);return new Q(V(W(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof f))return s.getLogger(this.prototype).error(".createFromPolygon()",L),null;const r=E(e);return new Q({vertexAttributes:new U({position:r.position}),components:[new j({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new C})}static async createFromGLTF(e,t,r){if(!(e instanceof u)){const e=new A;throw s.getLogger(this.prototype).error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:o}=await a(import("./support/meshUtils/loadGLTFMesh.js"),r);return new Q((await o(e,t,r)).mesh)}static createWithExternalSource(e,t,r){const o=r?.extent??null,{spatialReference:s}=e,n=r?.transform?.clone()??new R,i=P(e,r),a=r?.unitConversionDisabled,p={source:t,extent:o,unitConversionDisabled:a},c=new z;return c.externalSources.push(p),new Q({metadata:c,transform:n,vertexSpace:i,spatialReference:s})}static createIncomplete(e,t){const{spatialReference:o}=e,s=t?.transform?.clone()??new R,n=P(e,t),i=new Q({transform:s,vertexSpace:n,spatialReference:o});return i.addResolvingPromise(Promise.reject(new r("mesh-incomplete","Mesh resources are not complete"))),i}};e([c({type:[j],json:{write:!0}})],Y.prototype,"components",void 0),e([c({nonNullable:!0,types:X,constructOnly:!0,json:{write:!0},clonable:(e,t)=>O(t)?.vertexSpace??e.clone(t)})],Y.prototype,"vertexSpace",void 0),e([c({type:R,clonable:(e,t)=>{const r=O(t);return r&&"transform"in r?r.transform:e?.clone()??e},json:{write:!0}})],Y.prototype,"transform",void 0),e([c({constructOnly:!0,type:z,clonable:(e,t)=>O(t)?.metadata??e.clone()})],Y.prototype,"metadata",void 0),e([c()],Y.prototype,"hasExtent",null),e([c()],Y.prototype,"_transformedExtent",null),e([c()],Y.prototype,"_untransformedBounds",null),e([c()],Y.prototype,"origin",null),e([c({readOnly:!0,json:{read:!1}})],Y.prototype,"extent",null),e([c({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Y.prototype,"hasZ",void 0),e([c({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Y.prototype,"hasM",void 0),e([c({type:U,nonNullable:!0,json:{write:!0},clonable:(e,t)=>O(t)?.vertexAttributes??e.clone(t)})],Y.prototype,"vertexAttributes",void 0),Y=Q=e([l("esri.geometry.Mesh")],Y);const $=v();export{Y as default};
