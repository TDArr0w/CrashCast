/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../config.js";import{Cyclical as e}from"../../core/Cyclical.js";import n from"../../core/Error.js";import o from"../../core/Logger.js";import s from"../Polygon.js";import r from"../Polyline.js";import i from"../SpatialReference.js";import{cutParams as l,offsetMagnitude as c,updatePolyGeometry as f,getGeometryParts as u}from"./normalizeUtilsCommon.js";import{getInfo as a}from"./spatialReferenceUtils.js";import{geographicToWebMercator as p,webMercatorToGeographic as h}from"./webMercatorUtils.js";import{cut as m}from"../../rest/geometryService/cut.js";import{simplify as g}from"../../rest/geometryService/simplify.js";const y=()=>o.getLogger("esri.geometry.support.normalizeUtils");function x(t){return"polygon"===t.type}function d(t){return"polygon"===t[0].type}function M(t){return"polyline"===t[0].type}function w(t){const e=[];let n=0,o=0;for(let s=0;s<t.length;s++){const r=t[s];let i=null;for(let t=0;t<r.length;t++)i=r[t],e.push(i),0===t?(n=i[0],o=n):(n=Math.min(n,i[0]),o=Math.max(o,i[0]));i&&e.push([(n+o)/2,0])}return e}function b(t,e){if(!(t instanceof r||t instanceof s)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw y().error(t),new n("internal:geometry",t)}const o=u(t),i=[];for(const n of o){const t=[];i.push(t),t.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const s=n[o][0],r=n[o][1],i=n[o+1][0],l=n[o+1][1],c=Math.sqrt((i-s)*(i-s)+(l-r)*(l-r)),f=(l-r)/c,u=(i-s)/c,a=c/e;if(a>1){for(let l=1;l<=a-1;l++){const n=l*e,o=u*n+s,i=f*n+r;t.push([o,i])}const n=(c+Math.floor(a-1)*e)/2,o=u*n+s,i=f*n+r;t.push([o,i])}t.push([i,l])}}return x(t)?new s({rings:i,spatialReference:t.spatialReference}):new r({paths:i,spatialReference:t.spatialReference})}function j(t,e,n){if(e){const e=b(t,1e6);t=h(e,!0)}return n&&(t=f(t,n)),t}function R(t,e,n){if(Array.isArray(t)){const o=t[0];if(o>e){const n=c(o,e);t[0]=o+n*(-2*e)}else if(o<n){const e=c(o,n);t[0]=o+e*(-2*n)}}else{const o=t.x;if(o>e){const n=c(o,e);t=t.clone().offset(n*(-2*e),0)}else if(o<n){const e=c(o,n);t=t.clone().offset(e*(-2*n),0)}}return t}function v(t,e){let n=-1;for(let o=0;o<e.cutIndexes.length;o++){const s=e.cutIndexes[o],r=e.geometries[o],i=u(r);for(let t=0;t<i.length;t++){const e=i[t];e.some(n=>{if(n[0]<180)return!0;{let n=0;for(let t=0;t<e.length;t++){const o=e[t][0];n=o>n?o:n}n=Number(n.toFixed(9));const o=-360*c(n,180);for(let s=0;s<e.length;s++){const e=r.getPoint(t,s);r.setPoint(t,s,e.clone().offset(o,0))}return!0}})}if(s===n){if(d(t))for(const e of u(r))t[s]=t[s].addRing(e);else if(M(t))for(const e of u(r))t[s]=t[s].addPath(e)}else n=s,t[s]=r}return t}async function P(e,n,o){if(!Array.isArray(e))return P([e],n);n&&"string"!=typeof n&&y().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const i="string"==typeof n?n:n?.url??t.geometryServiceUrl;let u,h,x,d,M,w,b,z,L=0;const S=[],U=[];for(const t of e)if(null!=t)if(u||(u=t.spatialReference,h=a(u),x=u.isWebMercator,w=x?102100:4326,d=l[w].maxX,M=l[w].minX,b=l[w].plus180Line,z=l[w].minus180Line),h)if("mesh"===t.type)U.push(t);else if("point"===t.type)U.push(R(t.clone(),d,M));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map(t=>R(t,d,M)),U.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,h);U.push(e.rings?new s(e):e)}else if(t.extent){const e=t.extent,n=c(e.xmin,M)*(2*d);let o=0===n?t.clone():f(t.clone(),n);e.offset(n,0);let{xmin:s,xmax:r}=e;s=Number(s.toFixed(9)),r=Number(r.toFixed(9)),e.intersects(b)&&r!==d?(L=r>L?r:L,o=j(o,x),S.push(o),U.push("cut")):e.intersects(z)&&s!==M?(L=r*(2*d)>L?r*(2*d):L,o=j(o,x,360),S.push(o),U.push("cut")):U.push(o)}else U.push(t.clone());else U.push(t);else U.push(t);let A=c(L,d),C=-90;const F=A,N=new r;for(;A>0;){const t=360*A-180;N.addPath([[t,C],[t,-1*C]]),C*=-1,A--}if(S.length>0&&F>0){const t=v(S,await m(i,S,N,o)),n=[],s=[];for(let o=0;o<U.length;o++){const r=U[o];if("cut"!==r)s.push(r);else{const r=t.shift(),i=e[o];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(n.push(r),s.push("simplify")):s.push(x?p(r):r)}}if(!n.length)return s;const r=await g(i,n,o),l=[];for(let e=0;e<s.length;e++){const t=s[e];"simplify"!==t?l.push(t):l.push(x?p(r.shift()):r.shift())}return l}const W=[];for(let t=0;t<U.length;t++){const e=U[t];if("cut"!==e)W.push(e);else{const t=S.shift();W.push(!0===x?p(t):t)}}return W}function z(t){if(!t)return null;const e=t.extent;if(!e)return null;const n=t.spatialReference&&a(t.spatialReference);if(!n)return e;const[o,s]=n.valid,r=2*s,{width:i}=e;let l,{xmin:c,xmax:f}=e;if([c,f]=[f,c],"extent"===t.type||0===i||i<=s||i>r||c<o||f>s)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;l=w(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;l=w(t.paths);break;case"multipoint":l=t.points}const u=e.clone();for(let a=0;a<l.length;a++){let t=l[a][0];t<0?(t+=s,f=Math.max(t,f)):(t-=s,c=Math.min(t,c))}return u.xmin=c,u.xmax=f,u.width<i?(u.xmin-=s,u.xmax-=s,u):e}function L(t,e,n){const o=a(n);if(null==o)return t;const[s,r]=o.valid,i=2*r;let l=0,c=0;e>r?l=Math.ceil(Math.abs(e-r)/i):e<s&&(l=-Math.ceil(Math.abs(e-s)/i)),t>r?c=Math.ceil(Math.abs(t-r)/i):t<s&&(c=-Math.ceil(Math.abs(t-s)/i));let f=t+(l-c)*i;const u=f-e;return u>r?f-=i:u<s&&(f+=i),f}function S(t,e){const n=U(e);return n?.normalize(t)??t}function U(t){const n=a(t);if(null==n)return null;const[o,s]=n.valid;return new e(o,s)}const A=U(i.WGS84),C=U(i.WebMercator);export{U as createSpatialReferenceCyclical,A as gcsCyclical,L as getClosestDenormalizedXToReference,z as getDenormalizedExtent,P as normalizeCentralMeridian,S as normalizeMapX,b as straightLineDensify,C as webMercatorCyclical};
