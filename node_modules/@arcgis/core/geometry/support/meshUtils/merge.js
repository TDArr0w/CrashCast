/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{G as t,g as r,h as o}from"../../../chunks/vec32.js";import{create as n}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import s from"../MeshComponent.js";import{MeshVertexAttributes as i}from"../MeshVertexAttributes.js";import{addMeshMaterialCloneContext as l,addMeshTextureCloneContext as a,getMeshMaterialCloneContext as c}from"./meshCloneUtils.js";import{convertVertexSpace as u}from"./vertexSpaceConversion.js";const f=()=>e.getLogger("esri.geometry.support.triangleMeshMerge");function p(e,t){if(0===e.length)return f().error("merge()","Must specify one more geometries to merge"),null;const r=e[0].spatialReference;for(const l of e){if(!l.spatialReference.equals(r))return f().error("merge()","Geometries must all be in the same spatial reference"),null;if(!l.loaded)return f().error("merge()","Geometries must all be loaded before merging"),null}const o=m(e);if(null==o)return null;const n=w(e),s=[],i={position:0,uv:0,normal:0,tangent:0,color:0},p=l(a()),g=c(p);for(const l of e){const e=o.rebake?u(l,o.vertexSpace,{allowBufferReuse:!0}):l.vertexAttributes;if(!e)return f().error("merge()","Failed to convert vertex space due to projection errors"),null;if(t&&t.reuseMaterials&&l.components)for(const t of l.components)t.material&&g?.materialMap?.set(t.material,t.material);h(l,i,p,s),x("position",e,n,i,0),x("normal",e,n,i,0),x("tangent",e,n,i,0),x("uv",l.vertexAttributes,n,i,0),x("color",l.vertexAttributes,n,i,255)}return{vertexAttributes:n,components:s,vertexSpace:o.vertexSpace,transform:o.rebake?null:o.transform,spatialReference:r}}function m(e){let s=null,i=null,l=!0,a=!0,c=null;const u=n();let p=0;for(const o of e){const{vertexSpace:e,transform:n}=o;if(null==i){i=e;const t=i.origin;t&&(c=t)}if(i.type!==e.type)return f().error("merge()",`Inconsistent mesh vertex space for provided geometries. One was ${i.type} while another is ${e.type}. Unable to merge geometries.`),null;null==s||null!=n&&n.equals(s)||(l=!1),null!=n&&null==s&&(s=n);const m=e.origin;m&&(c&&!t(m,c)&&(a=!1),p++,r(u,u,m))}if(null==i)throw new Error;const m=i.clone();if(null==m.origin)return{rebake:!1,vertexSpace:m};if(a&&l)return{rebake:!1,vertexSpace:m,transform:s?.clone()};const g=o(u,u,1/p);return m.origin=g,{rebake:!0,vertexSpace:m}}function g(e,t){return t.normal>0&&!e.vertexAttributes.normal}function v(e,t,r){g(e,t)&&"source"===r.shading&&(r.shading="flat")}function h(e,t,r,o){if(e.components)for(const n of e.components){const s=n.clone(r),i=t.position/3;if(s.faces)for(let e=0;e<s.faces.length;e++)s.faces[e]+=i;else{s.faces=new Uint32Array(e.vertexAttributes.position.length/3);for(let e=0;e<s.faces.length;e++)s.faces[e]=e+i}v(e,t,s),o.push(s)}else if(e.vertexAttributes&&e.vertexAttributes.position){const r=e.vertexAttributes.position.length/3,n=new Uint32Array(r),i=t.position/3;for(let e=0;e<r;e++)n[e]=e+i;const l=new s({faces:n});v(e,t,l),o.push(l)}}function x(e,t,r,o,n){if(!t)return;const s=t.position;if(!s)return;const i=t[e],l=r[e];if(null==i){let t=o[e];const r=y[e];if(null!=l){for(let e=0;e<s.length;e+=3)for(let o=0;o<r;o++)l[t++]=n;o[e]=t}}else null!=l&&null!=i&&(b(i,0,l,o[e],i.length),o[e]+=i.length)}function b(e,t,r,o,n){for(let s=0;s<n;s++)r[o++]=e[t++];return r}function A(e){let t=!1,r=!1,o=!1,n=!1;for(const s of e){const e=s.vertexAttributes;if(e?.position&&(e.uv&&(t=!0),e.normal&&(r=!0),e.tangent&&(n=!0),e.color&&(o=!0),r&&t&&o&&n))break}return{normal:r,uv:t,color:o,tangent:n}}function w(e){let t=0,r=0,o=0,n=0,s=0;const l=A(e);for(const i of e){const e=i.vertexAttributes;e?.position&&(t+=e.position.length,l.uv&&(r+=e.position.length/y.position*y.uv),l.normal&&(o+=e.position.length/y.position*y.normal),l.color&&(n+=e.position.length/y.position*y.color),l.tangent&&(s+=e.position.length/y.position*y.tangent))}return new i({position:new Float64Array(t),uv:r?new Float32Array(r):null,normal:o?new Float32Array(o):null,tangent:s?new Float32Array(s):null,color:n?new Uint8Array(n):null})}const y={position:3,normal:3,tangent:4,uv:2,color:4};export{p as merge};
