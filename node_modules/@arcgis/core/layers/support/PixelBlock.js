/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import s from"../../core/Error.js";import{JSONSupport as e}from"../../core/JSONSupport.js";import{clone as i}from"../../core/lang.js";import l from"../../core/Logger.js";import{property as r}from"../../core/accessorSupport/decorators/property.js";import{cast as o}from"../../core/accessorSupport/decorators/cast.js";import{subclass as a}from"../../core/accessorSupport/decorators/subclass.js";import{SimpleBandStatistics as n}from"./SimpleBandStatistics.js";import{getPixelValueRange as h}from"./rasterFormats/pixelRangeUtils.js";var p;let c=p=class extends e{static createEmptyBand(t,s){return new(p.getPixelArrayConstructor(t))(s)}static combineBandMasks(t){if(t.length<2)return t[0];const s=t[0].length,e=new Uint8Array(s).fill(255);for(let i=0;i<t.length;i++){const l=t[i];for(let t=0;t<s;t++)l[t]||(e[t]=0)}return e}static getPixelArrayConstructor(t){let s;switch(t){case"u1":case"u2":case"u4":case"u8":s=Uint8Array;break;case"u16":s=Uint16Array;break;case"u32":s=Uint32Array;break;case"s8":s=Int8Array;break;case"s16":s=Int16Array;break;case"s32":s=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":s=Float32Array;break;case"f64":s=Float64Array}return s}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let s=t.toLowerCase();return["u1","u2","u4"].includes(s)?s="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(s)||(s="f32"),s}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new s("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new n)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(t=>u(t,this.mask));const t=this.mask;let s=0;if(null!=t)for(let e=0;e<t.length;e++)t[e]&&s++;else s=this.width*this.height;this.validPixelCount=s}clamp(t){if(!t||"f64"===t||"f32"===t||!this.pixels)return;const[s,e]=h(t),i=this.pixels,l=this.width*this.height,r=i.length;let o,a,n;const c=[];for(let h=0;h<r;h++){n=p.createEmptyBand(t,l),o=i[h];for(let t=0;t<l;t++)a=o[t],n[t]=a>e?e:a<s?s:a;c.push(n)}this.pixels=c,this.pixelType=t}extractBands(t){const{pixels:s,statistics:e}=this;if(null==t||0===t.length||!s||0===s.length)return this;const i=s.length,l=t.some(t=>t>=s.length),r=i===t.length&&!t.some((t,s)=>t!==s);if(l||r)return this;const o=this.bandMasks?.length===i?t.map(t=>this.bandMasks[t]):void 0;let{mask:a,validPixelCount:n}=this;const{width:h,height:c}=this;return o?.length&&(a=p.combineBandMasks(o),n=a.filter(t=>!!t).length),new p({pixelType:this.pixelType,width:h,height:c,mask:a,bandMasks:o,validPixelCount:n,maskIsAlpha:this.maskIsAlpha,pixels:t.map(t=>s[t]),statistics:e&&t.map(t=>e[t])})}clone(){const t=new p({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount});let s;null!=this.mask&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(t=>new Uint8Array(t)));const e=p.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const i=!!this.pixels[0].slice;for(s=0;s<this.pixels.length;s++)t.pixels[s]=i?this.pixels[s].slice():new e(this.pixels[s])}if(this.statistics)for(t.statistics=[],s=0;s<this.statistics.length;s++)t.statistics[s]=i(this.statistics[s]);return t}getTransferableObject(){const{pixels:t,bandMasks:s,mask:e}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;const i=this.toJSON();this.pixels=t,this.bandMasks=s,this.mask=e,i.pixels=t?[...t]:t,i.bandMasks=s?[...s]:s,i.mask=e;const l=[];return[...t??[],e,...s??[]].filter(t=>null!=t&&ArrayBuffer.isView(t)).forEach(t=>{t&&!l.includes(t.buffer)&&l.push(t.buffer)}),{pixelBlock:i,transferList:l}}_fillFrom8Bit(t){const{mask:s,maskIsAlpha:e,premultiplyAlpha:i,pixels:r}=this;if(!t||!r?.length)return void l.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let o,a,n,h;o=a=n=r[0],r.length>=3?(a=r[1],n=r[2]):2===r.length&&(a=r[1]);const p=new Uint32Array(t),c=this.width*this.height;if(o.length===c)if(null!=s&&s.length===c)if(e)for(h=0;h<c;h++){const t=s[h];if(t){const s=t/255;p[h]=i?t<<24|n[h]*s<<16|a[h]*s<<8|o[h]*s:t<<24|n[h]<<16|a[h]<<8|o[h]}}else for(h=0;h<c;h++)s[h]&&(p[h]=255<<24|n[h]<<16|a[h]<<8|o[h]);else for(h=0;h<c;h++)p[h]=255<<24|n[h]<<16|a[h]<<8|o[h];else l.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:s,mask:e,statistics:i}=this;if(!t||!s?.length)return void l.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const r=this.pixelType;let o=1,a=0,n=1;if(i&&i.length>0){for(const t of i)if(null!=t.minValue&&(a=Math.min(a,t.minValue)),null!=t.maxValue&&null!=t.minValue){const s=t.maxValue-t.minValue;n=Math.max(n,s)}o=255/n}else{let t=255;"s8"===r?(a=-128,t=127):"u16"===r?t=65535:"s16"===r?(a=-32768,t=32767):"u32"===r?t=4294967295:"s32"===r?(a=-2147483648,t=2147483647):"f32"===r?(a=-34e38,t=34e38):"f64"===r&&(a=-Number.MAX_VALUE,t=Number.MAX_VALUE),o=255/(t-a)}const h=new Uint32Array(t),p=this.width*this.height;let c,u,f,g,m;if(c=u=f=s[0],c.length!==p)return l.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(s.length>=2)if(u=s[1],s.length>=3&&(f=s[2]),null!=e&&e.length===p)for(g=0;g<p;g++)e[g]&&(h[g]=255<<24|(f[g]-a)*o<<16|(u[g]-a)*o<<8|(c[g]-a)*o);else for(g=0;g<p;g++)h[g]=255<<24|(f[g]-a)*o<<16|(u[g]-a)*o<<8|(c[g]-a)*o;else if(null!=e&&e.length===p)for(g=0;g<p;g++)m=(c[g]-a)*o,e[g]&&(h[g]=255<<24|m<<16|m<<8|m);else for(g=0;g<p;g++)m=(c[g]-a)*o,h[g]=255<<24|m<<16|m<<8|m}_fillFrom32Bit(t){const{pixels:s,mask:e}=this;if(!t||!s?.length)return l.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,r,o,a;i=r=o=s[0],s.length>=3?(r=s[1],o=s[2]):2===s.length&&(r=s[1]);const n=this.width*this.height;if(i.length!==n)return l.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let h=0;if(null!=e&&e.length===n)for(a=0;a<n;a++)t[h++]=i[a],t[h++]=r[a],t[h++]=o[a],t[h++]=1&e[a];else for(a=0;a<n;a++)t[h++]=i[a],t[h++]=r[a],t[h++]=o[a],t[h++]=1}};function u(t,s){let e=1/0,i=-1/0;const l=t.length;let r,o=0;if(null!=s)for(r=0;r<l;r++)s[r]&&(o=t[r],e=o<e?o:e,i=o>i?o:i);else for(r=0;r<l;r++)o=t[r],e=o<e?o:e,i=o>i?o:i;return new n(e,i)}t([r({json:{write:!0}})],c.prototype,"width",void 0),t([r({json:{write:!0}})],c.prototype,"height",void 0),t([r({json:{write:!0}})],c.prototype,"pixelType",void 0),t([o("pixelType")],c.prototype,"castPixelType",null),t([r({json:{write:!0}})],c.prototype,"validPixelCount",void 0),t([r({json:{write:!0}})],c.prototype,"mask",void 0),t([r({json:{write:!0}})],c.prototype,"maskIsAlpha",void 0),t([r({json:{write:!0}})],c.prototype,"pixels",void 0),t([r()],c.prototype,"premultiplyAlpha",void 0),t([r({json:{write:!0}})],c.prototype,"statistics",void 0),t([r({json:{write:!0}})],c.prototype,"depthCount",void 0),t([r({json:{write:!0}})],c.prototype,"noDataValues",void 0),t([r({json:{write:!0}})],c.prototype,"bandMasks",void 0),c=p=t([a("esri.layers.support.PixelBlock")],c);export{c as default};
