/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../geometry/Extent.js";import r from"../../geometry/Point.js";import t from"../../geometry/operators/support/GeographicTransformation.js";import s from"./PixelBlock.js";import{decode as o}from"./rasterFormats/RasterCodec.js";import{convertPixelBlockToFeatures as i,highlightPixels as n,split as l,clipTile as a,mosaic as m,approximateTransform as c,getLocalArithmeticNorthRotations as f}from"./rasterFunctions/pixelUtils.js";import{create as p}from"./rasterFunctions/rasterFunctionHelper.js";import{load as u,getProjectionOffsetGrid as S}from"./rasterFunctions/rasterProjectionHelper.js";import{computeStatisticsHistograms as d,estimateStatisticsHistograms as x}from"./rasterFunctions/stretchUtils.js";import{convertVectorFieldData as h,convertToLocalDirections as g}from"./rasterFunctions/vectorFieldUtils.js";import{readTransform as y}from"./rasterTransforms/utils.js";import O from"../../renderers/support/RasterSymbolizer.js";import{createFlowMesh as k}from"../../views/2d/engine/flow/dataUtils.js";function B(e){if(!e)return{result:null,transferList:[]};const{pixelBlock:r,transferList:t}=e.getTransferableObject();return{result:r,transferList:t}}class N{convertVectorFieldData(e){const r=s.fromJSON(e.pixelBlock),t=B(h(r,e.type));return Promise.resolve(t)}convertPixelBlockToFeatures(r){const t=i({pixelBlock:s.fromJSON(r.pixelBlock),extent:e.fromJSON(r.extent),fieldNames:r.fieldNames,skipFactor:r.skipFactor,skipSpatialReference:!0,pixelIdOffset:r.pixelIdOffset,imageRowSize:r.imageRowSize});return Promise.resolve(t)}computeStatisticsHistograms(e){const r=s.fromJSON(e.pixelBlock),t=d(r,{histogramSize:e.histogramSize,includeSkewnessKurtosis:e.includeSkewnessKurtosis});return Promise.resolve(t)}async decode(e){return B(await o(e.data,e.options))}symbolize(r){r.pixelBlock=s.fromJSON(r.pixelBlock),r.extent=r.extent?e.fromJSON(r.extent):null;const t=B(this.symbolizer.symbolize(r));return Promise.resolve(t)}highlightPixels(e){const r=s.fromJSON(e.pixelBlock),t=s.fromJSON(e.renderedPixelBlock);return n(r,t,e.highlightOptions),Promise.resolve(t.toJSON())}async updateSymbolizer(e){this.symbolizer=O.fromJSON(e.symbolizerJSON),e.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=e.histograms)}async updateRasterFunction(e){this.rasterFunction=p(e.rasterFunctionJSON)}async process(t){return B(this.rasterFunction.process({extent:e.fromJSON(t.extent),primaryPixelBlocks:t.primaryPixelBlocks.map(e=>null!=e?s.fromJSON(e):null),primaryPixelSizes:t.primaryPixelSizes?.map(e=>null!=e?r.fromJSON(e):null),primaryRasterIds:t.primaryRasterIds}))}stretch(e){const r=B(this.symbolizer.simpleStretch(s.fromJSON(e.srcPixelBlock),e.stretchParams));return Promise.resolve(r)}estimateStatisticsHistograms(e){const r=x(s.fromJSON(e.srcPixelBlock));return Promise.resolve(r)}split(e){const r=l(s.fromJSON(e.srcPixelBlock),e.tileSize,e.maximumPyramidLevel??0,!1===e.useBilinear),t=[];let o;return r&&(o=new Map,r.forEach((e,r)=>{if(e){const{pixelBlock:s,transferList:i}=e.getTransferableObject();o.set(r,s),i.forEach(e=>{t.includes(e)||t.push(e)})}})),Promise.resolve({result:o,transferList:t})}clipTile(e){const r=s.fromJSON(e.pixelBlock),t=B(a({...e,pixelBlock:r}));return Promise.resolve(t)}async mosaicAndTransform(e){const r=e.srcPixelBlocks.map(e=>e?new s(e):null),t=m(r,e.srcMosaicSize,{blockWidths:e.blockWidths,alignmentInfo:e.alignmentInfo,clipOffset:e.clipOffset,clipSize:e.clipSize});let o,i=t;e.coefs&&(i=c(t,e.destDimension,e.coefs,e.sampleSpacing,e.interpolation)),e.projectDirections&&e.gcsGrid&&(o=f(e.destDimension,e.gcsGrid),i=g(i,e.isUV?"vector-uv":"vector-magdir",o));const{result:n,transferList:l}=B(i);return{result:{pixelBlock:n,localNorthDirections:o},transferList:l}}async createFlowMesh(e,r){const t={data:new Float32Array(e.flowData.buffer),mask:new Uint8Array(e.flowData.maskBuffer),width:e.flowData.width,height:e.flowData.height},{vertexData:s,indexData:o}=await k(e.meshType,e.simulationSettings,t,r.signal);return{result:{vertexBuffer:s.buffer,indexBuffer:o.buffer},transferList:[s.buffer,o.buffer]}}async getProjectionOffsetGrid(r){const s=e.fromJSON(r.projectedExtent),o=e.fromJSON(r.srcBufferExtent);let i=null;r.datumTransformationSteps?.length&&(i=new t({steps:r.datumTransformationSteps})),await u();const n=r.rasterTransform?y(r.rasterTransform):null;return S({...r,projectedExtent:s,srcBufferExtent:o,datumTransformation:i,rasterTransform:n})}}export{N as default};
