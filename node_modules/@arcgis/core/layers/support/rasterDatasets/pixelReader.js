/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{throwIfAborted as t}from"../../../core/promiseUtils.js";import i from"../../../geometry/Extent.js";import n from"../../../geometry/Point.js";import o from"../Field.js";import r from"../PixelBlock.js";import{getByteCount as a}from"../rasterFormats/pixelRangeUtils.js";import{snapToRaster as s,clip as l}from"../rasterFunctions/clipUtils.js";import{mosaic as c,pixelIdFieldName as p,convertPixelBlockToFeatures as u,getValidPixels as f,countCategoricalPixels as m}from"../rasterFunctions/pixelUtils.js";import{load as x,projectPolygon as h}from"../rasterFunctions/rasterProjectionHelper.js";import{computeBoxStatistics as y,computeStatisticsHistograms as d}from"../rasterFunctions/stretchUtils.js";import{getBandNames as w}from"../../../renderers/support/rasterRendererHelper.js";import g from"../../../rest/support/ImageIdentifyParameters.js";const k=2**30,b=2048,B=2**20,S=20,j=100;async function R(e,t){return"imagery"===e.type?await e.generateRasterInfo(e.rasterFunction,t):e.raster.rasterInfo}function P(e){const t=[new o({name:p,alias:"Pixel ID",type:"oid"})],{pixelType:i}=e,n="f32"===i?"single":"f64"===i?"double":"integer";return w(e).forEach(e=>{t.push(new o({name:e,alias:e,type:n}))}),t.map(e=>e.toJSON())}async function F(t,i){if(t.spatialReference.equals(i))return t;if("polyline"===t.type){const n=(await import("../../../geometry/operators/projectOperator.js")).execute(t,i);if(null==n)throw new e("read-pixels","failed to project the geometry into the layer's spatial reference");return n}if("extent"===t.type||t.rings[0].length<S){const e=(await import("../../../geometry/operators/lengthOperator.js")).execute(t,{unit:"meters"})/j;t=(await import("../../../geometry/operators/densifyOperator.js")).execute(t,e,{unit:"meters"}),await x(),t=h(t,i)}return t}async function M(e,t,i=!1){const{spatialReference:o}=e,r=t?.geometry,a=await F(r??e.extent,o),l="extent"===a.type?a:a.extent,c=null==r||"extent"===r.type&&r.spatialReference.equals(o)?void 0:a,p=new n({x:e.pixelSize.x,y:e.pixelSize.y,spatialReference:o}),u=!!t?.autoResample,f=u?p:t?.pixelSize??p;let{extent:m,width:x,height:h}=s(e,l,f);if(!u)return{extent:m,clipGeometry:c,width:x,height:h,pixelSize:f};const y=e.storageInfo?.pyramidScalingFactor??2;let{x:d,y:w}=f;const g=t?.maxPixelCount??B;for(;x*h>g&&(!i||Math.max(x,h)>1024);)d*=y,w*=y,x/=y,h/=y;return x=Math.round(x),h=Math.round(h),{extent:m,clipGeometry:c,width:x,height:h,pixelSize:new n({x:d,y:w,spatialReference:o})}}async function*I(e,n,o=!1,r){const{extent:a,clipGeometry:s,width:c,height:p}=n,u=a.width/c,f=a.height/p,m=Math.ceil(c/b),x=Math.ceil(p/b),h=u*b,y=f*b,{xmin:d,xmax:w,ymin:g,ymax:k}=a,B=x*m,S={bandIds:n.bandIds?.length?n.bandIds:void 0,interpolation:"nearest",...r};for(let j=0;j<x;j++)for(let n=0;n<m;n++){t(S);const r=new i({xmin:d+n*h,xmax:o?Math.min(w,d+(n+1)*h):d+(n+1)*h,ymax:k-j*y,ymin:o?Math.max(g,k-(j+1)*y):k-(j+1)*y,spatialReference:a.spatialReference}),c={row:j,col:n},p=j*m+n+1;if(s&&!r.intersects(s)){yield{extent:r,pixelBlock:null,id:c,total:B,current:p};continue}const x=o?Math.round(r.width/u):b,R=o?Math.round(r.height/f):b;let{pixelBlock:P}=await e.fetchPixels(r,x,R,S).catch(()=>({pixelBlock:void 0}));P&&s&&(P=await l(P,r,s)),yield{extent:r,pixelBlock:P,id:c,total:B,current:p}}}async function*T(e,i,n){const o=await R(e,n),r=P(o),a={...i,geometry:i?.geometry??o.extent},s=I(e,await M(o,a),!0,n),l=o.width;for await(const c of s){if(!c.pixelBlock){yield{...c};continue}const a=L(e),{pixelBlock:s}=c,{statistics:p,histograms:u}=await W({pixelBlock:s,rasterJobHandler:a},n),f=c;f.statistics=p,f.histograms=u;const m=c.id.row*o.width*b+c.id.col*b;t(n),f.featureSet=await K({pixelBlock:s,extent:c.extent,fields:r,skipFactor:i?.skipFactor??1,rasterJobHandler:a,pixelIdOffset:m,imageRowSize:l},n),t(n),yield f}}function v(t,i,n){const o=a(i),{width:r,height:s}=t;if(r*s*o>k)throw new e("fetch-pixels","failed to fetch pixels as pixel byte count exceeds the 1GB limit");if(n&&r*s>n)throw new e("fetch-pixels",`failed to fetch pixels as pixel count exceeds the ${n} limit`)}async function z(t,i,n){if(!i.geometry)throw new e("fetch-pixels","geometry is required to fetch pixel feature set");const o=await R(t),r=await M(o,i,!0);v(r,o.pixelType);const{extent:a,pixelSize:s}=r,l=Math.round(o.extent.width/s.x),c=P(o),p={fields:c,features:[]},u=p.features,{maxPixelCount:f}=i,m=!!i.autoResample&&null!=f&&r.width*r.height>f,x=m?1:i.skipFactor??1,h=r.width<=b||r.height<=b,y=I(t,r,1===x||h,n);for await(const e of y){if(!e.pixelBlock)continue;const i=L(t),r=Math.floor((o.extent.ymax-e.extent.ymax)/s.y)*l+Math.floor((e.extent.xmin-o.extent.xmin)/s.x),a=await K({pixelBlock:e.pixelBlock,extent:e.extent,fields:c,skipFactor:x,rasterJobHandler:i,pixelIdOffset:r,imageRowSize:l},n);if(a?.features?.length){const{features:e}=a,t=e.length;for(let i=0;i<t;i++){const t=e.pop();u.push(t)}}}if(m&&f){const e=f/(i.skipFactor??1)**2;if(u.length>e){const t=u.length/e,i=[...u],n=u.length-1;u.length=0;for(let o=0,r=0;o<e-1;o++){r+=t;const e=Math.round(r);e<n&&u.push(i[e])}}}return{extent:a,featureSet:p,pixelSize:s}}async function H(e,t,i){const{geometry:n}=t;if("multipoint"===n.type)return O(e,n,i);if("polyline"===n.type)return q(e,n,i);const o=await _(e,{geometry:n},i);if(!o)return null;return y(o)}async function O(e,t,i){const n=await R(e,i),o=t.points.map((e,i)=>t.getPoint(i)).map(t=>C(e,t,i)),a=(await Promise.all(o)).filter(e=>null!=e);if(a.length<=1)return J(a[0]);const s=a[0].map((e,t)=>a.map(e=>e[t]));return y(new r({pixels:s,pixelType:n.pixelType}))}async function C(e,t,i){if("imagery"===e.type){const n=await e.identify(new g({geometry:t,returnCatalogItems:!1}),i).catch(()=>null);return null==n?.value||n.value.includes("NoData")?null:n.value.replaceAll(", "," ").split(" ").map(e=>Number(e))}const n=await e.identify(t,i).catch(()=>null);return n?.value}function J(e){return e?.map(e=>({min:e,max:e,avg:e,median:e,quartile1:e,quartile3:e}))}async function q(e,t,i){const n=await G(e,{geometry:t},i),o=await R(e,i),{bandCount:a,pixelType:s}=o,l=new Array(a).fill(0).map(()=>r.createEmptyBand(s,n.length));let c=0;for(let r=0;r<n.length;r++){const e=n[r];if(null!=e.value){c++;for(let t=0;t<a;t++)l[t][r]=e.value[t]}}c!==n.length&&l.forEach((e,t)=>{l[t]=e.subarray(0,c)});return y(new r({pixels:l,pixelType:s}))}async function E(t,i,n){const o=await R(t,n);if(!o.attributeTable||!o.pixelType.startsWith("u"))return null;const r=o.attributeTable.clone(),a=r.fields.find(e=>"value"===e.name.toLowerCase()),s=r.fields.find(e=>"count"===e.name.toLowerCase());if(!a||!s)throw new e("compute-attribute-table","Value or count field not found in attribute table");const l=2**Number(o.pixelType.slice(1)),c=new Uint32Array(l),{geometry:p}=i;return await D(t,p,(e,t)=>m(e,c),n),r.features.forEach(e=>{const t=e.attributes[a.name];e.attributes[s.name]=c[t]}),r}async function N(e,t,i){const{geometry:n}=t;if("point"===n.type)return C(e,n,i);if("multipoint"===n.type){const t=n.points.map((e,t)=>n.getPoint(t)).map(t=>C(e,t,i)),o=(await Promise.all(t)).filter(e=>null!=e);if(0===o.length)return null;return U(o).map(e=>e/o.length)}const o=await D(e,n,(e,t)=>A(e),i),r=o?.filter(e=>e.count>0);if(!r?.length)return null;const a=U(r.map(e=>e.bandSum)),s=r.map(e=>e.count).reduce((e,t)=>e+t);return a.map(e=>e/s)}function U(e){return e.reduce((e,t)=>e.map((e,i)=>e+t[i]))}function A(e){const{width:t,height:i,pixels:n,mask:o}=e,r=new Array(n.length).fill(0);let a=0;for(let s=0;s<i;s++)for(let e=0;e<t;e++){const i=s*t+e;if(!o||o[i]){for(let e=0;e<n.length;e++)r[e]+=n[e][i];a++}}return{bandSum:r,count:a}}async function G(e,t,i){const n=await D(e,t.geometry,f,i);return n?.flat()??[]}async function D(i,n,o,r){const a=i.spatialReference;if("polyline"===n.type&&!n.spatialReference.equals(a)){const t=(await import("../../../geometry/operators/projectOperator.js")).execute(n,a);if(null==t)throw new e("read-pixels","failed to fetch pixels");n=t}const s="polyline"===n.type?n.extent:n,c=await F(s,a),p="polyline"===n.type?n:c,u=await R(i,r),f={geometry:c,autoResample:!1},m=[],x=I(i,await M(u,f),!0,r);for await(const e of x){if(!e.pixelBlock)continue;const{extent:i}=e,n=o(await l(e.pixelBlock,i,p),i);m.push(n),t(r)}return m}async function W(e,t){const{rasterJobHandler:i}=e,{pixelBlock:n}=e,{statistics:o,histograms:r}=i?await i.computeStatisticsHistograms({pixelBlock:n},t):d(n);return{statistics:o,histograms:r}}async function K(e,t){const{extent:i,fields:n,skipFactor:o,rasterJobHandler:r,pixelIdOffset:a,imageRowSize:s}=e,{pixelBlock:l}=e,c=n.map(({name:e})=>e),p=r?await r.convertPixelBlockToFeatures({pixelBlock:l,extent:i,fieldNames:c,skipFactor:o,pixelIdOffset:a,imageRowSize:s},t):u({pixelBlock:l,extent:i,fieldNames:c,skipFactor:o,pixelIdOffset:a,imageRowSize:s});return p?{fields:n,features:p}:void 0}function L(e){return"_rasterJobHandler"in e?e._rasterJobHandler:null}async function _(e,t,i){const n=await R(e);t={...t,maxPixelCount:t.maxPixelCount??2**28};const o=await M(n,t);v(o,n.pixelType,t.maxPixelCount);const r=[],a=I(e,o,!1,i);for await(const c of a)r.push(c.pixelBlock);if(!r.some(e=>null!=e))return null;const{width:s,height:l}=o,p=Math.ceil(s/b),u=Math.ceil(l/b),f={width:p*b,height:u*b};let m;const x=L(e);if(x){const e=await x.mosaicAndTransform({srcPixelBlocks:r,srcMosaicSize:f,destDimension:f},{...i,transferPixelsToWorker:!0});m=e?.pixelBlock}else m=c(r,f);return m}async function V(t,i,n){if(!i.geometry)throw new e("compute-statistics-histograms","geometry is required to fetch pixel feature set");const o=await _(t,i,n);if(!o)throw new e("compute-statistics-histograms","failed to get intersecting pixels");const r=L(t);return r?await r.computeStatisticsHistograms({pixelBlock:o,includeSkewnessKurtosis:!0},{...n,transferPixelsToWorker:!0}):d(o,{includeSkewnessKurtosis:!0})}export{H as computeBoxStatistics,E as computeRasterAttributeTable,V as computeStatisticsHistograms,T as createPixelFeatureSetCursor,_ as fetchLargePixelBlock,z as fetchPixelFeatureSet,N as identifyAveragePixelValue,G as readIntersectingPixels};
