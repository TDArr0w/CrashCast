/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{result as e}from"../../core/asyncUtils.js";import t from"../../core/Error.js";import{assertIsSome as n}from"../../core/maybe.js";import{whenOrAbort as a,throwIfAbortError as o}from"../../core/promiseUtils.js";import{getMetersPerUnitForSR as i}from"../../core/unitUtils.js";import{initializeProjection as l,project as r}from"../../geometry/projectionUtils.js";import{fromExtent as s}from"../../geometry/support/aaBoundingRect.js";import{GeometryQueryContext as c,ExtentQueryContext as u,isTileInfoTilemapCache as m,getLods as f}from"./ElevationQueryContext.js";import{ElevationTile as p}from"./ElevationTile.js";import{GeometryDescriptor as y}from"./GeometryDescriptor.js";import{TileElevationSampler as w}from"./TileElevationSampler.js";import{TileKey as d}from"./TileKey.js";async function h(e,n,a){if(e=a?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice(),!e.length)throw new t(G,"Elevation queries require at least one elevation layer to fetch tiles from");const o=y.fromGeometry(n),i={...A,...a,returnSampleInfo:!0},l=e.pop(),r=await v(l,o,i),s=await x(e,r,i);return s.geometry=s.geometry.export(),a?.returnSampleInfo||delete s.sampleInfo,s}async function v(e,n,a){if(!e)throw new t(G,"Elevation queries require an elevation layer to fetch tiles from");if(!n||!(n instanceof y)&&"point"!==n.type&&"multipoint"!==n.type&&"polyline"!==n.type)throw new t("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const o={...A,...a},i=new c(e,n.spatialReference,o),l=o.signal;return await e.load({signal:l}),await V(i,n,l),await R(i,l),await L(i,l),k(i),O(i,l)}async function g(e,n,a){if(e=Array.isArray(e)?e:[e],0===(e=a?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice()).length)throw new t(G,"Elevation queries require at least one elevation layer to fetch tiles from");if(!n||"extent"!==n.type)throw new t("elevation-query:invalid-extent","Invalid or undefined extent");const o={...A,...a,returnSampleInfo:!0},i=T(e[e.length-1],n,o);if(1===e.length)return i;return I(e,n,await i,o)}async function T(e,t,n,a){const o=n.signal;await e.load({signal:o});const i=t.spatialReference,s=e.tileInfo.spatialReference;i.equals(s)||(await l([{source:i,dest:s}],{signal:o}),t=r(t,s));const c=new u(e,t,n,a);await R(c,o),await L(c,o);const m=c.elevationTiles,f=c.layer.tileInfo,p=c.parameters.noDataValue;return new w({noDataValue:p,tiles:m,tileInfo:f})}async function I(e,t,n,a){if(e.pop(),!e.length)return n;const o=n.samplers.filter(e=>!e.tile.hasNoDataValues).map(e=>s(e.extent)),i=await T(e[e.length-1],t,a,o);if(0===i.samplers.length)return n;const l=n.samplers.concat(i.samplers),r=a.noDataValue;return I(e,t,new w({samplers:l,noDataValue:r}),a)}async function x(e,t,a){const o=t.geometry.coordinates,i=t.sampleInfo;n(i);const l=new Array,r=new Array;for(let n=0;n<o.length;n++){i[n].demResolution<0&&e.length&&(l.push(o[n]),r.push(n))}const s=e.pop();if(null==s||0===l.length)return t;const c=t.geometry.clone(l),u=await v(s,c,a),m=u.sampleInfo;if(!m)throw new Error("no sampleInfo");return r.forEach((e,t)=>{o[e].z=u.geometry.coordinates[t].z,i[e].demResolution=m[t].demResolution,i[e].source=m[t].source}),x(e,t,a)}async function R(e,n){"geometry"===e.type&&S(e);const a=e.parameters.demResolution;if("number"==typeof a)F(e,a);else if("finest-contiguous"===a)await E(e,n);else{if("auto"!==a)throw new t("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${a}', expected a number, "finest-contiguous" or "auto"`);await q(e,n)}}async function E(e,t){const{tileInfo:n,tilemapCache:a}=e.layer,o=b(n,a,e.parameters.minDemResolution);await D(e,o,t)}async function D(e,n,i){const l=e.layer;if(e.selectTilesAtLOD(n),n<0)return;const r=l.tilemapCache,s=e.getTilesToFetch();try{if(r&&!m(r))await a(Promise.all(s.map(e=>r.fetchAvailability(e.level,e.row,e.col,{signal:i}))),i);else if(await L(e,i),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new t("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(c){o(c),await D(e,n-1,i)}}async function q(t,n){$(t),U(t);const i=t.layer.tilemapCache;if(!i||m(i))return j(t,n);const l=t.getTilesToFetch(),r={},s=l.map(async t=>{const a=new d(0,0,0),l=await e(i.fetchAvailabilityUpsample(t.level,t.row,t.col,a,{signal:n}));!1!==l.ok?null!=t.id&&(r[t.id]=a):o(l.error)});await a(Promise.all(s),n),t.remapTiles(r)}async function j(e,t){const n=e.layer.tileInfo;await L(e,t);let a=!1;e.forEachTileToFetch((e,t)=>{n.upsampleTile(e)?a=!0:t()}),a&&await j(e,t)}function b(e,t,n=0){const a=f(e,t);let o=a.length-1;if(n>0){const t=n/i(e.spatialReference),l=a.findIndex(e=>e.resolution<t);0===l?o=0:l>0&&(o=l-1)}return o}const A={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function V(e,n,a){let o;const i=e.layer.tileInfo.spatialReference;if(n instanceof y?o=await n.project(i,a):(await l([{source:n.spatialReference,dest:i}],{signal:a}),o=r(n,i)),!o)throw new t("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${n.spatialReference.wkid}' on an elevation service in '${i.wkid}'`);e.geometry=y.fromGeometry(o)}function S(e){if(null==e.layer.fullExtent)return;const t=new p(new d(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;const n=e.layer.fullExtent;e.geometry.coordinates.forEach(e=>{const a=e.x,o=e.y;(a<n.xmin||a>n.xmax||o<n.ymin||o>n.ymax)&&(e.elevationTile=t)})}function C(e,t){const{tileInfo:n,tilemapCache:a}=e.layer,o=t/i(n.spatialReference),l=f(n,a);let r=l[0],s=0;for(let i=1;i<l.length;i++){const e=l[i];Math.abs(e.resolution-o)<Math.abs(r.resolution-o)&&(r=e,s=i)}return s}function F(e,t){const n=C(e,t);e.selectTilesAtLOD(n)}function $(e){const{tileInfo:t,tilemapCache:n}=e.layer,a=b(t,n,e.parameters.minDemResolution);e.selectTilesAtLOD(a,e.parameters.maximumAutoTileRequests)}async function L(e,t){const n=e.getTilesToFetch(),o={},i=e.parameters.cache,l=e.parameters.noDataValue,r={noDataValue:l,signal:t},s=n.map(async t=>{if(null==t.id)return;const n=`${e.layer.uid}:${t.id}:${l}`,a=i?.get(n),s=a??await e.layer.fetchTile(t.level,t.row,t.col,r);i?.put(n,s),o[t.id]=new p(t,s)});await a(Promise.allSettled(s),t),e.populateElevationTiles(o)}function U(e){const t=e.layer.tileInfo;let n=0;const a={},o=e=>{null!=e.id&&(e.id in a?a[e.id]++:(a[e.id]=1,n++))},i=e=>{if(null==e.id)return;const t=a[e.id];1===t?(delete a[e.id],n--):a[e.id]=t-1};e.forEachTileToFetch(o,i);let l=!0;for(;l&&(l=!1,e.forEachTileToFetch(a=>{n<=e.parameters.maximumAutoTileRequests||(i(a),t.upsampleTile(a)&&(l=!0),o(a))},i),l););}function k(e){e.geometry.coordinates.forEach(t=>{const n=t.elevationTile;let a=e.parameters.noDataValue;if(n){const e=n.sample(t.x,t.y);null==e?t.elevationTile=null:a=e}t.z=a})}async function O(e,t){const a=await e.geometry.project(e.outSpatialReference,t);n(a);const o={geometry:a.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(o.sampleInfo=z(e)),e.geometry.coordinates.forEach(e=>{e.tile=null,e.elevationTile=null}),o}function z(e){const t=e.layer.tileInfo,n=i(t.spatialReference);return e.geometry.coordinates.map(a=>{let o=-1;if(a.elevationTile&&a.elevationTile!==e.outsideExtentTile){o=t.lodAt(a.elevationTile.key.level).resolution*n}return{demResolution:o,source:-1===o?void 0:e.layer}})}const G="elevation-query:invalid-layer";export{G as InvalidLayerError,g as createSampler,A as defaultOptions,b as getFinestLodIndex,v as query,h as queryAll};
