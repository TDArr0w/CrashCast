/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../geometry/Multipoint.js";import t from"../../geometry/Point.js";import s from"../../geometry/Polyline.js";import{initializeProjection as n,project as o}from"../../geometry/projectionUtils.js";class r{constructor(e){this.geometry=e,this.spatialReference=e.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const t=new r(this.geometry);return t.spatialReference=this.spatialReference,t.coordinates=e??this.coordinates.map(e=>e.clone()),t._exporter=this._exporter,t}async project(t,s){if(this.spatialReference.equals(t))return this.clone();await n([{source:this.spatialReference,dest:t}],{signal:s});const r=new e({spatialReference:this.spatialReference,points:this.coordinates.map(e=>[e.x,e.y])}),i=o(r,t);if(!i)return null;const a=this.coordinates.map((e,t)=>{const s=e.clone(),n=i.points[t];return s.x=n[0],s.y=n[1],s}),c=this.clone(a);return c.spatialReference=t,c}static fromGeometry(n){const o=new r(n);if(n instanceof r)return o.coordinates=n.coordinates.map(e=>e.clone()),o._exporter=(e,t)=>{const s=n.clone(e);return s.spatialReference=t,s},o;switch(n.type){case"point":{const e=n,{hasZ:s,hasM:r}=e;return o.coordinates=s&&r?[new i(e.x,e.y,e.z,e.m)]:s?[new i(e.x,e.y,e.z)]:r?[new i(e.x,e.y,null,e.m)]:[new i(e.x,e.y)],o._exporter=(e,s)=>n.hasM?new t(e[0].x,e[0].y,e[0].z,e[0].m,s):new t(e[0].x,e[0].y,e[0].z,s),o}case"multipoint":{const t=n,{hasZ:s,hasM:r}=t;return o.coordinates=s&&r?t.points.map(e=>new i(e[0],e[1],e[2],e[3])):s?t.points.map(e=>new i(e[0],e[1],e[2])):r?t.points.map(e=>new i(e[0],e[1],null,e[2])):t.points.map(e=>new i(e[0],e[1])),o._exporter=(t,s)=>n.hasM?new e({points:t.map(e=>[e.x,e.y,e.z??0,e.m??0]),hasZ:!0,hasM:!0,spatialReference:s}):new e({points:t.map(e=>[e.x,e.y,e.z??0]),spatialReference:s}),o}case"polyline":{const e=n,t=[],r=[],{hasZ:a,hasM:c}=n;let p=0;for(const s of e.paths)if(r.push([p,p+s.length]),p+=s.length,a&&c)for(const e of s)t.push(new i(e[0],e[1],e[2],e[3]));else if(a)for(const e of s)t.push(new i(e[0],e[1],e[2]));else if(c)for(const e of s)t.push(new i(e[0],e[1],null,e[2]));else for(const e of s)t.push(new i(e[0],e[1]));return o.coordinates=t,o._exporter=(e,t)=>{const o=n.hasM?e.map(e=>[e.x,e.y,e.z??0,e.m??0]):e.map(e=>[e.x,e.y,e.z??0]),i=r.map(e=>o.slice(e[0],e[1]));return new s({paths:i,hasM:n.hasM,hasZ:!0,spatialReference:t})},o}}}}class i{constructor(e,t,s=null,n=null,o=null,r=null){this.x=e,this.y=t,this.z=s,this.m=n,this.tile=o,this.elevationTile=r}clone(){return new i(this.x,this.y,this.z,this.m)}}export{i as Coordinate,r as GeometryDescriptor};
