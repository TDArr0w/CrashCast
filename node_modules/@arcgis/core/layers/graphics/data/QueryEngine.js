/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{indexOf as e,PositionHint as t}from"../../../core/arrayUtils.js";import{toConst as i}from"../../../core/compilerUtils.js";import r from"../../../core/Error.js";import"../../../core/has.js";import{clone as s}from"../../../core/lang.js";import{removeMaybe as a,destroyMaybe as n}from"../../../core/maybe.js";import{signalFromSignalOrOptions as l,throwIfAborted as u}from"../../../core/promiseUtils.js";import{getMetersPerUnitForSR as o}from"../../../core/unitUtils.js";import{isSerializable as c}from"../../../core/support/jsonUtils.js";import{isLoaded as h}from"../../../geometry/projectionUtils.js";import{set as y,negativeInfinity as d,create as m,expandWithAABB as f}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as p,create as x}from"../../../geometry/support/aaBoundingRect.js";import{getBoundsXY as g}from"../../../geometry/support/boundsUtils.js";import{fromJSON as _,isExtent as F,isPolygon as w}from"../../../geometry/support/jsonUtils.js";import{normalizeCentralMeridian as Q}from"../../../geometry/support/normalizeUtils.js";import{equals as S,isValid as R}from"../../../geometry/support/spatialReferenceUtils.js";import{convertFromGeometry as I}from"../featureConversionUtils.js";import{getWhereClause as j}from"./attributeSupport.js";import{cleanFromGeometryEngine as b,getGeometry as E}from"./geometryUtils.js";import{project as T,checkProjectionSupport as A,projectMany as v}from"./projectionSupport.js";import{QueryEngineCache as G}from"./QueryEngineCache.js";import{queryCapabilities as k}from"./QueryEngineCapabilities.js";import{QueryEngineResult as C}from"./QueryEngineResult.js";import{queryEngineEmptyResult as O,normalizeAttributeBinsQuery as M,normalizeQueryLike as P,normalizeQuery as q}from"./queryUtils.js";import{validateAttributeBinsQuery as z,validateQuery as U,validateStatisticsQuery as B}from"./queryValidationUtils.js";import{getSpatialQueryOperator as Z,canQueryWithRBush as H}from"./spatialQuerySupport.js";import{getTimeExtent as N,getTimeOperator as J}from"./timeSupport.js";import L from"../../support/FieldsIndex.js";import{ImmediateTask as V}from"../../../views/support/Scheduler.js";const D="unsupported-query";class K{constructor(e,t=null,i,r,s){this.attributes=e,this.geometry=i,this.centroid=r,this.filterFlags=s,this.groupId=-1,this.displayId=t}}class W{constructor(e){this._changeHandle=null,this.capabilities={query:k},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new G,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,"object-id"===e.featureIdInfo.type&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=c(e.fieldsIndex)?e.fieldsIndex:L.fromJSON(e.fieldsIndex),!e.availableFields||1===e.availableFields.length&&"*"===e.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map(e=>e.name)):this.availableFields=new Set(e.availableFields.map(e=>this.fieldsIndex.get(e)?.name).filter(e=>null!=e)),e.scheduler&&e.priority?this._frameTask=e.scheduler.registerTask(e.priority):this._frameTask=V}destroy(){this._changeHandle=a(this._changeHandle),this._frameTask=a(this._frameTask),this._clearCache(),n(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}async executeQuery(e,t){const i=l(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryFeatureSet(e),i)}async executeQueryForCount(e={},t){const i=l(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForCount(e),i)}async executeQueryForExtent(e,t){const i=l(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForExtent(e),i)}async executeQueryForIds(e,t){return Array.from(await this.executeQueryForIdSet(e,t))}async executeQueryForIdSet(e,t){const i=l(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForIdSet(e),i)}async executeQueryForLatestObservations(e,t){const i=l(t);if(!this.timeInfo?.trackIdField)throw new r(D,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});return await this._frameTask.scheduleGenerator(()=>this._executeQueryForLatestObservations(e),i)}async executeQueryForOpaqueFeatures(e,t){const i=l(t);return(await this._frameTask.scheduleGenerator(()=>this._executeQuery(e,{}),i)).items}async executeAttributeBinsQuery(e,t){const i=l(t);return e=s(e),await this._frameTask.scheduleGenerator(()=>this._executeAttributeBinsQuery(e),i)}async executeQueryForSummaryStatistics(e={},t,i){const r=l(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSummaryStatistics(e,t),r)}async executeQueryForUniqueValues(e={},t,i){const r=l(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForUniqueValues(e,t),r)}async executeQueryForClassBreaks(e={},t,i){const r=l(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForClassBreaks(e,t),r)}async executeQueryForHistogram(e={},t,i){const r=l(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForHistogram(e,t),r)}async executeQueryForSnapping(e,t){const i=l(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSnapping(e,i),i)}async fetchRecomputedExtents(e){const t=l(e);this._timeExtentPromise||=N(this.timeInfo,this.featureStore);const[i,r]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return u(t),{fullExtent:i,timeExtent:r}}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async*_executeQueryFeatureSet(e){try{const t=yield*this._executeQuery(e,{});return yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new C([],e,this).createQueryResponse()}}async*_executeQueryForCount(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null});return yield,t.createQueryResponseForCount()}catch(t){if(t!==O)throw t;return 0}}async*_executeQueryForExtent(e){const t=e.outSR;try{const i=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const r=i.size;if(!r)return{count:0,extent:null};const s=await this._getBounds(i.items,i.spatialReference,t??this.spatialReference);return yield,{count:r,extent:s}}catch(i){if(i===O)return{count:0,extent:null};throw i}}async*_executeQueryForIdSet(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const i=t.items,r=new Set;for(const e of i)r.add(t.featureAdapter.getObjectId(e));return r}catch(t){if(t===O)return new Set;throw t}}async*_executeQueryForLatestObservations(e){try{const t=yield*this._executeQuery(e,{});return yield,this._filterLatest(t),yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new C([],e,this).createQueryResponse()}}async*_executeAttributeBinsQuery(e){let t;try{e=await M(e,this.definitionExpression,this.spatialReference),yield,e=await z(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield,t=yield*this._executeGeometryQuery(e,i),yield,this._executeAggregateIdsQuery(t),yield,this._executeObjectIdsQuery(t),yield,this._executeTimeQuery(t),yield,this._executeAttributesQuery(t),yield}catch(i){if(i!==O)throw i;t=new C([],e,this)}return await t.createQueryBinsResponse(e)}async*_executeQueryForSummaryStatistics(e={},t){const{field:i,normalizationField:r,valueExpression:s}=t,a=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:r,valueExpression:s});return yield,await a.createSummaryStatisticsResponse(t)}async*_executeQueryForUniqueValues(e={},t){const{field:i,field2:r,field3:s,valueExpression:a}=t,n=yield*this._executeQueryForStatistics(e,{field:i,field2:r,field3:s,valueExpression:a});return yield,await n.createUniqueValuesResponse(t)}async*_executeQueryForClassBreaks(e,t){const{field:i,normalizationField:r,valueExpression:s}=t,a=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:r,valueExpression:s});return yield,await a.createClassBreaksResponse(t)}async*_executeQueryForHistogram(e,t){const{field:i,normalizationField:r,valueExpression:s}=t,a=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:r,valueExpression:s});return yield,await a.createHistogramResponse(t)}async*_executeQueryForSnapping(e,t){const{point:i,distance:r,returnEdge:a,vertexMode:n}=e;if(!a&&"none"===n)return{candidates:[]};let l=s(e.query);l=await P(l,this.definitionExpression,this.spatialReference),yield,l=await U(l,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const u=!S(i.spatialReference,this.spatialReference);u&&(await A(i.spatialReference,this.spatialReference),yield);const o="number"==typeof r?r:r.x,c="number"==typeof r?r:r.y,h={xmin:i.x-o,xmax:i.x+o,ymin:i.y-c,ymax:i.y+c,spatialReference:i.spatialReference},y=u?T(h,this.spatialReference):h;if(!y)return{candidates:[]};const d=(await Q(_(i),null,{signal:t}))[0];yield;const m=(await Q(_(y),null,{signal:t}))[0];if(yield,null==d||null==m)return{candidates:[]};const f=await this._searchFeatures(X(m.toJSON()));yield;const p=new C(f,l,this);this._executeObjectIdsQuery(p),yield,this._executeTimeQuery(p),yield,this._executeAttributesQuery(p),yield,yield*this._executeGeometryQueryForSnapping(p),yield;const x=d.toJSON(),g=u?T(x,this.spatialReference):x,F=u?Math.max(y.xmax-y.xmin,y.ymax-y.ymin)/2:r;return p.createSnappingResponse({...e,point:g,distance:F},l.returnZ,i.spatialReference)}async _getBounds(e,t,i){const r=y(m(),d);return await this.featureStore.forEachBounds(e,e=>f(r,e)),Y(r,t,i,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async _getAllFeaturesQueryEngineResult(e){return new C(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(t=>e.push(t)))().then(()=>i(e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async*_executeQuery(e,t){e=s(e),e=await q(e,this.definitionExpression,this.spatialReference),yield,e=await U(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield,e={...e,...t};const i=yield*this._executeSceneFilterQuery(e);yield;const r=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(r),yield,this._executeObjectIdsQuery(r),yield,this._executeTimeQuery(r),yield,this._executeAttributesQuery(r),r}async*_executeSceneFilterQuery(e){if(null==e.sceneFilter)return null;const{outSR:t,returnGeometry:i,returnCentroid:r}=e,s=this.featureStore.featureSpatialReference,a=e.sceneFilter.geometry,n=null==s||S(s,a.spatialReference)?a:T(a,s);if(!n)return null;const l=i||r,u=R(t)&&!S(this.spatialReference,t)&&l?async e=>this._project(e,t):e=>e;yield;const o=this.featureAdapter,c=await this._searchFeatures(X(n));yield;if("disjoint"===e.sceneFilter.spatialRelationship){if(!c.length)return null;const t=new Set;for(const e of c)t.add(o.getObjectId(e));const i=await this._getAllFeatures();yield;const r=await Z("esriSpatialRelDisjoint",n,this.geometryType,this.hasZ,this.hasM);yield;const s=e=>!t.has(o.getObjectId(e))||r(o.getGeometry(e)),a=yield*this._runSpatialFilter(i,s);yield;const l=new C(a,e,this);return await u(l)}if(!c.length)return new C([],e,this);if(this._canExecuteSinglePass(n,e))return await u(new C(c,e,this));const h=await Z("esriSpatialRelContains",n,this.geometryType,this.hasZ,this.hasM);yield;const y=yield*this._runSpatialFilter(c,e=>h(o.getGeometry(e)));return yield,await u(new C(y,e,this))}async*_executeGeometryQuery(i,r){if(null!=r&&0===r.items.length)return r;const{geometry:s,outSR:a,returnGeometry:n,returnCentroid:l}=i,u=r?null:this._getCacheKey(i),o=u?this._cache.get(u):null;if(o)return new C(o,i,this);const c=R(a)&&!S(this.spatialReference,a),h=n||l,y=async e=>(c&&h&&await this._project(e,a),u&&this._cache.put(u,e.items),e),d=this.featureStore.featureSpatialReference,m=!s||null==d||S(d,s.spatialReference)?s:T(s,d);if(!m)return await y(null!=r?r:await this._getAllFeaturesQueryEngineResult(i));yield;const f=this.featureAdapter;let p=await this._searchFeatures(X(s));yield;const x=i.spatialRel??"esriSpatialRelIntersects";if("esriSpatialRelDisjoint"===x){if(!p.length)return await y(null!=r?r:await this._getAllFeaturesQueryEngineResult(i));const e=new Set;for(const i of p)e.add(f.getObjectId(i));let t;null!=r?t=r.items:(yield,t=await this._getAllFeatures(),yield);const s=await Z(x,m,this.geometryType,this.hasZ,this.hasM);yield;const a=t=>!e.has(f.getObjectId(t))||s(f.getGeometry(t)),n=yield*this._runSpatialFilter(t,a);yield;const l=new C(n,i,this);return await y(l)}if(null!=r){const i=new t;p=p.filter(t=>e(r.items,t,r.items.length,i)>=0)}if(!p.length){const e=new C([],i,this);return u&&this._cache.put(u,e.items),e}if(this._canExecuteSinglePass(m,i))return await y(new C(p,i,this));const g=await Z(x,m,this.geometryType,this.hasZ,this.hasM);yield;const _=yield*this._runSpatialFilter(p,e=>g(f.getGeometry(e)));return yield,await y(new C(_,i,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds?.length||null==this.aggregateAdapter)return;const t=new Set;for(const r of e.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(r).forEach(e=>t.add(e))}const i=this.featureAdapter.getObjectId;e.items=e.items.filter(e=>t.has(i(e)))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(e=>t.has(i(e)))}_executeTimeQuery(e){if(0===e.items.length)return;const t=J(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=j(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(e=>t.testFeature(e,this.featureAdapter))}}async*_executeGeometryQueryForSnapping(e){const{query:t}=e,{spatialRel:i}=t;if(!e?.items?.length||!t.geometry||!i)return;const r=await Z(i,t.geometry,this.geometryType,this.hasZ,this.hasM);yield;const s=this.featureAdapter,a=e=>r(s.getGeometry(e)),n=yield*this._runSpatialFilter(e.items,a);e.items=n}*_runSpatialFilter(e,t){if(!t)return e;if(null==this._frameTask)return e.filter(e=>t(e));let i=yield;const r=new Array;for(const s of e)t(s)&&r.push(s),i.madeProgress(),i.done&&(i=yield);return r}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:r}=this.timeInfo,s=r||i,a=new Map,n=this.featureAdapter.getAttribute;for(const l of e.items){const e=n(l,t),i=n(l,s),r=a.get(e);(!r||i>n(r,s))&&a.set(e,l)}e.items=Array.from(a.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:r,returnCentroid:s,outSR:a,resultType:n,cacheHint:l}=e;if("tile"!==n&&!l)return null;const u=r||s;return R(a)&&!S(this.spatialReference,a)&&u?JSON.stringify([t,i,a]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return H(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(e,t){if(!t||S(this.spatialReference,t))return e;const r=this.featureAdapter,s=h()?await this._getFullExtent():void 0,a=await v(e.items.map(e=>E(this.geometryType,this.hasZ,this.hasM,r.getGeometry(e))),this.spatialReference,t,{areaOfInterestExtent:s});return e.items=i(a.map((t,i)=>r.cloneWithGeometry(e.items[i],I(t,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(e=>this.featureStore.forEachInBounds(e,e=>t.add(e))));const i=Array.from(t.values());return t.clear(),i}async*_executeQueryForStatistics(e,t){e=s(e);try{e=await q(e,this.definitionExpression,this.spatialReference),yield,e=await B(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield;const r=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(r),yield,this._executeObjectIdsQuery(r),yield,this._executeTimeQuery(r),yield,this._executeAttributesQuery(r),yield,r}catch(i){if(i!==O)throw i;return new C([],e,this)}}get test(){}}function X(e){if(H(e)){if(F(e))return[p(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if(w(e))return e.rings.map(e=>p(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[g(x(),e)]}function Y(e,t,i,r,s){const a={xmin:e[0],ymin:e[1],xmax:e[3],ymax:e[4],spatialReference:b(r)};s&&isFinite(e[2])&&isFinite(e[5])&&(a.zmin=e[2],a.zmax=e[5],a.hasZ=!0);const n=T(a,t,i);if(n.spatialReference=b(i),n.xmax-n.xmin===0){const e=o(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin===0){const e=o(n.spatialReference);n.ymin-=e,n.ymax+=e}if(s&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin===0){const e=o(n.spatialReference);n.zmin-=e,n.zmax+=e}return n}export{K as Feature,W as QueryEngine,Y as getQueryResultExtent};
