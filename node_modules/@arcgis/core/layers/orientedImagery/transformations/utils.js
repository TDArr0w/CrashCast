/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../../core/Error.js";import{rad2deg as n,deg2rad as a}from"../../../core/mathUtils.js";import{create as e}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{create as i,fromValues as o}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{fromArray as r}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{zeros as c}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{multiply as s,transpose as l}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{invertOrIdentity as f,mul as u}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{a as m,g as h}from"../../../chunks/vec32.js";import{isSerializable as p}from"../../../core/support/jsonUtils.js";import g from"../../../geometry/Point.js";import{projectWithZConversion as v}from"../../../geometry/projectionUtils.js";import{earth as M}from"../../../geometry/support/Ellipsoid.js";import{isWebMercator as d}from"../../../geometry/support/spatialReferenceUtils.js";import{a as x}from"../../../chunks/vec3.js";import{isConstantElevation as w,ConstantElevation as y,isElevationSource as b}from"../core/ElevationSourceDefinitions.js";import{getMetersPerUnitOfSR as j}from"../core/utils.js";import{getElevationSampler as O}from"./updateElevationUtils.js";import{isNumber as z}from"../../../support/guards.js";import{defaultImageSphereSize as F}from"../../../widgets/PanoramicViewer/constants.js";function E(t,n,a){const[e,o,r,c]=n,[s,l,m,h]=a;P(e,o,r,c);const p=P(s,l,m,h),g=R(e,o,r,c),v=R(s,l,m,h),M=f(i(),g),d=u(i(),M,v),[x,w,y,b]=V(t,d);return[x/b,w/b,p?0:y/b]}function P(t,n,a,e){return 0===t[2]&&0===n[2]&&0===a[2]&&0===e[2]&&(t[2]=n[2]=a[2]=e[2]=1,!0)}function S(t){return 0===t?1:t}function V(t,n){const[a,e,i]=t,o=[0,0,0,0];return o[0]=a*n[0]+e*n[1]+i*n[2]+n[3],o[1]=a*n[4]+e*n[5]+i*n[6]+n[7],o[2]=a*n[8]+e*n[9]+i*n[10]+n[11],o[3]=S(a*n[12]+e*n[13]+i*n[14]+n[15]),o}function R(t,n,a,e){const c=N(r([...e,1]),f(new Array(16),o(t[0],n[0],a[0],0,t[1],n[1],a[1],0,t[2],n[2],a[2],0,1,1,1,1))),s=c[0],l=c[1],u=c[2],m=i();return m[0]=s*t[0],m[1]=l*n[0],m[2]=u*a[0],m[3]=0,m[4]=s*t[1],m[5]=l*n[1],m[6]=u*a[1],m[7]=0,m[8]=s*t[2],m[9]=l*n[2],m[10]=u*a[2],m[11]=0,m[12]=s,m[13]=l,m[14]=u,m[15]=1,m}function D(t,n,a,e,i=c()){return i[0]=t[0]+n[0]*a,i[1]=t[1]+n[1]*a,i[2]=t[2]+n[2]*(a/e),i}function H(t,n,a){const e=c();return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*(n/a),e}function L(t,n){const[a,e,i]=t,o=c();return o[0]=a*n[0]+e*n[3]+i*n[6],o[1]=a*n[1]+e*n[4]+i*n[7],o[2]=a*n[2]+e*n[5]+i*n[8],o}function N(t,n){const[a,e,i,o]=t,r=new Array(4);return r[0]=a*n[0]+e*n[1]+i*n[2]+o*n[3],r[1]=a*n[4]+e*n[5]+i*n[6]+o*n[7],r[2]=a*n[8]+e*n[9]+i*n[10]+o*n[11],r[3]=a*n[12]+e*n[13]+i*n[14]+o*n[15],r}function k(n,i,o,r=!0){if(!Number.isFinite(n))throw new t("InvalidRotationAngle","Please specify a valid angle for rotation");const c=o*(r?a(n):n),s=Math.cos(c),l=Math.sin(c),f=e();switch(i){case 0:f[4]=s,f[5]=-l,f[7]=l,f[8]=s;break;case 1:f[0]=s,f[2]=l,f[6]=-l,f[8]=s;break;case 2:f[0]=s,f[1]=-l,f[3]=l,f[4]=s;break;default:throw new t("InvalidRotationAxis","Please specify either 0, 1 or 2 for X, Y or Z axis respectively")}return f}const A={HPR:[[2,-1],[0,1],[2,-1]],OPK:[[0,1],[1,1],[2,1]]};function I(n,a,i=!0){if(3!==n?.length||3!==a?.length)throw new t("InvalidRotationAngles","Please specify three angles with config for rotation");const o=e();for(let t=0;t<3;t++){const[e,r]=a[t],c=k(n[t],e,r,i);s(o,c,o)}return o}function q(t,n=!0){return I(t,A.OPK,n)}function U(t,n=!0){return I(t,A.HPR,n)}function C(t,n,e){const i=Math.sin(a(e)),o=Math.cos(a(e)),r=[[t,0],[t,n],[0,n]];r.forEach((t,n)=>{r[n]=[o*t[0]-i*t[1],i*t[0]+o*t[1]]});const c={xmin:Math.min(0,r[0][0],r[1][0],r[2][0]),xmax:Math.max(0,r[0][0],r[1][0],r[2][0]),ymin:Math.min(0,r[0][1],r[1][1],r[2][1]),ymax:Math.max(0,r[0][1],r[1][1],r[2][1])};return{hfov:Math.abs(c.xmax-c.xmin),vfov:Math.abs(c.ymax-c.ymin)}}function K(t,e){const i=Number(t[0]),o=Number(t[1]),r=Number(t[2]),[c,s,l,f]=e,u=a(c),m=a(s),h=l/Math.sqrt(1-f*Math.sin(u)**2),p=i/h,g=o/h,v=r/h,M=Math.cos(u)-Math.sin(u)*g+Math.cos(u)*v,d=Math.sin(u)+Math.cos(u)*g+Math.sin(u)*v,x=Math.sqrt(M**2+p**2),w=f*h*Math.sin(u),y=(t,n=5)=>{if(0===n)return t;const a=y(t,n-1);return Math.atan(d/x-(w-f*(l/Math.sqrt(1-f*Math.sin(a)**2))*Math.sin(a))/(h*x))},b=y(u),j=Math.atan(i/(h*M))+m,O=n(b);return[n(j),O,i/(Math.cos(b)*Math.sin(j-m))-l/Math.sqrt(1-f*Math.sin(b)**2)]}function T(t,n,a){const e=360/n,i=180/a;return{heading:(t.x-n/2)*e,pitch:90-(t.y-a/2)*i}}function W(t,n,a,e=F/2){const{heading:i,pitch:o}=Y(t,e);return X(i,o,n,a)}function X(t,n,a,e){const i=t%360;return{x:a/2+(i<-180?i+360:i>180?i-360:i)/(360/a),y:e-n/(180/e),heading:t,pitch:n}}function Y(t,a){const e=n(Math.acos(-t.z/a));return{heading:n(Math.atan2(t.x,t.y)),pitch:e}}function Z(t,n,e=F/2){return[e*(Math.sin(a(t))*Math.sin(a(n))),e*(Math.cos(a(t))*Math.sin(a(n))),e*Math.cos(a(180-n))]}function G(t,n,a,e=F/2){const{heading:i,pitch:o}=T(t,n,a);return Z(i,o,e)}async function J(t,a,e){const i=await v(a,t.spatialReference,e);let o=n(Math.atan2(i.y-t.y,i.x-t.x));return o=o>=0&&o<=90?90-o:o>90&&o<=180?360-o+90:90+Math.abs(o),o}function $(t,n,a){const e=Math.cos(a),i=Math.sin(a),o=[1,0,0,1,0,0],r=o[0]*e+o[2]*i,c=o[1]*e+o[3]*i,s=-o[0]*i+o[2]*e,l=-o[1]*i+o[3]*e;o[0]=r,o[1]=c,o[2]=s,o[3]=l;return[t*o[0]+n*o[2]+o[4],t*o[1]+n*o[3]+o[5]]}const B=t=>t.toArray(),Q=(...t)=>t.some(t=>t);function _(t,n){if(Q(0===t.length,t.some(({x:t,y:n})=>Q(null==t,null==n)),!n.hasZ))throw new Error("Input pixels must have x, y and camera location must have z value")}function tt(t,n){if(t.some(t=>null==t.z)||null==n.z)throw new Error("Input points and camera location must have z value")}function nt(t){if(9!==t?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix")}function at(t,n){return d(n)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/M.radius))):1}const et=t=>n=>new g(n,t),it=t=>null!=t&&"queryExtent"in t;function ot(t,n,a,e){return[[-n,-n],[+n,-n],[+n,+n],[-n,+n]].map(([n,i])=>E(x(c(),a,[n,i,0]),e,t))}function rt({a0:t,a1:n,a2:a,b0:e,b1:i,b2:o},r,c,s){const l=[t??r/2-.5,n,a??0,e??c/2-.5,i??0,o].map(ct);return null!=s&&st(l)?{affines:l,focalLength:s}:{affines:[r/2-.5,1,0,c/2-.5,0,-1]}}function ct(t,n){if(null==t)return null;const a=parseFloat(`${t}`);return isNaN(a)?null:a}function st(t){return null!=t[1]&&null!=t[5]}function lt(t,n,a){const{cameraHeight:e,cameraPitch:i,cameraRoll:o,elevation:r,farDistance:c,horizontalFieldOfView:s,location:l,verticalFieldOfView:f}=jt(t,t.location.spatialReference),u=r??(l.z??0)-e;return{...mt(t,n,a),averageElevation:u,cameraPitch:i,cameraRoll:o??0,farDistance:c,horizontalFieldOfView:s,verticalFieldOfView:f}}function ft(t,n,a,e){return wt(e)?q([e.omega,e.phi,e.kappa]):yt(e)?U([e.heading,e.pitch,e.roll]):U([t,n,a??0])}function ut(t,n,a){const{cameraHeading:e,cameraHeight:i,farDistance:o,horizontalFieldOfView:r,location:c,verticalFieldOfView:s}=jt(t,t.location.spatialReference);return{averageElevation:(c.z??0)-i,cameraLocation:c,cameraHeading:e,farDistance:o,horizontalFieldOfView:r,imageHeight:a,imageWidth:n,verticalFieldOfView:s}}function mt(t,n,a){const{a0:e,a1:i,a2:o,b0:r,b1:c,b2:s,cameraHeading:l,cameraOrientation:f,cameraPitch:u,cameraRoll:m,focalLength:h,horizontalFieldOfView:p,location:g,matrix:v,principalX:M,principalY:d,radial:x,tangential:w,verticalFieldOfView:y}=t,{affines:b,focalLength:j}=rt({a0:e,a1:i,a2:o,b0:r,b1:c,b2:s},n,a,h),O=v??ft(l,u,m,f),z=null!=M&&null!=d?[M,d]:void 0;return{affineTransformations:f?.affineTransformations??b,cameraLocation:g.clone(),focalLength:f?.focalLength??j,horizontalFieldOfView:p,imageHeight:a,imageWidth:n,principalOffsetPoint:f?.principalOffsetPoint??z,radialDistortionCoefficients:f?.radialDistortionCoefficients??x,rotationMatrix:O,tangentialDistortionCoefficients:f?.tangentialDistortionCoefficients??w,verticalFieldOfView:y}}const ht=t=>null!=t&&"elevationSample"in t&&null!=t.elevationSample,pt=t=>b(t?.elevationSource)&&null!=t?.extent,gt=t=>w(t?.elevationSource),vt=async(t,n,a,e,i)=>{const o=j(t),r=n-a/o;return gt(e)?(e.elevationSource=new y({constantElevation:e.elevationSource.constantElevation/o}),e):ht(e)?e:pt(e)?{elevationSample:await O({...p(e.elevationSource)?e.elevationSource.toJSON():e.elevationSource,extent:e.extent},i),elevationSource:new y({constantElevation:r})}:{averageGroundElevation:r,spatialReference:t}},Mt=t=>z(t?.heading)&&z(t?.pitch),dt=(t,n)=>[[-t,-n],[t,-n],[t,n],[-t,n]];function xt(t){const{cameraLocation:n,farDistance:i,horizontalFieldOfView:o,rotationMatrix:r,scalingFactor:s,verticalFieldOfView:f}=t,u=e();l(u,r);const p=2*Math.tan(a(f)/2)*i*s,g=2*Math.tan(a(o)/2)*i*s,v=L([0,0,-1],u),M=D([n.x,n.y,n.z],v,t.farDistance*s,s),d=L([0,1,0],u),x=L([1,0,0],u),w=H(d,p/2,s),y=H(x,g/2,s),b=m(c(),w,y),j=h(c(),w,y);return[h(c(),M,b),h(c(),M,j),m(c(),M,b),m(c(),M,j)]}const wt=t=>2===t?.type,yt=t=>1===t?.type;function bt(t,n,a){if("panoramic"===t){const[t,e]=a;return W({x:n.x,y:n.y,z:n.z},t,e)}return{x:n.x+.5,y:.5-n.y}}function jt(t,n,a=!0){const e=j(n),i=a?t.clone():t;return i.cameraHeight/=e,i.farDistance/=e,i.nearDistance/=e,w(i.elevationSource)&&(i.elevationSource.constantElevation/=e),i}export{xt as computeFarplaneVertices,C as computeHFOVAndVFOV,ot as computeNewReferenceCoordinates,Z as convertHeadingPitchToSphereVertex,X as convertOrientationToPixelLocation,G as convertPixelLocationToSphereVertex,T as convertPixelToHeadingPitch,Y as convertSphereVertexToOrientation,W as convertSphereVertexToPixelLocation,jt as convertToSRUnits,I as createRotationMatrix,U as createRotationMatrixFromHPR,q as createRotationMatrixFromOPK,rt as getAffinesAndFocalLength,ut as getImageToWorldPanoramicProperties,lt as getImageToWorldProperties,J as getInitialAngle,vt as getUpdateElevationProps,at as getWebMercatorScalingFactor,mt as getWorldToImageProperties,Mt as hasAngles,yt as hasHeadingPitchRoll,wt as hasOmegaPhiKappa,it as isElevationSampler,ht as isUpdateElevationWithElevationSampler,pt as isUpdateElevationWithElevationSource,gt as isUpdateUsingConstantElevation,st as isValidAffines,R as linearEquationSolve,K as ltpToGeographic,Q as or,B as pointToArray,E as projectiveTransform,dt as reducerFn,$ as rotatePixel,D as scaleAndAddWithFactor,H as scaleWithFactor,bt as transformGraphicCoordinatesToPixel,L as transformMat3,N as transformMat4,_ as validatePixelsToTransform,tt as validatePointsToTransform,nt as validateRotationMatrix,et as vecToPoint};
