/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{throwIfAborted as e}from"../../../core/promiseUtils.js";import{create as t}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{transpose as n}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{a as o,g as a}from"../../../chunks/vec32.js";import i from"../../../geometry/Circle.js";import s from"../../../geometry/Mesh.js";import c from"../../../geometry/Multipoint.js";import f from"../../../geometry/Polygon.js";import{projectWithZConversion as l}from"../../../geometry/projectionUtils.js";import m from"../../../geometry/SpatialReference.js";import{polygonCentroidPoint as u}from"../../../geometry/support/centroid.js";import{earth as p}from"../../../geometry/support/Ellipsoid.js";import h from"../../../geometry/support/MeshComponent.js";import{MeshVertexAttributes as y}from"../../../geometry/support/MeshVertexAttributes.js";import{create as g,fromArray as x,intersectRay as d}from"../../../geometry/support/plane.js";import{isWebMercator as w}from"../../../geometry/support/spatialReferenceUtils.js";import{convertToSRUnits as M,getWebMercatorScalingFactor as R,createRotationMatrixFromHPR as j,transformMat3 as v,scaleAndAddWithFactor as P,scaleWithFactor as D,computeHFOVAndVFOV as b,projectiveTransform as A}from"../transformations/utils.js";const I=Math.PI/180;function z(e){const t=M(e,e.geometry.spatialReference);return e.isSpherical?S(t):V(t)}function V(e){const{horizontalFieldOfView:t,verticalFieldOfView:r,geometry:n,cameraHeading:o}=e,a=R(n.y,n.spatialReference);let i=e.cameraPitch,s=e.cameraRoll??0,c=150;t>150&&(i=90,s=0,c=5);const l=Math.ceil(t/c),m=F(l,o,t);let u=e.farDistance?e.farDistance*a:e.cameraHeight*a/Math.cos(i*I);e.cameraPitch+r/2>=90&&(u=(e.farDistance||20)*a);const p=new f({spatialReference:n?.spatialReference});p.imageID=e.objectId;let h=null;for(const f of m)h=H(f,i,e.cameraHeight,n,u,a,r,t,l,p,s,e.nearDistance);return h.imageID=e.objectId,{polygon:p,frustum:h}}function F(e,t,r){const n=[];if(e%2==0)for(let o=0;o<e/2;o++)n.push(t-r/e*(o+.5),t+r/e*(o+.5));else{n.push(t);for(let o=1;o<e/2;o++)n.push(t-r/e*o,t+r/e*o)}return n.sort(),n}function H(e,i,s,c,f,l,m,u,p,h,y=0,g=0){const x=n(t(),j([e,i,y??0])),d=U({cameraHeight:s,cameraPitch:i,farDistance:f,location:c,horizontalFieldOfView:u,nearDistance:g,verticalFieldOfView:m},x),w=v([0,0,-1],x),{x:M,y:R}=c,b=P([M,R,s],w,f,l),A=2*Math.tan(m*I/2)*f,z=2*Math.tan(u/p*I/2)*f,V=v([0,1,0],x),F=v([1,0,0],x),H=D(V,A/2,l),S=D(F,z/2,l),q=o(r(),H,S),C=a(r(),H,S),E=O([a(r(),b,q),a(r(),b,C),o(r(),b,q),o(r(),b,C)],s,c,l);return E.push(E[0]),h.addRing(E),d}function O(e,t,r,n){return e.map(e=>E(e,t,r,n))}function S(e){const{geometry:t,farDistance:r,objectId:n,nearDistance:o,cameraHeight:a}=e,c=R(t.y,t.spatialReference),f=new i({center:t.clone(),radius:r*c});if(f.imageID=n,o){const e=new i({center:t.clone(),radius:o*c});f.addRing(e.rings[0])}const l=t.clone();l.z=a-r*c;const m=s.createSphere(l,{size:2*r*c});return m.imageID=n,{polygon:f,frustum:m}}function q(e,t){return e.contains(t)}function C(e,t){return Math.sign(e)!==Math.sign(t)}function U(e,t,n){const{cameraHeight:i,cameraPitch:c,farDistance:f,location:l,horizontalFieldOfView:m,nearDistance:u,verticalFieldOfView:p}=e,h=L(l),g=c+p/2>=90==!1,x=2*Math.tan(p*I/2)*u,d=2*Math.tan(m*I/2)*u,w=2*Math.tan(p*I/2)*f,M=2*Math.tan(m*I/2)*f;let R,j;j=[0,0,-1],j=v(j,t),R=P([l.x,l.y,i],j,f,h),g&&(R[2]=0);const b=P([l.x,l.y,i],j,u,h);let A=[0,1,0];A=v(A,t);let z=[1,0,0];z=v(z,t);let V=[],F=[];u?(F=[{faces:[4,0,3,4,7,3]},{faces:[5,1,2,5,6,2]},{faces:[4,0,1,4,5,1]},{faces:[6,2,3,6,7,3]}],V=V.concat(a(r(),b,o(r(),D(A,x/2,h),D(z,d/2,h)))),V=V.concat(a(r(),b,a(r(),D(A,x/2,h),D(z,d/2,h)))),V=V.concat(o(r(),b,o(r(),D(A,x/2,h),D(z,d/2,h)))),V=V.concat(o(r(),b,a(r(),D(A,x/2,h),D(z,d/2,h))))):(V=[l.x,l.y,i],F=[{faces:[0,1,2,0,2,3,0,3,4,0,4,1]}]),V=V.concat(a(r(),R,o(r(),D(A,w/2,h),D(z,M/2,h)))),V=V.concat(a(r(),R,a(r(),D(A,w/2,h),D(z,M/2,h)))),V=V.concat(o(r(),R,o(r(),D(A,w/2,h),D(z,M/2,h)))),V=V.concat(o(r(),R,a(r(),D(A,w/2,h),D(z,M/2,h))));const H=new y({position:Float64Array.from(V)});return new s({vertexAttributes:H,components:F,spatialReference:l.spatialReference})}function E(e,t,n,a){{const i=Math.sqrt((e[2]-t)**2+(Math.sqrt((e[0]-n.x)**2+(e[1]-n.y)**2)/a)**2)*a,s=D(o(r(),[e[0],e[1],e[2]],[n.x,n.y,t]),1/i,1/a),c=t/(t-e[2]),f={x:(1-c)*n.x+c*e[0],y:(1-c)*n.y+c*e[1],z:(1-c)*t+c*e[2]},l=Math.sqrt((f.z-t)**2+(Math.sqrt((f.x-n.x)**2+(f.y-n.y)**2)/a)**2)*a,m=D(o(r(),[f.x,f.y,f.z],[n.x,n.y,t]),1/l,1/a);return C(s[0],m[0])&&C(s[1],m[1])&&C(s[2],m[2])||e[2]>=0?[e[0],e[1],0]:[f.x,f.y,f.z]}}function k(e){const{spatialReference:t,x:r,y:n}=e.geometry,{cameraHeading:o,cameraPitch:a,farDistance:i,nearDistance:s}=e,c=L(e.geometry),l=new f({spatialReference:t}),m=Math.abs(1.44*i*c);let u=Math.abs(1.44*s*c);(a<20||null==o)&&(u=m);const p=[];return p[0]={x:r+m*Math.sin((o-45)*I),y:n+m*Math.cos((o-45)*I)},p[1]={x:r+m*Math.sin((o+45)*I),y:n+m*Math.cos((o+45)*I)},p[2]={x:r+u*Math.sin((o+135)*I),y:n+u*Math.cos((o+135)*I)},p[3]={x:r+u*Math.sin((o+225)*I),y:n+u*Math.cos((o+225)*I)},l.addRing([[p[0].x,p[0].y,0],[p[1].x,p[1].y,0],[p[2].x,p[2].y,0],[p[3].x,p[3].y,0],[p[0].x,p[0].y,0]]),l}function L(e){return e&&w(e?.spatialReference)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*e.y/p.radius))):1}function W(e,t){const n=1+t/100;if("esri.geometry.Circle"===e.declaredClass){const{radius:t,center:r}=e,o=new i({radius:t*n,center:r});return e.rings.length>1&&o.addRing(e.rings[1]),o}if("esri.geometry.Polygon"===e.declaredClass){const t=new f({spatialReference:e.spatialReference}),a=u(e);if(a){const i=[];for(let t=0;t<e.rings[0].length;t++){const s=Math.sqrt((a.x-e.rings[0][t][0])**2+(a.y-e.rings[0][t][1])**2),c=D(o(r(),[e.rings[0][t][0],e.rings[0][t][1],0],[a.x,a.y,0]),1/s,1),f=P([a.x,a.y,0],c,s*n,1);i.push({x:f[0],y:f[1]})}t.addRing([[i[0].x,i[0].y,0],[i[1].x,i[1].y,0],[i[2].x,i[2].y,0],[i[3].x,i[3].y,0],[i[0].x,i[0].y,0]])}return t}return e}async function B(e,t,r){const{cameraHeight:n,cameraLocation:o,cameraPitch:a,frustumVertices:i,horizontalFieldOfView:s,imageHeight:c,imageWidth:f,inSRS:l,outSRS:u,verticalFieldOfView:p,cameraRoll:h,options:y}=r,g=new m(l),x=new m(u),d=b(s,p,h??0),w=i.length>15;return a+d.vfov/2>=90?await Q(i,e,f,c,g,x,w,y):await G(i,e,t,o,n,w,g,x,y)}async function G(e,t,r,n,o,a,i,c,f){const l=J(e,t,r,n,o);if(!l)return;const{farPlane:m,nearPlane:u}=l,p=await T([...u?.vertexPositions??e.slice(0,3),...m.vertexPositions],i,c,f),h=_(p);return new s({vertexAttributes:new y({position:p}),components:$(a?Y(h,!0):Z(h,!0)),spatialReference:c})}function J(e,t,r,n,o){const a=X(e),i=X(e,"near");if(!a)return;const s=t.length;for(let c=0;c<s;c++){const e=Array.from(r[c]),t=[e[0]-n[0],e[1]-n[1],e[2]-(n[2]??o)];N(n,t,c,i),K(n,t,c,a)}return{farPlane:a,nearPlane:i}}function K(e,t,n,o){const{coefficients:a,vertexPositions:i}=o,s=r();d(a,{origin:e,direction:t},s)&&i.splice(3*n,3,...s)}function N(e,t,n,o){if(!o)return;const a=r();d(o.coefficients,{origin:e,direction:t},a)&&o.vertexPositions.splice(3*n,3,...a)}async function Q(e,t,r,n,o,a,i,c){let f,l=i?new Array:[e[0],e[1],e[2]],m=new Array;for(const s of t)i?(f=A([s[0],s[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[0],e[1],e[2]],[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]]]),l=l.concat(...f),f=A([s[0],s[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[12],e[13],e[14]],[e[15],e[16],e[17]],[e[18],e[19],e[20]],[e[21],e[22],e[23]]]),m=m.concat(...f)):(f=A([s[0],s[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]],[e[12],e[13],e[14]]]),l=l.concat(...f));l=l.concat(m);const u=await T(l,o,a,c),p=_(u);return new s({vertexAttributes:new y({position:u}),components:$(i?Y(p,!0):Z(p,!0)),spatialReference:a})}async function T(t,r,n,o){if(r.equals(n))return t;const a=t.reduce((e,t,r)=>{const n=Math.floor(r/3);return e[n]||(e[n]=new Array),e[n].push(t),e},new Array),{points:i}=await l(new c({points:a,spatialReference:r}),n,o);return e(o),i.flat()}function X(e,t="far"){const r=g();let n;switch(t){case"far":if(n=Array.from(15===e.length?e.slice(3):e.slice(12)),x(r,n,!1))return{coefficients:r,vertexPositions:n};break;case"near":if(n=Array.from(e.slice(0,12)),15===e.length||!x(r,n,!1))return;return{coefficients:r,vertexPositions:n}}}const Y=(e,t=!1)=>{if(t&&e-2<=4||e<=4||e%2!=0)throw new Error("Invalid number of vertices");const r=[],n=e/2,o=Math.round((t?e-2:e)/2);for(let a=0;a<o;a++){const o=a+n,i=t?o+1:o,s=i%e,c=(t?o:i+1)%e;r.push({faces:new Uint32Array([a,c,s,a,a+1,s])})}return r};function Z(e,t=!1){if(e<3||t&&e-1<3)throw new Error("Invalid number of vertices");const r=[],n=t?e-2:e-1;for(let o=0;o<n;o++)r.push({faces:new Uint32Array([0,o+1,o+2])});return r}const $=e=>e.map(e=>new h(e)),_=e=>e.length/3;export{q as checkIfPolygonContainsSelectedPoint,k as computePolygonForInspection,z as createCoveragePolygon,O as limitZToGround,T as projectVertices,W as resizePolygon,B as updateFrustum};
