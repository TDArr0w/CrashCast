/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{resolveTimeZone as i}from"../../../../intl/date.js";import{isTimeOnlyField as n,isDateField as t,isTimestampOffsetField as a,isDateOnlyField as r}from"../../../../layers/support/fieldUtils.js";import o from"../../../../rest/support/AttributeBinsQuery.js";import l from"../../../../rest/support/AutoIntervalBinParameters.js";import s from"../../../../rest/support/DateBinParameters.js";import m from"../../../../rest/support/FixedBoundariesBinParameters.js";import u from"../../../../rest/support/FixedIntervalBinParameters.js";import d from"../../../../rest/support/GenerateRendererParameters.js";import p from"../../../../rest/support/StatisticDefinition.js";import{getSQLFilterForNormalization as f,mergeWhereClauses as c,getRangeExpr as y}from"../../../statistics/support/utils.js";import{isAnyDateField as z}from"../../utils.js";import{getSQLExpressionForDateOrTimeField as x,getFieldExpr as v,updateQueryWithFeatureFilter as w,defaultNumBins as T,generateBinParams as h,getViewInfoParams as F}from"./utils.js";import{createClassBreaksDefinition as B}from"../../../../statistics/utils.js";const V="countOFExpr",j="lowerBoundary",E="upperBoundary";function q(e,i,t){const a=e.valueExpression||e.sqlExpression,r=e.signal;if(!a){const{field:a,normalizationType:o,normalizationField:l}=e,s=a?i.getField(a):null,m=z(s)||n(s),u={field:a,normalizationType:o,normalizationField:l,normalizationTotal:t,layer:i};return{sqlExpression:m?x(i,s):v(u),sqlWhere:m?null:e.sqlWhere||f({field:a,normalizationType:o,normalizationField:l}),filter:e.filter,signal:r}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,filter:e.filter,signal:r}}async function I(e,i,n){const{field:t,normalizationType:a,normalizationField:r,signal:o}=e,l=f({field:t,normalizationType:a,normalizationField:r}),s=new d({classificationDefinition:B({field:t,normalizationType:a,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numBins||T}),where:c(l,n)});return i.generateRenderer(s,o).then(e=>{const{normalizationTotal:n,classBreaks:o}=e;return h({field:t,normalizationType:a,normalizationField:r,normalizationTotal:n,classBreaks:o,where:l,layer:i})})}async function M(i,t,a,o,d){const{field:p,sqlExpression:f,normalizationField:c,classificationMethod:z,normalizationType:x}=i,w=p?t.getField(p):null,h=n(w),F=r(w)||h,B=i.numBins||T;if(F){if(x||z)throw new e(`${t.adapterName}:not-supported`,"NormalizationType and classificationMethod are not supported for date-only and time-only fields");const i=(o-a)/B/1e3,n=i/86400;return new s({field:p,expression:f,interval:{unit:h?"seconds":"days",value:Math.ceil(h?i:n)},start:a,end:o})}if("defined-interval"===z)return new u({field:p,expression:f,normalizationField:c,normalizationTotal:d,normalizationType:x,interval:i.definedInterval??Math.ceil((o-a)/B),start:x?null:a,end:x?null:o,normalizationMinValue:x?a:null,normalizationMaxValue:x?o:null});if("manual"===z)throw new e(`${t.adapterName}:not-supported`,"Layer does not support manual classificationMethod");if("natural-breaks"===z||"quantile"===z||"standard-deviation"===z){const n=v({field:p,normalizationField:c,normalizationTotal:d,normalizationType:x,layer:t}),r=null!==i.minValue&&null!==i.maxValue?y(n,i.minValue,i.maxValue):void 0,o=await I(i,t,r);if(!o.intervals)throw new e(`${t.adapterName}:invalid`,"Invalid intervals returned from generate renderer");const l=[a,...o.intervals.map(e=>e[1])];return new m({field:x?null:p,expression:x?n:f,boundaries:l})}return new l({field:p,normalizationField:c,normalizationTotal:d,normalizationType:x,expression:f,numBins:B,start:x?null:a,end:x?null:o,normalizationMinValue:x?a:null,normalizationMaxValue:x?o:null})}function g(e,i,n,t){return null!=n&&null!=t?Promise.resolve({min:n,max:t}):i.summaryStatistics({...e,outStatisticTypes:{include:["min","max"]}}).then(e=>({min:e.min,max:e.max}))}async function b(e,n,r,l){const{field:s,minValue:m,maxValue:u,filter:d,view:f}=e,y=s?n.getField(s):null,z=t(y)||a(y),x=q(e,n,r),{min:v,max:T}=await g(x,n,m,u);if(null==v||null==T)return{query:null,min:v,max:T};const h=new p({statisticType:"count",outStatisticFieldName:V,onStatisticField:"1"}),{where:F,timeExtent:B}=l||{},j=c(F,x.sqlWhere),E="lowerBoundary",I="upperBoundary",b=new o({binParameters:await M(e,n,v,T,r),outStatistics:[h],binOrder:e.sortOrder,where:j,timeExtent:B,lowerBoundaryAlias:E,upperBoundaryAlias:I,outTimeZone:f?.timeZone&&z?i(f.timeZone):null});return w(b,d),{query:b,min:v,max:T}}function D(e,i=!1){if("string"!=typeof e)return e;return(i?new Date(`1970-01-01T${e}Z`):new Date(e)).getTime()}function P(e,i,t){const a=n(i);return{...t,bins:e.features.map(e=>({minValue:D(e.attributes[j],a),maxValue:D(e.attributes[E],a),count:e.attributes[V]}))}}function S(e,i,n){const{valueExpression:t,view:a}=e,{featuresJSON:r,graphics:o,fieldInfos:l}=i,s={field:e.field,valueExpression:t,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:n,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return t&&a&&(r||o)&&(s.viewInfoParams=F(a),s.timeZone=a.timeZone,s.fieldInfos=l),s}export{I as binParamsFromGenRend,D as formatHistogramBinValue,b as getAttributeBinsQuery,g as getDataRange,S as getHistogramAttributeDefinition,q as getQueryParamsForExpr,P as processQueryAttributeBinsResult};
