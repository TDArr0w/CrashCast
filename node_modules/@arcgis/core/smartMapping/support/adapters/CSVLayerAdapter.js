/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../core/Error.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import{createGenerateRendererClassBreaks as s,createGenerateRendererUniqueValues as o}from"../../../rest/support/generateRendererUtils.js";import{getDataValues as a,mergeWhereClauses as n}from"../../statistics/support/utils.js";import{WorkerClient as l}from"../../statistics/support/WorkerClient.js";import{getFieldsList as p}from"../utils.js";import c from"./FeatureLayerAdapter.js";import{ensureFeaturesJSON as m}from"./support/utils.js";let u=class extends c{constructor(){super(...arguments),this.adapterName="csv-layer-adapter"}async _createGenerateRendererResult(e,r,i,n,l){const p=e?.features,c=p?.length;if(!c)throw new t("csv-layer-adapter:insufficient-data","No features are available to calculate statistics");const u=m(p);let d=null;if("percent-of-total"===n){if(d=(await this.workerClient.summaryStatistics({field:r},u)).sum,null==d)throw new t("csv-layer-adapter:invalid","invalid normalizationTotal")}if("class-breaks-definition"===l?.type){const e=(await a({field:r,normalizationType:n,normalizationField:i,normalizationTotal:d},u)).filter(e=>Number.isFinite(e));return s({definition:l,values:e,normalizationTotal:d})}const f=(await a({field:r},u)).filter(e=>null!=e&&"string"==typeof e&&""!==e.trim());return o(f)}generateRenderer(e,t){const r=e.classificationDefinition;let i=null,s=null,o=null;"class-breaks-definition"===r?.type?(i=r.classificationField,s=r.normalizationField,o=r.normalizationType):i=r?.attributeField;const a=this.layer;return p({field:i,normalizationField:s}).then(l=>{const p=a.createQuery();return p.returnGeometry=!1,p.outFields=l,p.where=n(p.where,e.where),a.queryFeatures(p,{signal:t}).then(e=>this._createGenerateRendererResult(e,i,s,o,r))})}load(e){const t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=l.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};e([r({readOnly:!0})],u.prototype,"adapterName",void 0),u=e([i("esri.smartMapping.support.adapters.CSVLayerAdapter")],u);export{u as default};
