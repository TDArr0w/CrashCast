/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{toPt as r}from"../../core/screenUtils.js";import{ensureClass as n}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as a}from"../../intl/messages.js";import s from"../../renderers/ClassBreaksRenderer.js";import l from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoSizeStop.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as u}from"../../renderers/support/utils.js";import m from"../../renderers/visualVariables/SizeVariable.js";import{castSizeFromStringOrNumber as p}from"../../renderers/visualVariables/support/castSizeVariable.js";import d from"../../renderers/visualVariables/support/SizeStop.js";import c from"../../renderers/visualVariables/support/SizeVariableLegendOptions.js";import f from"../heuristics/ageUnit.js";import y from"../heuristics/outline.js";import z from"../heuristics/referenceSize.js";import v from"../heuristics/sizeRange.js";import{getTypeSchemeData as w}from"./type.js";import{createPrimitiveOverrides as h,updateReferenceSizeSymbol as b,createReferenceSizeSymbol as g}from"./support/referenceSizeUtils.js";import{isSizeVV as S,getAuthoringInfoVisualVariable as x,spliceVisualVariables as E,updateAuthoringInfoVisualVariable as V,processRegenerateParams as T,getRendererToUpdate as k,getStyleType as O,hasScaleDependentSizeVV as I,hasOutlineVV as B,findSizeVVIndex as F,findOutlineVVIndex as R}from"./support/regenerateUtils.js";import{createPrimitiveOverrides as j,updateSpikeSymbol as q,createSpikeSymbol as D,defaultSpikeSymbolStyle as G}from"./support/spikeUtils.js";import{getSummaryStatistics as U,errorCallback as P,getClassBreaks as M,getTitleAndExpressionForAgeRenderer as C,updateAgeRendererAuthoringInfoVV as W,verifyBasicFieldValidity as $,getSizeRangeForAxis as A,getDataRange as H,createSymbol as L,getSymbolOutlineFromScheme as J,getSymbolSizeFromScheme as K,getBasemapInfo as N}from"./support/utils.js";import{verifyDates as Q,supportedAgeUnits as X}from"../statistics/support/ageUtils.js";import{verifyBinningParams as Y}from"../support/binningUtils.js";import{getFieldsList as Z,isAnyDateField as _,getNormalizationType as ee}from"../support/utils.js";import{binningCapableLayerTypes as ie,featureCapableLayerTypes as re,createLayerAdapter as ne,getLayerTypeLabels as ae}from"../support/adapters/support/layerUtils.js";import{cloneScheme as se,getSchemes as le}from"../symbology/size.js";import{getColorFromSymbol as te}from"../../symbols/support/utils.js";const oe=2**53-1,ue=[5,112.5];async function me(e,r){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if("reference-size"===e.theme&&!e.view&&!e.field)throw new i("size-visual-variable:missing-parameters","'view' and 'field' are required when 'theme' is 'reference-size'");if("reference-size"===e.theme&&e.valueExpression)throw new i("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'theme' is 'reference-size'");e.forBinning&&Y(e,"size-visual-variable");const n={...e},a=e.forBinning?ie:re,s=ne(n.layer,a,e.forBinning);if(!s)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+ae(a).join(", "));"height"===n.axis&&(n.sizeOptimizationEnabled=!1);const l=null!=n.signal?{signal:n.signal}:null;await s.load(l);const t=s.geometryType;if("mesh"===t)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(n.worldScale){if("polyline"===t||"polygon"===t)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!n.view||"3d"!==n.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if("reference-size"===n.theme&&!e.forBinning&&"polygon"!==t)throw new i("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");if("spike"===n.theme&&!e.forBinning&&"polygon"!==t&&"point"!==t)throw new i("size-visual-variable:invalid-parameters","Spike is only supported for point and polygon layers");const o=await Z({field:n.field,normalizationField:n.normalizationField,valueExpression:n.valueExpression}),u=$(s,o,"size-visual-variable:invalid-parameters");if(u)throw u;"spike"!==n.theme||n.spikeOptions?.symbolStyle||(n.spikeOptions??={},n.spikeOptions.symbolStyle=G);const m={...n,layer:s,referenceSizeResult:r};return await de(m),m}async function pe(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&Y(e,"size-continuous-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0;const n=e.forBinning?ie:re,a=ne(r.layer,n,e.forBinning);if(!a)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ae(n).join(", "));const s=null!=r.signal?{signal:r.signal}:null;await a.load(s);const l=a.geometryType,t=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="reference-size"!==r.theme&&"spike"!==r.theme&&"polygon"===l&&r.outlineOptimizationEnabled,"mesh"===l)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if("reference-size"===r.theme&&!e.forBinning&&"polygon"!==l)throw new i("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");if("spike"===r.theme&&!e.forBinning&&"polygon"!==l&&"point"!==l)throw new i("size-continuous-renderer:invalid-parameters","Spike is only supported for point and polygon layers");const o=await Z({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),u=$(a,o,"size-continuous-renderer:invalid-parameters");if(u)throw u;"spike"!==r.theme||r.spikeOptions?.symbolStyle||(r.spikeOptions??={},r.spikeOptions.symbolStyle=G);const m={...r,layer:a};return await de(m),m}async function de(e){const i=e.layer,r=i.geometryType,n=i.layer,a=e.forBinning&&"featureReduction"in n&&"binning"===n.featureReduction?.type;if(("polygon"===r||a)&&e.view&&e.field&&!e.valueExpression&&(!e.theme||"reference-size"===e.theme)){try{e.referenceSizeResult=e.referenceSizeResult??await z({layer:n,view:e.view,filter:e.filter,forBinning:e.forBinning,signal:e.signal})}catch{}!e.theme&&e.referenceSizeResult?.isGrid&&(e.theme="reference-size"),e.referenceSizeOptions?.symbolStyle||(e.referenceSizeOptions?e.referenceSizeOptions.symbolStyle="circle":e.referenceSizeOptions={symbolStyle:"circle"})}}async function ce(e){if(!e||!(e.layer&&e.view&&e.sizeStops))throw new i("update-renderer-with-reference-size:missing-parameters","'layer', 'view and 'sizeStops' parameters are required");const{view:r,forBinning:n}=e,a=e.forBinning?ie:re,s=ne(e.layer,a,e.forBinning);if(!s)throw new i("update-renderer-with-reference-size:invalid-parameters","'layer' must be one of these types: "+ae(a).join(", "));const l=s.layer;let t=e.renderer;if(!t)if(e.forBinning){if(!("featureReduction"in l&&l.featureReduction&&"renderer"in l.featureReduction&&l.featureReduction.renderer)||"class-breaks"!==l.featureReduction.renderer.type&&"unique-value"!==l.featureReduction.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");t=l.featureReduction.renderer}else{if(!("renderer"in l)||!l.renderer||"class-breaks"!==l.renderer.type&&"unique-value"!==l.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");t=l.renderer}const o=t.authoringInfo;if(!o||!o?.visualVariables?.some(e=>"reference-size"===e.theme))throw new i("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'reference-size'");const u=e.isGrid??(await z({view:r,layer:l,forBinning:n}))?.isGrid;return{...e,isGrid:u,renderer:t,layer:s}}async function fe(e){if(!e||!e.layer||!e.sizeStops)throw new i("update-renderer-with-spike:missing-parameters","'layer' and 'sizeStops' parameters are required");const r=e.forBinning?ie:re,n=ne(e.layer,r,e.forBinning);if(!n)throw new i("update-renderer-with-spike:invalid-parameters","'layer' must be one of these types: "+ae(r).join(", "));await n.load();const a=n.layer;let s=e.renderer;if(!s)if(e.forBinning){if(!("featureReduction"in a&&a.featureReduction&&"renderer"in a.featureReduction&&a.featureReduction.renderer)||"class-breaks"!==a.featureReduction.renderer.type&&"unique-value"!==a.featureReduction.renderer.type)throw new i("update-renderer-with-spike:invalid-parameters","Feature reduction renderer is not supported");s=a.featureReduction.renderer}else{if(!("renderer"in a)||!a.renderer||"class-breaks"!==a.renderer.type&&"unique-value"!==a.renderer.type)throw new i("update-renderer-with-spike:invalid-parameters","Renderer is not supported");s=a.renderer}const l=s.authoringInfo,t=l?.visualVariables.find(e=>"spike"===e.theme);if(!t)throw new i("update-renderer-with-spike:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'spike'");const o=e.spikeOptions??{};return o.symbolStyle??=t?.spikeSymbolStyle?void 0:G,{...e,renderer:s,layer:n,spikeOptions:o}}async function ye(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&Y(e,"size-class-breaks-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0,r.classificationMethod??="equal-interval",r.normalizationType=ee(r);const n=e.forBinning?ie:re,a=ne(r.layer,n,e.forBinning);if(!a)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+ae(n).join(", "));if(!(null!=r.minValue&&null!=r.maxValue)&&(null!=r.minValue||null!=r.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=r.signal?{signal:r.signal}:null;await a.load(s);const l=a.geometryType,t=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="polygon"===l&&r.outlineOptimizationEnabled,"mesh"===l)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=await Z({field:r.field,normalizationField:r.normalizationField}),u=$(a,o,"size-class-breaks-renderer:invalid-parameters");if(u)throw u;return{...r,layer:a}}function ze(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const r=i;return r.analyzeData=!(null!=i.minValue&&null!=i.maxValue),r}function ve(e){const i={...e},r=!!i.symbolType?.includes("3d-volumetric"),n=i;return n.worldScale=r,r&&(n.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,n}async function we(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const r={...e};r.symbolType??="2d",r.defaultSymbolEnabled??=!0;const n=ne(r.layer,re);if(!n)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+ae(re).join(", "));const a=null!=r.signal?{signal:r.signal}:null;await n.load(a);const s=n.geometryType,l=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="polygon"===s&&r.outlineOptimizationEnabled,"mesh"===s)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=Q(n,r.startTime,r.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(r.unit&&!X.includes(r.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${X.join(", ")}`);return{...r,layer:n}}async function he(e){const r="regenerate-size-visual-variables";T(e,r);const n=await k(e),a=O(n);if(!a||!["size-continuous","univariate-color-size","color-size","relationship-size","type-size"].includes(a))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const s=x(n,"size");if(!s)throw new i(`${r}:invalid-parameters`,"Renderer does not have a size visual variable authoringInfo");const l=s.theme,t="reference-size"===l,o="spike"===l,u=n.visualVariables?.find(S);if(!u&&!t&&!o)throw new i(`${r}:invalid-parameters`,"Renderer does not have a size visual variable");let m=s.field,p=s.normalizationField,d=null,c=null;m||(u?.field?(m=u.field,p=u.normalizationField):n.field?(m=n.field,p=n.normalizationField):(d=u?.valueExpression??n.valueExpression,c=u?.valueExpressionTitle??n.valueExpressionTitle));const{layer:f,forBinning:y,filter:z,view:v,signal:w}=e,h=I(n),b=await me({layer:f,field:m,valueExpression:d,valueExpressionTitle:c,normalizationField:p,theme:l,sizeOptimizationEnabled:h,forBinning:y,filter:z,view:v,signal:w},e.referenceSizeResult);return"reference-size"!==l||null==s.referenceSizeScale||!b.referenceSizeResult||b.referenceSizeResult.isGrid||b.sizeOptimizationEnabled||(b.sizeOptimizationEnabled=!0),{...e,creatorParameters:b,renderer:n}}async function be(e){const r="regenerate-size-continuous-renderer";T(e,r);const n=await k(e),a=O(n);if(!a||!["size-continuous","univariate-color-size"].includes(a))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:s,field:l,normalizationField:t,valueExpression:o,valueExpressionTitle:u}=n,m=s?.visualVariables.find(e=>"size"===e.type),p=m.theme,{layer:d,forBinning:c,filter:f,view:y,signal:z}=e,v=B(n),w=I(n),h=await pe({layer:d,field:l,valueExpression:o,valueExpressionTitle:u,normalizationField:t,theme:p,outlineOptimizationEnabled:v,sizeOptimizationEnabled:w,forBinning:c,filter:f,view:y,signal:z});return"reference-size"!==p||null==m.referenceSizeScale||!h.referenceSizeResult||h.referenceSizeResult.isGrid||h.sizeOptimizationEnabled||(h.sizeOptimizationEnabled=!0),{...e,creatorParameters:h,renderer:n}}async function ge(e){const r="regenerate-size-class-breaks-renderer";await T(e,r);const n=await k(e);if("size-class-breaks"!==O(n))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:a,field:s,normalizationField:l,normalizationType:t,normalizationTotal:o,valueExpression:u,valueExpressionTitle:m}=n,{classificationMethod:p,standardDeviationInterval:d}=a,c=n.classBreakInfos.length,{layer:f,forBinning:y,filter:z,view:v,signal:w}=e,h=B(n),b=await ye({layer:f,field:s,valueExpression:u,valueExpressionTitle:m,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:p,standardDeviationInterval:d,numClasses:c,outlineOptimizationEnabled:h,forBinning:y,filter:z,view:v,signal:w});return{...e,creatorParameters:b,renderer:n}}async function Se(e){const r="regenerate-size-age-renderer";await T(e,r);const n=await k(e);if("size-age"!==O(n))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:a}=n,s=a?.visualVariables.find(e=>"size"===e.type),l=s.startTime,t=s.endTime,o=s.units,u=s.theme,{layer:m,filter:p,view:d,signal:c}=e,f=B(n),y=I(n),z=await we({layer:m,startTime:l,endTime:t,unit:o,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:p,view:d,signal:c});return{...e,creatorParameters:z,renderer:n}}async function xe(e){let i=e.sizeScheme,r=null,n=null;const a=await N(e.basemap,e.view);if(r=null!=a.basemapId?a.basemapId:null,n=null!=a.basemapTheme?a.basemapTheme:null,i)return{scheme:se(i),basemapId:r,basemapTheme:n};const s=le({basemapTheme:n,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,r=s.basemapId,n=s.basemapTheme),{scheme:i,basemapId:r,basemapTheme:n}}function Ee(e,i){switch(i){case"point":case"multipoint":{const i=e;return[p(i.minSize),p(i.maxSize)]}case"polyline":{const i=e;return[p(i.minWidth),p(i.maxWidth)]}case"polygon":{const i=e;return[p(i.marker.minSize),p(i.marker.maxSize)]}}}function Ve(e,i){"clamped-linear"===e.transformationType&&"below"===i&&e.flipSizes()}async function Te(e,i,r,n,a,s){const l=ke(e,i,r,n);return l||Ee(a,s)}function ke(e,i,r,n){return"spike"===n?[r?.minHeight??ue[0],r?.maxHeight??ue[1]]:"reference-size"===n&&i?[1,i.size]:e?[e.minSize,e.maxSize]:null}function Oe(e,i){if("reference-size"===i.theme&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,r=0,n=0,a=1,s=e.avg,l=e.min,t=e.max,o=e.stddev,u=0!==s?o/s:0,m=l>n&&l<a&&t<2*a&&u<.5,p=l>r&&l<i&&t<2*i&&u<.5;return{minDataValue:m?n:p?r:l,maxDataValue:m?a:p?i:s+2*o,defaultValuesUsed:!1}}const{theme:r,field:n}=i,a=i.layer,s=n&&!("function"==typeof n)?a.getField(n):null,l=_(s);return H(e,r,l,"above"===r||"below"===r)}function Ie(e,r){if(("spike"===r||"reference-size"===r)&&null!=e.minDataValue&&null!=e.maxDataValue&&null!=e.minSize&&null!=e.maxSize&&"number"==typeof e.minSize&&"number"==typeof e.maxSize)return[new d({value:e.minDataValue,size:e.minSize}),new d({value:e.maxDataValue,size:e.maxSize})];throw new i("get-size-stops-for-theme","Invalid size variable or theme")}async function Be(e,r,a,s){const{theme:u,field:p,normalizationField:d,minValue:f,maxValue:y,axis:z}=e,v=e.layer.geometryType,w=await xe({basemap:e.basemap,geometryType:v,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=w.scheme;if(!h)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const b=await Te(a,s,e.spikeOptions,u,h,v),{minDataValue:g,maxDataValue:S,defaultValuesUsed:x}=Oe(r,e),E=[],V="height"===z,T=V?z:void 0,k=b[0];let O=b[1];if(V&&"number"==typeof k&&"number"==typeof O){const e=A({minSize:k,maxSize:O},T);E.push(new m({axis:"width-and-depth",minSize:e.minSize})),O=e.maxSize}const I=new m({field:p??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:d,axis:T,minSize:k,maxSize:O,minDataValue:g,maxDataValue:S,legendOptions:n(c,e.legendOptions)});Ve(I,u),E.unshift(I);const B=new o("reference-size"===u?{type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:Ie(I,u).map(({label:e,size:i,value:r})=>new t({label:e,size:i,value:r})),theme:u,referenceSizeScale:s?.isGrid||e.sizeOptimizationEnabled?e?.view?.scale:void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=f?f:r.min,maxSliderValue:null!=y?y:r.max}:"spike"===u?{type:"size",field:e.field,normalizationField:e.normalizationField,spikeSymbolStyle:e.spikeOptions?.symbolStyle,sizeStops:Ie(I,u).map(({label:e,size:i,value:r})=>new t({label:e,size:i,value:r})),theme:u,minSliderValue:null!=f?f:r.min,maxSliderValue:null!=y?y:r.max}:{type:"size",theme:u,minSliderValue:null!=f?f:r.min,maxSliderValue:null!=y?y:r.max}),F=new l({visualVariables:[B]});return{basemapId:w.basemapId,basemapTheme:w.basemapTheme,visualVariables:E,statistics:r,isGrid:s?.isGrid,defaultValuesUsed:x,sizeScheme:se(h),authoringInfo:F}}async function Fe(e,i,r,n,l){const t=await a("esri/smartMapping/t9n/smartMapping"),o=l.layer,u=l.field,m=o.geometryType,p=l.defaultSymbolEnabled,d=se(e.sizeScheme),c="polygon"===m,f=c?d.marker:d,y=c?d.background:null,z=c?"point":m,v=i?.opacity,w=e.isGrid,b=l.theme,S="reference-size"===b,x="spike"===b,E=S||x?[]:e.visualVariables.map(e=>e.clone());i?.visualVariables?.length&&E.push(...i.visualVariables.map(e=>e.clone()));const V=S?g({type:l.referenceSizeOptions?.symbolStyle||"circle",color:f.color,primitiveOverrides:h({view:l.view,field:u,normalizationField:n,sizeStops:Ie(e.visualVariables[0],b),sizeByScaleEnabled:w||!!l.sizeOptimizationEnabled})}):x?D({color:f.color,strokeColor:f.outline.color,baseWidth:l.spikeOptions?.baseWidth,strokeWidth:l.spikeOptions?.strokeWidth,defaultHeight:l.spikeOptions?.defaultHeight,primitiveOverrides:j({field:u,normalizationField:n,sizeStops:Ie(e.visualVariables[0],b)}),symbolStyle:l.spikeOptions?.symbolStyle}):L(z,{type:l.symbolType,color:f.color,size:K(f,z),outline:J(f,z,v)});return{renderer:new s({backgroundFillSymbol:!w&&y?L(m,{type:l.symbolType,color:y.color,outline:J(y,m,v)}):null,classBreakInfos:[{minValue:-oe,maxValue:oe,symbol:V}],defaultLabel:p?t.other:null,defaultSymbol:!p||S||x?null:L(z,{type:l.symbolType,color:f.noDataColor,size:K(f,z,!0),outline:J(f,z,v)}),field:u,normalizationField:n,normalizationType:r,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:E,authoringInfo:e.authoringInfo?.clone()}),visualVariables:e.visualVariables.map(e=>e.clone()),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,isGrid:w,sizeScheme:se(e.sizeScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}function Re(e,i){const n=r(e.minSize),a=(r(e.maxSize)-n)/(i>=4?i-1:i),s=[];for(let r=0;r<i;r++)s.push(n+a*r);return s}async function je(e,i){const r=await a("esri/smartMapping/t9n/smartMapping"),n=e.layer,t=e.defaultSymbolEnabled,o=n.geometryType,m="polygon"===o,p=e.symbolType?.includes("3d-volumetric"),d=await xe({basemap:e.basemap,geometryType:o,sizeScheme:e.sizeScheme,worldScale:p,view:e.view}),c=d.scheme,{result:f,outlineResult:y}=i,z=f?.classBreakInfos??[],v=e.classificationMethod,w=e.normalizationType,h=m?c.marker:c,b=m?c.background:null,g=m?"point":o,S=Ee(h,g),x=p?A({minSize:S[0],maxSize:S[1]},"height"):null,E=Re({minSize:S[0],maxSize:x?x.maxSize:S[1]},z.length),V=y?.opacity,T=new s({backgroundFillSymbol:b&&L(o,{type:e.symbolType,color:b.color,outline:J(b,o,V)}),classBreakInfos:z.map((i,r)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:L(g,{type:e.symbolType,color:h.color,size:E[r],widthAndDepth:x?.minSize,outline:J(h,g,V)}),label:i.label})),defaultLabel:t?r.other:null,defaultSymbol:t?L(g,{type:e.symbolType,color:h.noDataColor,size:K(h,g,!0),widthAndDepth:x?.minSize,outline:J(h,g,V)}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?f?.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new l({type:"class-breaks-size",classificationMethod:v,standardDeviationInterval:e.standardDeviationInterval})});return"standard-deviation"!==v&&u({classBreakInfos:T.classBreakInfos,classificationMethod:v,normalizationType:w,round:!0}),y?.visualVariables?.length&&(T.visualVariables=y.visualVariables.map(e=>e.clone())),{renderer:T,sizeScheme:se(c),classBreaksResult:f,defaultValuesUsed:!!i.defaultValuesUsed,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}async function qe(e){const i=await me(e),{view:r,field:n,valueExpression:a,minValue:s,maxValue:l,layer:t,normalizationField:o,signal:u,statistics:m,filter:p}=i,d=o?"field":void 0,[c,f]=await Promise.all([m??U({layer:t,field:n,valueExpression:a,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:d,normalizationField:o,filter:p,minValue:s,maxValue:l,view:r,signal:u}),i.sizeOptimizationEnabled?v({view:r,layer:t,signal:u,filter:p}).catch(P):null]);return Be(i,c,f,i.referenceSizeResult)}async function De(e){const{view:i,filter:r,renderer:n,signal:a,creatorParameters:s}=await he(e),{field:l,normalizationField:o,valueExpression:u,theme:p,layer:d,sizeOptimizationEnabled:c,spikeOptions:f,referenceSizeResult:y,valueExpressionTitle:z}=s,w=o?"field":void 0,[h,b]=await Promise.all([U({layer:d,field:l,valueExpression:u,normalizationField:o,normalizationType:w,filter:r,view:i,signal:a}),c&&!y?v({view:i,layer:d,signal:a,filter:r}).catch(P):null]),g=ke(b,y,f,p),{minDataValue:E,maxDataValue:V}=Oe(h,{theme:p,layer:d,field:l}),T=n.visualVariables?.find(S),k=(T?.stops?null:T)??new m({field:l??void 0,valueExpression:u,valueExpressionTitle:z,valueUnit:"unknown",normalizationField:o});g&&(k.minSize=g[0],k.maxSize=g[1]),k.minDataValue=E,k.maxDataValue=V,Ve(k,p);const O=x(n,"size");O.minSliderValue=h.min,O.maxSliderValue=h.max;const I="reference-size"===p;return(I||"spike"===p)&&(O.sizeStops=Ie(k,p).map(({label:e,size:i,value:r})=>new t({label:e,size:i,value:r})),I&&(O.referenceSizeScale=y?.isGrid||c?i?.scale:void 0)),{visualVariables:"reference-size"===p||"spike"===p?[]:[k],isGrid:!!y?.isGrid,authoringInfo:n.authoringInfo?.clone(),statistics:h}}async function Ge(e){const i=await pe(e),r={layer:i.layer,view:i.view,filter:i.filter,signal:i.signal},[n,a]=await Promise.all([qe(ve(i)),i.outlineOptimizationEnabled?y(r).catch(P):null]),s=i.normalizationField;return Fe(n,a,s?"field":void 0,s,i)}async function Ue(e){const{renderer:i,view:r,signal:n,filter:a,creatorParameters:s,forBinning:l}=await be(e),{layer:t,sizeOptimizationEnabled:o,outlineOptimizationEnabled:u,theme:m,referenceSizeResult:p}=s,[d,c]=await Promise.all([De({...e,referenceSizeResult:p}),u?y({layer:t,view:r,filter:a,signal:n}).catch(P):null]),f="reference-size"===m,z="spike"===m;E(i,d.visualVariables,F),E(i,c?.visualVariables,R),V(i,d.authoringInfo,"size");const v=d.statistics;if(!f&&!z)return{renderer:i,statistics:v};if(z){return{renderer:await Me({layer:t,renderer:i,forBinning:l,sizeStops:x(i,"size","spike")?.sizeStops}),statistics:v}}const w=d.isGrid;return{renderer:await Pe({layer:t,renderer:i,view:r,forBinning:l,sizeOptimizationEnabled:o,sizeStops:x(i,"size","reference-size")?.sizeStops,isGrid:w}),isGrid:w,statistics:v}}async function Pe(r){const{layer:n,referenceSizeOptions:a,renderer:s,sizeScheme:o,sizeStops:u,typeScheme:m,view:p,isGrid:d}=await ce(r),c=s.clone();c.authoringInfo??=new l;const f=c.authoringInfo.visualVariables.find(e=>"reference-size"===e.theme),y=r.field??f?.field,z=r.normalizationField??f?.normalizationField;if(!y)throw new i("update-renderer-with-reference-size:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const v=h({view:p,field:y,normalizationField:z,sizeStops:u,sizeByScaleEnabled:d||!!r.sizeOptimizationEnabled}),w=a?.symbolStyle||f?.referenceSizeSymbolStyle||"circle";if("class-breaks"===c.type){const e="polygon"===("geometryType"in n?n.geometryType:null)&&o&&"marker"in o?o.marker:null;c.classBreakInfos.forEach(i=>{const r=e?.color??te(i.symbol,1);"cim"===i.symbol.type?b(i.symbol,{type:w,color:r,primitiveOverrides:v}):r&&(i.symbol=g({type:w,color:r,primitiveOverrides:v}))})}else if("unique-value"===c.type){const i=c.uniqueValueGroups,r="polygon"===("geometryType"in n?n.geometryType:null)&&m&&"colors"in m?m.colors:null,a=r?e(r,c.uniqueValueInfos?.length??0):null;let s=0;if(i){for(const e of i)for(const i of e.classes??[]){const e=a?a[s]:te(i.symbol,1);"cim"===i.symbol?.type?b(i.symbol,{type:w,color:e,primitiveOverrides:v}):e&&(i.symbol=g({type:w,color:e,primitiveOverrides:v})),s++}c.uniqueValueGroups=i}}return f&&(f.field=y,f.normalizationField=z,f.sizeStops=u.map(({label:e,size:i,value:r})=>new t({label:e,size:i,value:r})),f.referenceSizeScale=d||r.sizeOptimizationEnabled?p.scale:void 0,f.referenceSizeSymbolStyle=w),c}async function Me(r){const{layer:n,renderer:a,sizeScheme:s,sizeStops:o,typeScheme:u,spikeOptions:m}=await fe(r),p=a.clone();p.authoringInfo??=new l;const d=p.authoringInfo.visualVariables.find(e=>"spike"===e.theme),c=r.field??d?.field,f=r.normalizationField??d?.normalizationField;if(!c)throw new i("update-renderer-with-spike:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const y=j({field:c,normalizationField:f,sizeStops:o}),z="geometryType"in n?n.geometryType:null,v={primitiveOverrides:y,...m},h=m?.symbolStyle,b=h&&h.includes("outline")&&(h.includes("solid-fill")||h.includes("gradient-fill"));if("class-breaks"===p.type){if(s||b){const e=z?await xe({geometryType:z,sizeScheme:s,view:r.view}):null,i=e?.scheme,n="polygon"===z&&i&&"marker"in i?i.marker:i;if(s){const e=n&&"color"in n?n?.color:void 0;v.color=e}if(b){const e=n&&"outline"in n?n.outline.color:void 0;v.strokeColor=e}}p.classBreakInfos.forEach(e=>{if("cim"===e.symbol.type)q(e.symbol,v);else{const i=v.color??te(e.symbol,1)??void 0;i&&(e.symbol=D({...v,color:i}))}})}else if("unique-value"===p.type){const i=p.uniqueValueGroups,n=p.uniqueValueInfos?.length??0;let a=null;if(u||b){const i=z&&n?await w({numColors:n,geometryType:z,typeScheme:u,view:r.view}):null,s=i?.scheme;if(u){const i=s&&"colors"in s?s.colors:null;a=i?e(i,n):null}if(b){const e=s&&"outline"in s?s.outline.color:void 0;v.strokeColor=e}}let s=0;if(i){for(const e of i)for(const i of e.classes??[]){if("cim"===i.symbol?.type)q(i.symbol,{...v,color:a?.[s]});else{const e=a?.[s]??te(i.symbol,1)??void 0;e&&(i.symbol=D({...v,color:e}))}s++}p.uniqueValueGroups=i}}return d&&(d.field=c,d.normalizationField=f,d.sizeStops=o.map(({label:e,size:i,value:r})=>new t({label:e,size:i,value:r})),h&&(d.spikeSymbolStyle=h)),p}async function Ce(e){const i=await ye(e);return je(i,await M(ze(i),i.outlineOptimizationEnabled))}async function We(e){const{renderer:r,creatorParameters:n}=await ge(e),{outlineOptimizationEnabled:a,normalizationType:s,classificationMethod:l}=n,{result:t,outlineResult:o}=await M(ze(n),a),m=t.classBreakInfos;if(n.numClasses!==m.length)throw new i("regenerate-class-breaks-renderer:invalid-parameters","The number of class breaks generated does not match the number of class breaks in the renderer.");return r.classBreakInfos.forEach((e,i)=>{e.minValue=m[i].minValue,e.maxValue=m[i].maxValue,e.label=m[i].label}),r.normalizationTotal="percent-of-total"===s?t.normalizationTotal:void 0,"standard-deviation"!==l&&u({classBreakInfos:r.classBreakInfos,classificationMethod:l,normalizationType:s,round:!0}),E(r,o?.visualVariables,R),{renderer:r}}async function $e(e){const i=await we(e),{defaultSymbolEnabled:r,view:n,startTime:a,endTime:s,symbolType:l,minValue:t,maxValue:o,signal:u,filter:m,layer:p}=i,[d,c]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await f({view:n,layer:p,startTime:a,endTime:s,minValue:t,maxValue:o,signal:u,filter:m}),i.outlineOptimizationEnabled?y({layer:p,view:n,filter:m,signal:u}).catch(P):null]),{unit:z,statistics:v}=d,{valueExpression:w,title:h}=await C(i,z),b=await qe(ve({layer:p,basemap:i.basemap,valueExpression:w,symbolType:l,statistics:v,legendOptions:{title:h},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:t,maxValue:o,filter:m,signal:u})),g={layer:p,valueExpression:w,defaultSymbolEnabled:r,symbolType:l},S=await Fe(b,c,null,null,g),x=S.renderer.authoringInfo?.visualVariables;return x?.forEach(e=>W(e,a,s,z)),{...S,unit:z}}async function Ae(e){const{renderer:i,creatorParameters:r}=await Se(e),{layer:n,outlineOptimizationEnabled:a,sizeOptimizationEnabled:s,startTime:l,endTime:t,theme:o,view:u,signal:m,filter:p}=r,[d,c]=await Promise.all([f({view:u,layer:n,startTime:l,endTime:t,signal:m,filter:p}),a?y({layer:n,view:u,filter:p,signal:m}).catch(P):null]),{unit:z,statistics:v}=d,{valueExpression:w,title:h}=await C(r,z),b=await qe(ve({layer:n,valueExpression:w,statistics:v,legendOptions:{title:h},sizeOptimizationEnabled:s,theme:o,view:u,filter:p,signal:m}));E(i,b.visualVariables,F),E(i,c?.visualVariables,R),i.authoringInfo=b.authoringInfo.clone();const g=i.authoringInfo?.visualVariables;return g?.forEach(e=>W(e,l,t,z)),{renderer:i}}export{$e as createAgeRenderer,Ce as createClassBreaksRenderer,Ge as createContinuousRenderer,qe as createVisualVariables,Ie as getSizeStopsForTheme,Ae as regenerateAgeRenderer,We as regenerateClassBreaksRenderer,Ue as regenerateContinuousRenderer,De as regenerateVisualVariables,Pe as updateRendererWithReferenceSize,Me as updateRendererWithSpike};
