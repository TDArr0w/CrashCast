/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{clone as a}from"../../core/lang.js";import{ensureClass as r}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as o}from"../../intl/messages.js";import n from"../../renderers/ClassBreaksRenderer.js";import l from"../../renderers/PointCloudRGBRenderer.js";import s from"../../renderers/PointCloudStretchRenderer.js";import t from"../../renderers/support/AuthoringInfo.js";import u from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as m,createColorStops as c}from"../../renderers/support/utils.js";import d from"../../renderers/visualVariables/ColorVariable.js";import p from"../../renderers/visualVariables/support/ColorStop.js";import f from"../../renderers/visualVariables/support/VisualVariableLegendOptions.js";import y from"../heuristics/ageUnit.js";import v from"../heuristics/outline.js";import h from"../heuristics/sizeRange.js";import{spliceVisualVariables as w,updateAuthoringInfoVisualVariable as b,processRegenerateParams as g,getRendererToUpdate as T,getStyleType as x,hasOutlineVV as z,hasScaleDependentSizeVV as E,findColorVVIndex as V,findOutlineVVIndex as I,findScaleDependentSizeVVIndex as S}from"./support/regenerateUtils.js";import{getSummaryStatistics as M,errorCallback as B,getClassBreaks as O,getPointSizeAlgorithm as j,getTitleAndExpressionForAgeRenderer as k,updateAgeRendererAuthoringInfoVV as F,verifyBasicFieldValidity as q,getDataRange as R,createDataValues as U,createSymbol as C,getSymbolOutlineFromScheme as P,getSymbolSizeFromScheme as D,isValidPointSize as $,getDefaultDataRange as L,createDefaultStopValues as A,createStopValues as G,getBasemapInfo as W}from"./support/utils.js";import{verifyDates as H,supportedAgeUnits as J}from"../statistics/support/ageUtils.js";import{verifyBinningParams as K}from"../support/binningUtils.js";import{isAnyDateField as N,getFieldsList as Q,getNormalizationType as X}from"../support/utils.js";import{binningCapableLayerTypes as Y,featureCapableLayerTypes as Z,createLayerAdapter as _,getLayerTypeLabels as ee}from"../support/adapters/support/layerUtils.js";import{cloneScheme as ie,createScheme as ae,getSchemes as re,getSchemeById as oe}from"../symbology/color.js";import{getColorSchemeDefinition as ne}from"../symbology/support/utils.js";const le="high-to-low",se=2**53-1,te=5;async function ue(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-visual-variable");const a={...e},r=e.forBinning?Y:Z,o=_(a.layer,r,e.forBinning);if(!o)throw new i("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);if("mesh"!==o.geometryType&&a.worldScale&&(!a.view||"3d"!==a.view.type))throw new i("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const l=await Q({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),s=q(o,l,"color-visual-variable:invalid-parameters");if(s)throw s;return{...a,layer:o}}async function me(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-continuous-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=e.forBinning?Y:Z,o=_(a.layer,r,e.forBinning);if(!o)throw new i("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);const l=o.geometryType;a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled;const s="featureReduction"in a.layer&&"cluster"===a.layer.featureReduction?.type;if(a.sizeOptimizationEnabled=!("point"!==l&&"multipoint"!==l&&"polyline"!==l||s)&&a.sizeOptimizationEnabled,"mesh"===l)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==l)throw new i("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await Q({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),u=q(o,t,"color-continuous-renderer:invalid-parameters");if(u)throw u;return{...a,layer:o}}async function ce(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-class-breaks-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="equal-interval",a.normalizationType=X(a);const r=e.forBinning?Y:Z,o=_(a.layer,r,e.forBinning);if(!o)throw new i("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(!(null!=a.minValue&&null!=a.maxValue)&&(null!=a.minValue||null!=a.maxValue))throw new i("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);const l=o.geometryType;if(a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled,"mesh"===l)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==l)throw new i("color-class-breaks-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await Q({field:a.field,normalizationField:a.normalizationField}),t=q(o,s,"color-class-breaks-renderer:invalid-parameters");if(t)throw t;return{...a,layer:o}}function de(e){const i={...e};delete i.basemap,delete i.colorScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}async function pe(e){if(!e?.layer)throw new i("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const a={...e,layer:e.layer},r=[10],o=_(a.layer,r);if(!o)throw new i("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(a.layer=o,a.density=a.density||25,a.size=a.size||"100%",!$(a.size))throw new i("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=a.signal?{signal:a.signal}:null;return await o.load(n),a}async function fe(e){if(!e?.layer||!e.field)throw new i("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const a=e.field.toLowerCase();if("intensity"!==a&&"elevation"!==a)throw new i("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const r={...e,layer:e.layer,field:e.field},o=[10],n=_(r.layer,o);if(!n)throw new i("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(o).join(", "));if(r.layer=n,r.density=r.density||25,r.size=r.size||"100%",!$(r.size))throw new i("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const l=null!=r.signal?{signal:r.signal}:null;return await n.load(l),r}function ye(e){const i={...e},a=!!i.symbolType?.includes("3d-volumetric");delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const r=i;return r.worldScale=a,r}async function ve(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=_(a.layer,Z);if(!r)throw new i("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+ee(Z).join(", "));const o=null!=a.signal?{signal:a.signal}:null;await r.load(o);const n=r.geometryType;a.outlineOptimizationEnabled="polygon"===n&&a.outlineOptimizationEnabled;const l="featureReduction"in a.layer&&"cluster"===a.layer.featureReduction?.type;if(a.sizeOptimizationEnabled=!("point"!==n&&"multipoint"!==n&&"polyline"!==n||l)&&a.sizeOptimizationEnabled,"mesh"===n)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else if("3d-volumetric-uniform"===a.symbolType&&"point"!==n)throw new i("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const s=H(r,a.startTime,a.endTime,"color-age-renderer:invalid-parameters");if(s)throw s;if(a.unit&&!J.includes(a.unit))throw new i("color-age-renderer:invalid-unit",`Supported units are: ${J.join(", ")}`);return{...a,layer:r}}async function he(e){const a="regenerate-color-visual-variable";await g(e,a);const r=await T(e);if("class-breaks"!==r?.type)throw new i(`${a}:invalid-parameters`,"Renderer must be a ClassBreaksRenderer to regenerate a color visual variable");const o=r.authoringInfo,n=o?.visualVariables.find(e=>"color"===e.type),l=r.visualVariables?.find(e=>"color"===e.type);if(!l)throw new i(`${a}:invalid-parameters`,"Renderer does not have a color visual variable");const{field:s,normalizationField:t,valueExpression:u,valueExpressionTitle:m}=l,c="univariate-color-size"===o?.type?o?.univariateTheme:n?.theme,{layer:d,forBinning:p,filter:f,view:y,signal:v}=e,h=await ue({layer:d,field:s,valueExpression:u,valueExpressionTitle:m,normalizationField:t,theme:c,forBinning:p,filter:f,view:y,signal:v});return{...e,creatorParameters:h,renderer:r}}async function we(e){const a="regenerate-color-continuous-renderer";await g(e,a);const r=await T(e),o=x(r);if(!o||!["color-continuous","color-size"].includes(o))throw new i(`${a}:invalid-renderer`,"Renderer is invalid");const{authoringInfo:n,field:l,normalizationField:s,valueExpression:t,valueExpressionTitle:u}=r,m=n?.visualVariables.find(e=>"color"===e.type),c=m?.theme,{layer:d,forBinning:p,filter:f,view:y,signal:v}=e,h=z(r),w=E(r),b=await me({layer:d,field:l,valueExpression:t,valueExpressionTitle:u,normalizationField:s,theme:c,outlineOptimizationEnabled:h,sizeOptimizationEnabled:w,forBinning:p,filter:f,view:y,signal:v});return{...e,creatorParameters:b,renderer:r}}async function be(e){const a="regenerate-color-class-breaks-renderer";await g(e,a);const r=await T(e);if("color-class-breaks"!==x(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:o,field:n,normalizationField:l,normalizationType:s,normalizationTotal:t,valueExpression:u,valueExpressionTitle:m}=r,{classificationMethod:c,standardDeviationInterval:d}=o,p=r.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:h,signal:w}=e,b=z(r),E=await ce({layer:f,field:n,valueExpression:u,valueExpressionTitle:m,normalizationType:s,normalizationField:l,normalizationTotal:t,classificationMethod:c,standardDeviationInterval:d,numClasses:p,outlineOptimizationEnabled:b,defaultSymbolEnabled:!!r.defaultSymbol,forBinning:y,filter:v,view:h,signal:w});return{...e,creatorParameters:E,renderer:r}}async function ge(e){const a="regenerate-color-age-renderer";await g(e,a);const r=await T(e);if("color-age"!==x(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:o}=r,n=o?.visualVariables.find(e=>"color"===e.type),l=n.startTime,s=n.endTime,t=n.units,u=n.theme,{layer:m,filter:c,view:d,signal:p}=e,f=z(r),y=E(r),v=await ve({layer:m,startTime:l,endTime:s,unit:t,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:c,view:d,signal:p});return{...e,creatorParameters:v,renderer:r}}async function Te(e,i){let a=e.colorScheme,r=null,o=null;const{view:n}=e,l=await W(e.basemap,n);if(r=null!=l.basemapId?l.basemapId:null,o=null!=l.basemapTheme?l.basemapTheme:null,a)return{scheme:ie(a),basemapId:r,basemapTheme:o};const s=e.theme||le,t=re({theme:s,basemapTheme:o,geometryType:e.geometryType,worldScale:e.worldScale,view:n});if(t)if(r=t.basemapId,o=t.basemapTheme,e.schemeId){const i=s+"/"+r+"/"+e.schemeId;a=oe({id:i,geometryType:e.geometryType})}else a=t.primaryScheme;return{scheme:a,basemapId:r,basemapTheme:o}}function xe(e,i){const a=ne(e);return ae({geometryType:i},void 0,a.commonProps,a.colorRampInfo)}async function ze(a,r){const o=r.layer,n=await Te({basemap:r.basemap,colorScheme:r.colorScheme,geometryType:o.geometryType,schemeId:"elevation"===r.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),l=n.scheme;if(!l)throw new i("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const s=e(l.colors,te);if(s.length<te)throw new i("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const t=L(a,!1,!0),u=t?A(t[0],t[1],5):G(a);return{stops:c({values:u,isDate:!1,colors:s,labelIndexes:[0,2,4]}),basemapId:n.basemapId,basemapTheme:n.basemapTheme,statistics:a,defaultValuesUsed:!!t,colorScheme:ie(l)}}function Ee(e,i,a,r){const o=R(e,i,a,!0);return{values:U(o,e,i,r),defaultValuesUsed:o.defaultValuesUsed}}async function Ve(a,o,n,l){const{field:s,theme:m}=a,c=await Te({basemap:a.basemap,theme:a.theme,geometryType:n,colorScheme:a.colorScheme,worldScale:a.worldScale,view:a.view}),y=c.scheme;if(!y)throw new i("color-visual-variable:insufficient-info","Unable to find color scheme");const v=e(y.colors,te);if(v.length<te)throw new i("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const h=y.id.includes("seq-"),{values:w,defaultValuesUsed:b}=Ee(o,m,l,h),g=e(v,te),T=new d({field:s??void 0,valueExpression:a.valueExpression,valueExpressionTitle:a.valueExpressionTitle,normalizationField:a.normalizationField,stops:w.map((e,i)=>new p({value:e,color:g[i]})),legendOptions:r(f,a.legendOptions)}),x=new u({type:"color",minSliderValue:null!=a.minValue?a.minValue:o.min,maxSliderValue:null!=a.maxValue?a.maxValue:o.max,theme:y.theme}),z=new t({visualVariables:[x]});return{basemapId:c.basemapId,basemapTheme:c.basemapTheme,visualVariable:T,statistics:o,defaultValuesUsed:b,colorScheme:ie(y),authoringInfo:z}}async function Ie(e,i,a,r,l,s,t){const u=await o("esri/smartMapping/t9n/smartMapping"),{field:m,defaultSymbolEnabled:c}=t,d=ie(e.colorScheme),p=i?.opacity,f=[e.visualVariable.clone()];i?.visualVariables?.length&&f.push(...i.visualVariables.map(e=>e.clone())),a?.minSize&&f.push(a.minSize);return{renderer:new n({classBreakInfos:[{minValue:-se,maxValue:se,symbol:C(s,{type:t.symbolType,color:d.noDataColor,size:D(d,s),outline:P(d,s,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:c?u.other:null,defaultSymbol:c?C(s,{type:t.symbolType,color:d.noDataColor,size:D(d,s),outline:P(d,s,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:m,normalizationType:r,normalizationField:l,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:f,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:ie(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function Se(e){const i=await ue(e),{view:a,field:r,valueExpression:o,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:u,filter:m,statistics:c}=i,d=t?"field":void 0,p=await(c??M({layer:s,field:r,valueExpression:o,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:d,normalizationField:t,minValue:n,maxValue:l,filter:m,view:a,signal:u})),f=s,y=r&&"function"!=typeof r?f.getField(r):null;return Ve(i,p,f.geometryType,N(y))}async function Me(i){const{view:a,filter:r,creatorParameters:o,renderer:n,signal:l}=await he(i),s=n.authoringInfo?.clone(),t=s?.visualVariables.find(e=>"color"===e.type),u=n.visualVariables?.find(e=>"color"===e.type),{field:m,normalizationField:c,valueExpression:d,theme:f,layer:y}=o,v=await M({layer:y,field:m,valueExpression:d,normalizationField:c,filter:r,view:a,signal:l}),h=m&&"function"!=typeof m?y.getField(m):null,{values:w}=Ee(v,f,N(h),"high-to-low"===f);if(w.length===u.stops.length)u.stops.forEach((e,i)=>e.value=w[i]);else{const i=u.stops.map(e=>e.color),a=e(i,te);u.stops=w.map((e,i)=>new p({value:e,color:a[i]}))}return t&&(t.minSliderValue=v.min,t.maxSliderValue=v.max),{visualVariable:u,authoringInfo:s,statistics:v}}function Be(i,r){const o=i.colorsForClassBreaks;if(o?.length)for(const e of o)if(e.numClasses===r)return a(e.colors);return e(i.colors,r)}async function Oe(e,a){const r=await o("esri/smartMapping/t9n/smartMapping"),l=e.layer,s=e.defaultSymbolEnabled,u=l.geometryType,c=e.classificationMethod,d="standard-deviation"===c,p=await Te({basemap:e.basemap,geometryType:u,theme:d?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),f=p.scheme,{result:y,outlineResult:v}=a,h=y.classBreakInfos,w=e.normalizationType;if(!f)throw new i("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const b=Be(f,h.length);if(!b||b.length!==h.length)throw new i("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=v?.opacity,T=new n({classBreakInfos:h.map((i,a)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:C(u,{type:e.symbolType,color:b[a],size:D(f,u),outline:P(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:i.label})),defaultLabel:s?r.other:null,defaultSymbol:s?C(u,{type:e.symbolType,color:f.noDataColor,size:D(f,u),outline:P(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?y.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new t({type:"class-breaks-color",classificationMethod:c,standardDeviationInterval:e.standardDeviationInterval})});return d||m({classBreakInfos:T.classBreakInfos,classificationMethod:c,normalizationType:w,round:!0}),v?.visualVariables?.length&&(T.visualVariables=v.visualVariables.map(e=>e.clone())),{renderer:T,colorScheme:ie(f),classBreaksResult:y,defaultValuesUsed:a.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function je(e){const i=await me(e),{layer:a,view:r,signal:o,filter:n}=i,[l,s,t]=await Promise.all([Se(ye(i)),i.outlineOptimizationEnabled?v({layer:a,view:r,signal:o,filter:n}).catch(B):null,i.sizeOptimizationEnabled?h({layer:a,view:r,signal:o,filter:n}).catch(B):null]),u=i.normalizationField;return Ie(l,s,t,u?"field":void 0,u,a.geometryType,i)}async function ke(e){const{renderer:i,view:a,signal:r,filter:o,creatorParameters:n}=await we(e),{layer:l,outlineOptimizationEnabled:s,sizeOptimizationEnabled:t}=n,[u,m,c]=await Promise.all([Me(e),s?v({layer:l,view:a,signal:r,filter:o}).catch(B):null,t?h({layer:l,view:a,signal:r,filter:o}).catch(B):null]);return w(i,u.visualVariable,V),w(i,m?.visualVariables,I),w(i,c?.minSize,S),b(i,u.authoringInfo,"color"),{renderer:i}}async function Fe(e){const i=await ce(e);return Oe(i,await O(de(i),i.outlineOptimizationEnabled))}async function qe(e){const{renderer:i,creatorParameters:a}=await be(e),{normalizationType:r,outlineOptimizationEnabled:o,classificationMethod:n}=a;if("manual"===n)return{renderer:i};const l=await O(de(a),o),s=l.result.classBreakInfos;if(a.numClasses!==s.length){const e=xe(i.classBreakInfos.map(e=>e.symbol),a.layer.geometryType);return{renderer:(await Oe({...a,colorScheme:e},l)).renderer}}return i.classBreakInfos.forEach((e,i)=>{e.minValue=s[i].minValue,e.maxValue=s[i].maxValue,e.label=s[i].label}),i.normalizationTotal="percent-of-total"===r?l.result.normalizationTotal:void 0,"standard-deviation"!==n&&m({classBreakInfos:i.classBreakInfos,classificationMethod:n,normalizationType:r,round:!0}),w(i,l.outlineResult?.visualVariables,I),{renderer:i}}function Re(e){return pe(e).then(e=>({renderer:new l({field:"RGB",pointsPerInch:e.density??void 0,pointSizeAlgorithm:j(e.size)})}))}async function Ue(e){const i=await fe(e),a=i.statistics??await M({layer:i.layer,field:i.field,signal:i.signal}),r=await ze(a,i);return{renderer:new s({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:j(i.size),stops:r.stops}),basemapId:r.basemapId,basemapTheme:r.basemapTheme,statistics:r.statistics,defaultValuesUsed:r.defaultValuesUsed,colorScheme:r.colorScheme}}async function Ce(e){const i=await ve(e),{defaultSymbolEnabled:a,view:r,startTime:o,endTime:n,symbolType:l,colorMixMode:s,edgesType:t,minValue:u,maxValue:m,signal:c,filter:d}=i,p=i.layer,[f,w,b]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:y({view:r,layer:p,startTime:o,endTime:n,minValue:u,maxValue:m,signal:c,filter:d}),i.outlineOptimizationEnabled?v({layer:p,view:r,signal:c,filter:d}).catch(B):null,i.sizeOptimizationEnabled?h({layer:p,view:r,signal:c,filter:d}).catch(B):null]),{unit:g,statistics:T}=f,{valueExpression:x,title:z}=await k(i,g),E=await Se(ye({layer:p,basemap:i.basemap,valueExpression:x,symbolType:l,statistics:T,legendOptions:{title:z},colorScheme:i.colorScheme,theme:i.theme,view:r,minValue:i.minValue,maxValue:i.maxValue,filter:d,signal:c})),V={valueExpression:x,defaultSymbolEnabled:a,symbolType:l,colorMixMode:s,edgesType:t},I=await Ie(E,w,b,null,null,p.geometryType,V),S=I.renderer.authoringInfo?.visualVariables;return S?.forEach(e=>F(e,o,n,g)),{...I,unit:g}}async function Pe(e){const{renderer:i,creatorParameters:a}=await ge(e),{layer:r,outlineOptimizationEnabled:o,sizeOptimizationEnabled:n,startTime:l,endTime:s,theme:t,view:u,signal:m,filter:c}=a,[d,p,f]=await Promise.all([y({view:u,layer:r,startTime:l,endTime:s,signal:m,filter:c}),o?v({layer:r,view:u,signal:m,filter:c}).catch(B):null,n?h({layer:r,view:u,signal:m,filter:c}).catch(B):null]),{unit:b,statistics:g}=d,{valueExpression:T,title:x}=await k(a,b),z=await Se(ye({layer:r,valueExpression:T,statistics:g,legendOptions:{title:x},theme:t,view:u,filter:c,signal:m}));w(i,z.visualVariable,V),w(i,p?.visualVariables,I),w(i,f?.minSize,S),i.authoringInfo=z.authoringInfo.clone();const E=i.authoringInfo?.visualVariables;return E?.forEach(e=>F(e,l,s,b)),{renderer:i}}export{Ce as createAgeRenderer,Fe as createClassBreaksRenderer,je as createContinuousRenderer,Ue as createPCContinuousRenderer,Re as createPCTrueColorRenderer,Se as createVisualVariable,Pe as regenerateAgeRenderer,qe as regenerateClassBreaksRenderer,ke as regenerateContinuousRenderer,Me as regenerateVisualVariable};
