/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../Color.js";import{createUniqueColors as a}from"../../core/colorUtils.js";import r from"../../core/Error.js";import t from"../../renderers/HeatmapRenderer.js";import i from"../../renderers/support/AuthoringInfo.js";import n from"../../renderers/support/HeatmapColorStop.js";import{gaussianBlurRadiusPxToKernelDensityRadiusPt as o}from"../../renderers/support/heatmapUtils.js";import{processRegenerateParams as s,getRendererToUpdate as m,getStyleType as l}from"./support/regenerateUtils.js";import{verifyBasicFieldValidity as p,getBasemapInfo as d}from"./support/utils.js";import f from"../statistics/heatmapStatistics.js";import{getFieldsList as u}from"../support/utils.js";import{createLayerAdapter as c,getLayerTypeLabels as h}from"../support/adapters/support/layerUtils.js";import{cloneScheme as w,getSchemes as y}from"../symbology/heatmap.js";const b=.01,g=[0,.04];async function R(e){if(!e?.layer||!e.view)throw new r("heatmap-renderer:missing-parameters","'layer' and 'view' parameters are required");const a={...e,layer:e.layer,view:e.view};a.radius??=null==a.blurRadius?18:o(a.blurRadius),a.minRatio??=.01,a.maxRatio??=1,a.fadeRatio??=.2,a.fadeToTransparent??=!0;const t=[2,3,4,6,7,8,9,12,15],i=c(a.layer,t);if(!i)throw new r("heatmap-renderer:invalid-parameters","'layer' must be one of these types: "+h(t).join(", "));a.layer=i;const n=null!=a.signal?{signal:a.signal}:null;await i.load(n);const s=await u({field:a.field}),m=p(i,s,"heatmap-renderer:invalid-parameters");if(m)throw m;return a}async function v(e){const a="regenerate-heatmap-renderer";await s(e,a);const t=await m(e);if("heatmap"!==l(t))throw new r(`${a}:invalid-parameters`,"Renderer is invalid");const{layer:i,filter:n,view:o,signal:p}=e,d=await R({layer:i,field:t.field,radius:t.radius,fadeRatio:t.authoringInfo?.fadeRatio,filter:n,view:o,signal:p});return{...e,creatorParameters:d,renderer:t}}async function j(e){let a=e.scheme,r=null,t=null;const i=await d(e.basemap,e.view);if(r=null!=i.basemapId?i.basemapId:null,t=null!=i.basemapTheme?i.basemapTheme:null,a)return{scheme:w(a),basemapId:r,basemapTheme:t};const n=y({basemapTheme:t});return n&&(a=n.primaryScheme,r=n.basemapId,t=n.basemapTheme),{scheme:a,basemapId:r,basemapTheme:t}}async function I(r,o){const{field:s,basemap:m,radius:l,fadeToTransparent:p,heatmapScheme:d,view:f}=o,{scheme:u,basemapId:c,basemapTheme:h}=await j({basemap:m,scheme:d,view:f}),y=u.colors,R=y.length,v=null==r.min,I=v?g:[r.min,r.max];let x;const S=o.fadeRatio??0,U=o.maxRatio??0,D=o.minRatio??0,E=(U-D)/(R-1),C=y[0],H=p?D:b,M=[new n({ratio:0,color:new e([C.r,C.g,C.b,0])}),new n({ratio:b,color:new e([C.r,C.g,C.b,0])}),new n({ratio:H,color:new e([C.r,C.g,C.b,H])})];a(y,R).forEach((e,a)=>{const r=D+E*a;M.push(new n({ratio:r,color:e}))}),p&&(T(M,S),x=new i({fadeRatio:S}));return{renderer:new t({authoringInfo:x,radius:l,colorStops:M,field:s,minDensity:I[0],maxDensity:I[1]}),statistics:r,defaultValuesUsed:v,scheme:w(u),basemapId:c,basemapTheme:h}}function T(e,a){const r=10*(1-a)+1,t=e.length-3,i=e[2].color.a;e.forEach((e,n)=>{if(n<=2)return;const{color:o}=e,s=(n-3)/t;o.a=0===a?1:Math.min(Math.max(s*r+s+i,i),1)})}async function x(e){const a=await R(e);return I(a.statistics??await f({layer:a.layer,field:a.field,radius:a.radius,view:a.view,filter:a.filter,signal:a.signal}),a)}async function S(e){const{creatorParameters:a,renderer:r}=await v(e),t=await f({layer:a.layer,field:a.field,radius:a.radius,view:a.view,filter:a.filter,signal:a.signal}),i=null==t.min?g:[t.min,t.max];return r.minDensity=i[0],r.maxDensity=i[1],{renderer:U({renderer:r,fadeRatio:a.fadeRatio})}}function U(e){const{fadeRatio:a,renderer:r}=e,t=r.clone(),n=a??(t?.authoringInfo?.fadeRatio||0);return T(t.colorStops,n),t.authoringInfo?t.authoringInfo.fadeRatio=n:t.authoringInfo=new i({fadeRatio:n}),t}export{x as createRenderer,S as regenerateRenderer,U as updateRenderer};
