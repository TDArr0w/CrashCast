/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{equals as e}from"../../../../../core/arrayUtils.js";import{fromArray as t}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getHeightUnitCorrectionFactor as s,interpolateM as n}from"../../../../geometry/coordUtils.js";import{segmentLength3d as a,distanceAlongLineSegmentWithZ as r,distanceAlongLineSegment as o}from"../../../../geometry/lineUtils.js";import h from"../../../../../geometry/Point.js";import c from"../../../../../geometry/Polyline.js";import{getLength as i}from"../../../../../geometry/support/coordsUtils.js";function f(e){let t=0;const n=s(e.spatialReference);for(let s=0;s<e.paths.length;s++){const r=e.paths[s].length;for(let o=0;o<r;o++)o>0&&(t+=e.hasZ?a(e.paths[s][o-1],e.paths[s][o],n):i(e.paths[s][o-1],e.paths[s][o]))}return t}function l(e){const t=e.geometry.clone();return t.paths.map(s=>new c({spatialReference:e.geometry.spatialReference,paths:[s],hasZ:t.hasZ,hasM:t.hasM}))}function p(e){const t=[];for(const s of e.paths)for(let n=1;n<s.length;n++){const a=[[s[n-1].slice(),s[n].slice()]];t.push(new c({paths:a,spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM}))}return t}function u(e,t,s){const n=t[0],a=t[1],r=i(n,a),o=e.x+s*((t[1][0]-t[0][0])/r),c=e.y+s*((t[1][1]-t[0][1])/r),f={};return e.hasM&&(f.m=e.m),new h({x:o,y:c,spatialReference:e.spatialReference,...f})}function m(e,t,s,n){const r=t[0],o=t[1],c=a(r,o,n),i=e.x+s*((t[1][0]-t[0][0])/c),f=e.y+s*((t[1][1]-t[0][1])/c),l=e.z+s*((t[1][2]-t[0][2])/c),p={};return e.hasM&&(p.m=e.m),new h({x:i,y:f,z:l,spatialReference:e.spatialReference,...p})}function R(e,t,s){const n=t[0],a=t[1],r=[a[0]-n[0],a[1]-n[1]],o=Math.sqrt(r[0]**2+r[1]**2),h=[r[0]/o,r[1]/o];return e.x+=s*h[0],e.y+=s*h[1],e}function y(e,t,s){let a=0,r=null;if(t<=0){const n=[e.paths[0][0],e.paths[0][1]];let a=Z(e,0,0);return a=u(a,n,t),R(a,n,s)}const c=e.hasM?e.hasZ?3:2:-1;for(const u of e.paths)for(let f=0;f<u.length-1;f++){const l=i(u[f],u[f+1]),p=a+l;if(p===t)return r=new h({x:u[f+1][0],y:u[f+1][1],...e.hasM?{m:u[f+1][c]}:{},spatialReference:e.spatialReference}),0===s?r:R(r,[u[f],u[f+1]],s);if(p>t){const i=o(u[f],u[f+1],t-a);return r=new h({x:i[0],y:i[1],...c>-1?{m:n(u[f][c],u[f+1][c],l,t-a)??void 0}:{},spatialReference:e.spatialReference}),0===s?r:R(r,[u[f],u[f+1]],s)}a+=l}if(0===a)return null;const f=e.paths.length-1,l=e.paths[f].length-1,p=[e.paths[f][l-1],e.paths[f][l]];let m=Z(e,f,l);return m=u(m,p,t-a),R(m,p,s)}function g(e,s,o,c){let i=0;if(s<=0){const t=[e.paths[0][0],e.paths[0][1]];let n=Z(e,0,0);return n=m(n,t,s,c),R(n,t,o)}const f=e.hasM?e.hasZ?3:2:-1;for(const m of e.paths)for(let l=0;l<m.length-1;l++){const p=a(m[l],m[l+1],c),u=i+p;if(u===s){const t=new h({x:m[l+1][0],y:m[l+1][1],z:m[l+1][2],...e.hasM?{m:m[l+1][f]}:{},hasZ:!0,spatialReference:e.spatialReference});return 0===o?t:R(t,[m[l],m[l+1]],o)}if(u>s){const a=r(t(m[l]),t(m[l+1]),s-i,c),u=new h({x:a[0],y:a[1],z:a[2],...f>-1?{m:n(m[l][f],m[l+1][f],p,s-i)}:{},hasZ:!0,spatialReference:e.spatialReference});return 0===o?u:R(u,[m[l],m[l+1]],o)}i+=p}if(0===i)return null;const l=e.paths.length-1,p=e.paths[l].length-1,u=[e.paths[l][p-1],e.paths[l][p]];let y=Z(e,l,p);return y=m(y,u,s-i,c),R(y,u,o)}function M(e,t,s){const n=e.rings[t][s];return new h({spatialReference:e.spatialReference,x:n[0],y:n[1],hasZ:e.hasZ,hasM:e.hasM,z:e.hasZ?n[2]:void 0,m:e.hasM?e.hasZ?n[3]:n[2]:void 0})}function Z(e,t,s){const n=e.paths[t][s];return new h({spatialReference:e.spatialReference,x:n[0],y:n[1],hasZ:e.hasZ,hasM:e.hasM,z:e.hasZ?n[2]:void 0,m:e.hasM?e.hasZ?n[3]:n[2]:void 0})}function x(t){return e(t.at(0),t.at(-1))}export{f as computedTotalLength,l as convertRadialToPolylines,p as convertToTwoPoint,R as offsetPointFromSegment,y as pointAlongLineAndOffset,g as pointAlongLineWithZAndOffset,M as pointFromPolygonVertex,Z as pointFromPolylineVertex,x as sameStartEndPoint};
