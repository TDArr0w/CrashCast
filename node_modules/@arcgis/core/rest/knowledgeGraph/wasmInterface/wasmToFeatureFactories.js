/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{getKey as e}from"../../../core/object.js";import{ProtoFeatureCollection as t,ProtoInboundFeatureCollectionRequiredAttributes as a,Feature as s,Transform as r,Field as o,CompressedGeometry as n}from"../ProtoFeatureCollection.js";import{EsriGeometryTypes as l,EsriFieldTypes as i}from"./WasmDataModelWrapperInterfaces.js";import{WasmQuantizeOriginPositionTypeCode as c,SqlTypeCode as d}from"./WasmSerializedLayerData.js";function u(r){const o=new t;o.version=r.version;const n=r.get_query_result();if(0!==n.results_type.value)throw new Error("Got a non-feature collection type");const i=n.get_feature_result(),c=o.queryResult.featureResult;c.objectIdFieldName=i.objectid_field_name,c.exceededTransferLimit=i.exceeded_transfer_limit,c.hasM=i.has_m,c.hasZ=i.has_z,c.geometryType=e(l,i.geometry_type.value),c.globalIdFieldName=i.globalid_field_name,c.geohashFieldName=i.geohash_field_name;const d=c.uniqueIdField,u=i.unique_id_field;d.name=u.name,d.isSystemMaintained=u.isSystemMaintained;const _=c.geometryProperties,y=i.geometry_properties;_.shapeAreaFieldName=y.shapeAreaFieldName,_.shapeLengthFieldName=y.shapeLengthFieldName,_.units=y.units;const h=c.spatialReference,v=i.spatial_reference;h.wkid=v.wkid,h.latestWkid=v.latestWkid,h.vcsWkid=v.vcsWkid,h.latestVcsWkid=v.latestVcsWkid,h.wkt=v.wkt,c.transform=p(i.transform);const T=c.fields,w=c.fieldNameToAttributeIndexMap,z=i.fields,F=z.size();for(let e=0;e<F;e++){const t=z.get(e),a=f(t);T.push(a),w[a.name]=e,t.delete()}z.delete();const S=c.values,b=i.values_count();for(let e=0;e<b;e++)S.push(i.get_value_at(e));const k=c.features,q=i.features,W=q.size();if(W>0)for(const e of a)if(void 0===w[e])throw new Error(`Feature collection missing required attribute: ${e}`);for(let e=0;e<W;e++){const t=new s,a=q.get(e),r=t.attributes,o=a.attributes_count();for(let e=0;e<o;e++)r.push(a.get_attribute_at(e));const n=a.get_compressed_geometry();n&&(t.compressedGeometry=m(n),t.centroid=m(a.get_centroid()));const l=t.aggregateGeometries,i=a.aggregate_geometries,c=i.size();for(let e=0;e<c;e++){const t=i.get(e),a=m(t);l.push(a),t.delete()}i.delete(),k.push(t),a.delete()}q.delete();const x=c.geometryFields,N=i.geometry_fields,j=N.size();for(let e=0;e<j;e++){const t=N.get(e),a=g(t);x.push(a),t.delete()}return N.delete(),o}function m(t){const a=new n;a.geometryType=e(l,t.geometry_type.value);const s=[],r=[];for(let e=0;e<t.lengths.length;e++)s.push(t.lengths[e]);for(let e=0;e<t.coords.length;e++)r.push(t.coords[e]);return a.lengths=s,a.coords=r,a}function f(t){const a=new o;return a.name=t.name,a.alias=t.alias,a.fieldType=e(i,t.field_type.value),a.sqlType=e(d,t.sql_type.value),a.domain=t.domain,a.defaultValue=t.default_value,a}function g(t){const a=f(t);return a.geometryType=e(l,t.geometry_type.value),a}function p(t){const a=new r;a.quantizeOriginPosition=e(c,t.quantizeOriginPosition.value);const s=a.scale,o=t.scale;s.xScale=o.xScale,s.yScale=o.yScale,s.mScale=o.mScale,s.zScale=o.zScale;const n=a.translate,l=t.translate;return n.xTranslate=l.xTranslate,n.yTranslate=l.yTranslate,n.mTranslate=l.mTranslate,n.zTranslate=l.zTranslate,a}export{m as wasmToCompressedGeometry,f as wasmToField,g as wasmToGeometryField,u as wasmToProtoFeatureCollection,p as wasmToTransform};
