"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[5007],{4095:(t,e,n)=>{n.d(e,{CW:()=>u,DE:()=>f,S1:()=>p});var r=n(44208),o=n(53966),s=n(34727),i=n(74887),l=n(87811);n(5443),n(21325);const a=()=>o.A.getLogger("esri.views.2d.engine.flow.dataUtils"),c=10;async function u(t,e,n,o){const s=performance.now(),u=f(e,n),h=performance.now(),d=p(e,u,n.width,n.height),m=performance.now(),w=function(t){const e=new l.A,n=t.reduce((t,e)=>t+e.vertices.length,0),r=new Float32Array(4*n),o=new Array(t.length);let s=0,i=0;for(const{vertices:n}of t){const t=s;for(const t of n)r[4*s]=t.x,r[4*s+1]=t.y,r[4*s+2]=t.t,r[4*s+3]=t.speed,s++;o[i++]={startVertex:t,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:e.getFloat()}}return{lineVertices:r,lineDescriptors:o}}(d),g=performance.now(),y="Streamlines"===t?function(t,e){const{lineVertices:n,lineDescriptors:r}=t;let o=0,s=0;for(const t of r)o+=2*t.numberOfVertices,s+=6*(t.numberOfVertices-1);const i=new Float32Array(9*o),l=new Uint32Array(s);let a=0,c=0;function u(){l[c++]=a-2,l[c++]=a,l[c++]=a-1,l[c++]=a,l[c++]=a+1,l[c++]=a-1}function f(t,e,n,r,o,s,l,c){const u=9*a;let f=0;i[u+f++]=t,i[u+f++]=e,i[u+f++]=1,i[u+f++]=n,i[u+f++]=s,i[u+f++]=l,i[u+f++]=r/2,i[u+f++]=o/2,i[u+f++]=c,a++,i[u+f++]=t,i[u+f++]=e,i[u+f++]=-1,i[u+f++]=n,i[u+f++]=s,i[u+f++]=l,i[u+f++]=-r/2,i[u+f++]=-o/2,i[u+f++]=c,a++}for(const t of r){const{totalTime:r,timeSeed:o}=t;let s=null,i=null,l=null,a=null,c=null,h=null;for(let d=0;d<t.numberOfVertices;d++){const p=n[4*(t.startVertex+d)],m=n[4*(t.startVertex+d)+1],w=n[4*(t.startVertex+d)+2],g=n[4*(t.startVertex+d)+3];let y=null,M=null,v=null,x=null;if(d>0){y=p-s,M=m-i;const t=Math.sqrt(y*y+M*M);if(y/=t,M/=t,d>1){let t=y+c,n=M+h;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*y+n*M),e);t*=o,n*=o,v=-n,x=t}else v=-M,x=y;null!==v&&null!==x&&(f(s,i,l,v,x,r,o,g),u())}s=p,i=m,l=w,c=y,h=M,a=g}f(s,i,l,-h,c,r,o,a)}return{vertexData:i,indexData:l}}(w,c):function(t){const{lineVertices:e,lineDescriptors:n}=t;let r=0,o=0;for(const t of n){const e=t.numberOfVertices-1;r+=4*e*2,o+=6*e*2}const s=new Float32Array(16*r),i=new Uint32Array(o);let l,a,c,u,f,h,d,p,m,w,g,y,M,v,x=0,S=0;function b(){i[S++]=x-8,i[S++]=x-7,i[S++]=x-6,i[S++]=x-7,i[S++]=x-5,i[S++]=x-6,i[S++]=x-4,i[S++]=x-3,i[S++]=x-2,i[S++]=x-3,i[S++]=x-1,i[S++]=x-2}function D(t,e,n,r,o,i,l,a,c,u,f,h,d,p){const m=16*x;let w=0;for(const g of[1,2])for(const y of[1,2,3,4])s[m+w++]=t,s[m+w++]=e,s[m+w++]=n,s[m+w++]=r,s[m+w++]=l,s[m+w++]=a,s[m+w++]=c,s[m+w++]=u,s[m+w++]=g,s[m+w++]=y,s[m+w++]=d,s[m+w++]=p,s[m+w++]=o/2,s[m+w++]=i/2,s[m+w++]=f/2,s[m+w++]=h/2,x++}function A(t,e){let n=m+g,r=w+y;const o=Math.sqrt(n*n+r*r);n/=o,r/=o;const s=m*n+w*r;n/=s,r/=s;let i=g+M,x=y+v;const S=Math.sqrt(i*i+x*x);i/=S,x/=S;const A=g*i+y*x;i/=A,x/=A,D(l,a,c,u,-r,n,f,h,d,p,-x,i,t,e),b()}function E(t,e,n,r,o,s){if(m=g,w=y,g=M,y=v,null==m&&null==w&&(m=g,w=y),null!=f&&null!=h){M=t-f,v=e-h;const n=Math.sqrt(M*M+v*v);M/=n,v/=n}null!=m&&null!=w&&A(o,s),l=f,a=h,c=d,u=p,f=t,h=e,d=n,p=r}function F(t,e){m=g,w=y,g=M,y=v,null==m&&null==w&&(m=g,w=y),null!=m&&null!=w&&A(t,e)}for(const t of n){l=null,a=null,c=null,u=null,f=null,h=null,d=null,p=null,m=null,w=null,g=null,y=null,M=null,v=null;const{totalTime:n,timeSeed:r}=t;for(let o=0;o<t.numberOfVertices;o++)E(e[4*(t.startVertex+o)],e[4*(t.startVertex+o)+1],e[4*(t.startVertex+o)+2],e[4*(t.startVertex+o)+3],n,r);F(n,r)}return{vertexData:s,indexData:i}}(w),M=performance.now();return(0,r.A)("esri-2d-profiler")&&(a().info("I.1","_createFlowFieldFromData (ms)",Math.round(h-s)),a().info("I.2","_getStreamlines (ms)",Math.round(m-h)),a().info("I.3","createAnimatedLinesData (ms)",Math.round(g-m)),a().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(M-g)),a().info("I.5","createFlowMesh (ms)",Math.round(M-s)),a().info("I.6","Mesh size (bytes)",y.vertexData.buffer.byteLength+y.indexData.buffer.byteLength)),await Promise.resolve(),(0,i.Te)(o),y}function f(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),s=new Array(2*o+1);let i=0;for(let t=-o;t<=o;t++){const e=Math.exp(-t*t/(r*r));s[t+o]=e,i+=e}for(let t=-o;t<=o;t++)s[t+o]/=i;const l=new Float32Array(t.length);for(let r=0;r<n;r++)for(let n=0;n<e;n++){let i=0,a=0;for(let l=-o;l<=o;l++){if(n+l<0||n+l>=e)continue;const c=s[l+o];i+=c*t[2*(r*e+(n+l))],a+=c*t[2*(r*e+(n+l))+1]}l[2*(r*e+n)]=i,l[2*(r*e+n)+1]=a}const a=new Float32Array(t.length);for(let t=0;t<e;t++)for(let r=0;r<n;r++){let i=0,c=0;for(let a=-o;a<=o;a++){if(r+a<0||r+a>=n)continue;const u=s[a+o];i+=u*l[2*((r+a)*e+t)],c+=u*l[2*((r+a)*e+t)+1]}a[2*(r*e+t)]=i,a[2*(r*e+t)+1]=c}return a}(e.data,e.width,e.height,t.smoothing);return t.interpolate?(t,r)=>{const o=Math.floor(t),s=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(s<0||s>=e.height)return[0,0];const i=t-o,l=r-s,a=o,c=s,u=o<e.width-1?o+1:o,f=s<e.height-1?s+1:s,h=n[2*(c*e.width+a)],d=n[2*(c*e.width+u)],p=n[2*(f*e.width+a)],m=n[2*(f*e.width+u)],w=n[2*(c*e.width+a)+1],g=n[2*(c*e.width+u)+1];return[(h*(1-l)+p*l)*(1-i)+(d*(1-l)+m*l)*i,(w*(1-l)+n[2*(f*e.width+a)+1]*l)*(1-i)+(g*(1-l)+n[2*(f*e.width+u)+1]*l)*i]}:(t,r)=>{const o=Math.round(t),s=Math.round(r);return o<0||o>=e.width||s<0||s>=e.height?[0,0]:[n[2*(s*e.width+o)],n[2*(s*e.width+o)+1]]}}function h(t,e,n,r,o,i,l,a){const c=[],{raster:u,width:f,height:h,resolutionFactor:d}=a;let p=r,m=o,w=0,[g,y]=n(p,m);g*=e.velocityScale,y*=e.velocityScale;const M=Math.sqrt(g*g+y*y);let v,x;c.push({x:p,y:m,t:w,speed:M});for(let r=0;r<e.verticesPerLine;r++){let[r,o]=n(p,m);r*=e.velocityScale,o*=e.velocityScale;const a=Math.sqrt(r*r+o*o);if(a<e.minSpeedThreshold)return c;const g=t*r/a,y=t*o/a;if(p+=g*e.segmentLength,m+=y*e.segmentLength,e.wrapAround&&(p=(0,s.OS)(p,i[0])),w+=t*e.segmentLength/a,Math.acos(g*v+y*x)>e.maxTurnAngle)return c;if(e.collisions){let t=Math.round(p*d);const n=Math.round(m*d);if(e.wrapAround&&(t=(0,s.OS)(t,f)),t<0||t>f-1||n<0||n>h-1)return c;const r=u[n*f+t];if(-1!==r&&r!==l)return c;u[n*f+t]=l}c.push({x:p,y:m,t:w,speed:a}),v=g,x=y}return c}function d(t,e,n,r,o,s,i,l){const a=Math.round((.2+.6*i.getFloat())*t.verticesPerLine),c=t.verticesPerLine-a,u=h(-1,{...t,verticesPerLine:c},e,n,r,o,s,l),f=h(1,{...t,verticesPerLine:a},e,n,r,o,s,l),d=u.reverse();return d.splice(-1,1),d.concat(f)}function p(t,e,n,r,o={positions:[]}){if(t.density<=0)return[];const{positions:s}=o,i=[],a=new l.A,c=1/Math.max(t.lineCollisionWidth,1),u=Math.round(n*c),f=Math.round(r*c),p=new Int32Array(u*f);for(let t=0;t<p.length;t++)p[t]=-1;const m={raster:p,width:u,height:f,resolutionFactor:c},w={},g=t.lineSpacing/Math.sqrt(t.density),y=Math.floor(r/g),M=Math.floor(n/g);for(let t=0;t<y;t++){const e=t*g;for(let n=0;n<M;n++){const r=n*g;w[`${n}-${t}`]={x:r,y:e,positions:[]}}}for(const{x:t,y:e}of s){const n=w[`${Math.floor(t/g)}-${Math.floor(e/g)}`];n&&n.positions.push([t,e])}const v=[];for(const t in w){const e=w[t];if(0===e.positions.length)v.push({x:e.x+g/2,y:e.y+g/2,sort:.66+.33*a.getFloat(),stage:0});else{const[t]=e.positions.splice(0,1);v.push({x:t[0],y:t[1],sort:.33*a.getFloat(),stage:1});for(const[t,n]of e.positions)v.push({x:t,y:n,sort:.33+.33*a.getFloat(),stage:2})}}v.sort((t,e)=>t.sort-e.sort);for(const{x:o,y:s,stage:l}of v){const c=t.onlyForwardTracing?h(1,t,e,o,s,[n,r],i.length,m):d(t,e,o,s,[n,r],i.length,a,m);c.length<2||i.push({stage:l,vertices:c})}return i}},31635:(t,e,n)=>{function r(t,e,n,r){var o,s=arguments.length,i=s<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,n,r);else for(var l=t.length-1;l>=0;l--)(o=t[l])&&(i=(s<3?o(i):s>3?o(e,n,i):o(e,n))||i);return s>3&&i&&Object.defineProperty(e,n,i),i}function o(t,e,n){if(null!=e){if("object"!=typeof e&&"function"!=typeof e)throw new TypeError("Object expected.");var r,o;if(n){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");r=e[Symbol.asyncDispose]}if(void 0===r){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");r=e[Symbol.dispose],n&&(o=r)}if("function"!=typeof r)throw new TypeError("Object not disposable.");o&&(r=function(){try{o.call(this)}catch(t){return Promise.reject(t)}}),t.stack.push({value:e,dispose:r,async:n})}else n&&t.stack.push({async:!0});return e}n.d(e,{Cg:()=>r,hk:()=>i,mS:()=>o}),Object.create,Object.create;var s="function"==typeof SuppressedError?SuppressedError:function(t,e,n){var r=new Error(n);return r.name="SuppressedError",r.error=t,r.suppressed=e,r};function i(t){function e(e){t.error=t.hasError?new s(e,t.error,"An error was suppressed during disposal."):e,t.hasError=!0}var n,r=0;return function o(){for(;n=t.stack.pop();)try{if(!n.async&&1===r)return r=0,t.stack.push(n),Promise.resolve().then(o);if(n.dispose){var s=n.dispose.call(n.value);if(n.async)return r|=2,Promise.resolve(s).then(o,function(t){return e(t),o()})}else r|=1}catch(t){e(t)}if(1===r)return t.hasError?Promise.reject(t.error):Promise.resolve();if(t.hasError)throw t.error}()}},35007:(t,e,n)=>{n.r(e),n.d(e,{default:()=>c});var r=n(31635),o=(n(53966),n(44208),n(87811),n(49186),n(64108)),s=n(4095),i=n(19419);n(73941);var l=n(69052);n(21325);let a=class{constructor(){this._tileData=new Map}async generateStreamlines(t){const{flowData:e,flowExtentInfo:n,needsMagnitude:r,simulationSettings:o,startPositions:i}=t,l=u((0,s.DE)(o,e),o,n.modelSize,r,i);return{result:{streamlines:l},transferList:l?.map(t=>t.vertices.buffer)}}async generateTiledStreamlines(t){const{flowDataTiles:e,flowExtentInfo:n,needsMagnitude:r,reset:o,simulationSettings:a,startPositions:c}=t;this._updateTileData(e,o);const f=u(function(t,e,n){const[r,o]=n.modelSize;let a=null;const c=new Map;e.forEach(e=>{c.set(e.lij,(0,s.DE)(t,e))});const u=(t,e,n)=>(0,i.Rj)(t.extent,e,n);return(s,f)=>{const h=Math.round(s),d=Math.round(f);if(!t.wrapAround&&(h<0||h>=r||d<0||d>=o))return[0,0];const[p,m]=function(t,e,n,r){const{extent:o,modelSize:s,valid:a}=t,[c,u,f]=o,h=function(t,e,n){if(null!=n&&t>e){const[r,o]=n;return o-t+(e-r)}return e-t}(c,f,a);let d=e/s[0]*h+c;return null!=a&&r&&(d=new l.hr(a[0],a[1]).normalize(d)),[d,(s[1]-n)/s[1]*(0,i.uJ)(o)+u]}(n,s,f,!0);if(!function(t,e,n){const{extent:r,valid:o}=t,[s,i,l,a]=r;return!(n<i||n>a)&&(null!=o&&s>l?e>=l||e<=s:e>=s&&e<=l)}(n,p,m))return[0,0];if(null==a||!u(a,p,m)){a=null;for(const[t,n]of e)if(u(n,p,m)){a=n;break}}if(null==a?.data)return[0,0];const w=c.get(a.lij);if(null==w)return[0,0];const{width:g,height:y,extent:M}=a;return w((p-M[0])/(0,i.VL)(M)*g,y-(m-M[1])/(0,i.uJ)(M)*y)}}(a,this._tileData,n),a,n.modelSize,r,c);return{result:{streamlines:f},transferList:f?.map(t=>t.vertices.buffer)??[]}}_updateTileData(t,e){e&&this._tileData.forEach((e,n)=>{null==t.get(n)&&this._tileData.delete(n)}),t.forEach((t,e)=>{"delete"===t.type?this._tileData.delete(e):"on-worker"!==t.type&&"waiting"!==t.type&&this._tileData.set(e,t.data)})}};a=(0,r.Cg)([(0,o.$)("esri.views.3d.support.flow.FlowWorker")],a);const c=a;function u(t,e,n,r,o){if(null==t)return;const i=(0,s.S1)(e,t,n[0],n[1],{positions:o}),l=[],a=function(t){return t?4:3}(r);for(const{vertices:t,stage:e}of i){const n=new Float32Array(t.length*a);for(let e=0;e<t.length;e++)n[e*a]=t[e].x,n[e*a+1]=t[e].y,n[e*a+2]=t[e].t,r&&(n[e*a+3]=t[e].speed);l.push({vertices:n,stage:e,hasMagnitude:r})}return l}},69052:(t,e,n)=>{n.d(e,{hr:()=>o,ie:()=>a,uC:()=>l});var r=n(34727);class o{constructor(t,e){this.min=t,this.max=e,this.range=e-t}normalize(t,e=0,n=!1){return s(this.range,this.min,this.max,t,e,n)}clamp(t,e=0){return(0,r.qE)(t-e,this.min,this.max)+e}monotonic(t,e,n){return t<e?e:e+i(this.range,t-e,n)}minimalMonotonic(t,e,n){return s(this.range,t,t+this.range,e,n)}center(t,e,n){return e=this.monotonic(t,e,n),this.normalize((t+e)/2,n)}diff(t,e,n){return this.monotonic(t,e,n)-t}shortestSignedDiff(t,e){t=this.normalize(t);const n=(e=this.normalize(e))-t,r=e<t?this.minimalMonotonic(t,e)-t:e-this.minimalMonotonic(e,t);return Math.abs(n)<Math.abs(r)?n:r}contains(t,e,n){return e=this.minimalMonotonic(t,e),(n=this.minimalMonotonic(t,n))>t&&n<e}}function s(t,e,n,r,o=0,s=!1){return(r-=o)<e?r+=i(t,e-r):r>n&&(r-=i(t,r-n)),s&&r===n&&(r=e),r+o}function i(t,e,n=0){return Math.ceil((e-n)/t)*t+n}const l=new o(0,2*Math.PI),a=(new o(-Math.PI,Math.PI),new o(0,360))}}]);