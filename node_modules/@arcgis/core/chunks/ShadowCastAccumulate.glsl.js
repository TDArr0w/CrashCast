/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{ScreenSpacePass as e}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{calculateUVZShadowFromDepthPass as a}from"../views/3d/webgl-engine/core/shaderLibrary/shading/calculateUVZShadowFromDepth.glsl.js";import{ShadowmapFiltering as o}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ShadowmapFiltering.glsl.js";import{glsl as s}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DBindUniform as d}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{Texture2DShadowBindUniform as r}from"../views/3d/webgl-engine/core/shaderModules/Texture2DShadowBindUniform.js";import{ShaderBuilder as t}from"../views/webgl/ShaderBuilder.js";const n=255,i=1/n;function l(n){const l=new t,{fragment:p}=l;l.include(e),l.include(a),l.include(o),p.uniforms.add(new r("shadowMap",e=>e.shadowMap.depthTexture),new d("depthMap",e=>e.depth?.attachment)),p.constants.add("sampleValue","float",i);const u=1===n.index?"vec2":"float";return l.outputs.add("sampleCount",u),p.main.add(s`
    sampleCount = ${u}(0.0);

    vec3 uvzShadow = calculateUVZShadowFromDepth(uv, textureSize(shadowMap,0), depthMap);
    if (uvzShadow.z < 0.0) {
      return;
    }

    // The shadow map sampler returns a value between 0 and 1, we take the midpoint as we count discrete samples
    bool shadow = readShadowMapUVZ(uvzShadow, shadowMap) > 0.5;

    if (shadow) {
      sampleCount = ${u}(sampleValue); // Add 1 to the sample count
    }
  `),l}const p=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastMaxSamples:n,build:l},Symbol.toStringTag,{value:"Module"}));export{n as S,p as a,l as b};
