/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{radiusModifier as e}from"../geometry/ellipsoidUtils.js";import{earth as r,mars as o,moon as a}from"../geometry/support/Ellipsoid.js";import{ComponentData as i}from"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js";import{ForwardLinearDepthToWriteShadowMap as l}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepthToWriteShadowMap.glsl.js";import{isColorOrColorEmission as t}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SlicePass as n}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{TextureCoordinateAttribute as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VertexPosition as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js";import{OutputDepth as c}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as v}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{OutputHighlightOverlay as u}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlightOverlay.js";import{ReadDepth as h}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{computeFragmentNormals as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeFragmentNormals.glsl.js";import{ComputeMaterialColor as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js";import{ComputeNormalTexture as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{EvaluateSceneLighting as f,addLightingGlobalFactor as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as y,addMainLightDirection as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{PhysicallyBasedRenderingParameters as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadBaseColorTexture as j}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js";import{ReadShadowMapPass as S}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as $}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{OverlayIM as N}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js";import{DiscardOrAdjustAlphaDraw as O}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{If as T,glsl as D}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DBindUniform as M}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{SnowCover as A}from"../views/3d/webgl-engine/effects/weather/SnowCover.glsl.js";import{outputColorHighlightOID as W}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{sphereDepthInterpolate as P}from"../views/3d/webgl-engine/shaders/SphereDepthInterpolate.glsl.js";import{ShaderBuilder as R}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as z}from"../webscene/support/AlphaCutoff.js";function F(F){const B=new R,{vertex:_,fragment:I}=B;B.include(m,F),B.include(g,F),B.include(s,F),B.include(d,F),B.include(i,F),B.include(O,F),I.include(n,F),B.include(j,F),B.include($,F);const{output:E,pbrMode:H,hasNormalTexture:V,snowCover:G,receiveShadows:k,shadeNormals:U,spherical:q,ellipsoidMode:J,overlayEnabled:K,componentData:Q,vertexDiscardMode:X,renderOccluded:Y}=F,Z=1===H||2===H;Z&&(B.include(L,F),V&&B.include(b,F));const ee=4===E||5===E||6===E,re=ee&&1===Q,oe=1===J,ae=1===J?r.radius:oe?o.radius:a.radius;K&&(B.include(f,F),B.include(N,F),_.code.add(`\n      ${T(q,`const float invRadius = ${D.float(1/ae)};`)}\n      vec2 projectOverlay(vec3 pos) { return pos.xy ${T(q,"/ (1.0 + invRadius * pos.z);")}; }`));const ie=K&&t(E)&&4===H;ie&&(B.varyings.add("tbnTangent","vec3"),B.varyings.add("tbnBiTangent","vec3"),B.varyings.add("groundNormal","vec3"));const le=0===X,te=2===X,ne=1-1/255;if(B.include(S,F),B.include(l,F),_.main.add(D`
    bool castShadows;
    vec4 externalColor = forwardExternalColor(castShadows);
    ${T(re,"if(!castShadows) { gl_Position = vec4(vec3(1e38), 1.0); return; }")}

    ${T(!le,`{ if (externalColor.a ${te?">":"<="} ${D.float(ne)}) { gl_Position = vec4(vec3(1e38), 1.0); return; } }`)}

    ${T(10===E,"externalColor.a = 1.0;")}

    forwardPosition(readElevationOffset());
    forwardViewPosDepth(vPosition_view);
    forwardNormal();
    forwardTextureCoordinates();
    forwardVertexColor();
    forwardLinearDepthToReadShadowMap();
    forwardLinearDepthToWriteShadowMap();
    forwardEmissiveStrength();
    forwardObjectAndLayerIdColor();
    ${T(ie,q?D`
            groundNormal = normalize(positionWorld());
            tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
            tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:D`
            groundNormal = vec3(0.0, 0.0, 1.0);
            tbnTangent = vec3(1.0, 0.0, 0.0);
            tbnBiTangent = vec3(0.0, 1.0, 0.0);`)}
    ${T(K,"setOverlayVTC(projectOverlay(position));")}

    if (externalColor.a < ${D.float(z)}) {
      // Discard this vertex
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    }
  `),t(E))return B.include(p,F),B.include(w,F),B.include(f,F),B.include(W,F),I.include(A,F),I.code.add(D`
      float evaluateShadow() {
        return ${k?"readShadowMap(vPositionWorldCameraRelative, linearDepth)":"0.0"};
      }`),I.main.add(D`
      discardBySlice(vPositionWorldCameraRelative);
      discardByTerrainDepth();

      vec4 textureColor = readBaseColorTexture();
      discardOrAdjustAlpha(textureColor);

      /* When rendering the occluded overlay, we still need to read the base color texture
       * because we need to use the same discard logic. However after that to render only the
       * draped overlay, we simply set the base texture color to zero. */
      ${T(Y,D`textureColor = vec4(0);`)}

      ${T(K,D`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`)}

      /* Early discard to only emit when we have overlay */
      ${T(K&&Y,D`if (overlayColor.a < ${D.float(z)}) { discard; }`)}

      vec4 externalColor;
      int externalColorMixMode;
      readExternalColor(externalColor, externalColorMixMode);

      vec4 materialColor = computeMaterialColor(textureColor, externalColor, externalColorMixMode);
    `),Z?(y(I),q&&C(I),I.main.add(D`
        applyPBRFactors();
        ${T(1===H,D`if (externalColorMixMode == 3) {
              mrr = vec3(0.0, 0.6, 0.2);
            }`)}
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
        ${T(V,"mat3 tangentSpace = computeTangentSpace(fragmentFaceNormal, vPositionWorldCameraRelative, vuv0);")}
        vec3 shadingNormal = ${V?"computeTextureNormal(tangentSpace, vuv0)":"fragmentShadingNormal"};
        vec3 groundNormal = ${q?D`normalize(positionWorld())`:D`vec3(0.0, 0.0, 1.0)`};

        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * evaluateAmbientOcclusionInverse();
        ${T(G,D`float snow = getSnow(fragmentFaceNormal, normalize(positionWorld()));
                 materialColor.rgb = mix(materialColor.rgb, vec3(1.1), snow);
                 ssao = mix(ssao, 0.5 * ssao, snow);
                 shadingNormal = mix(shadingNormal, fragmentFaceNormal, snow);`)}
        ${T(K,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        ${T(q,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        ${q?D`float shadow = max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow());`:"float shadow = evaluateShadow();"}
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, shadow, ssao, additionalLight, viewDir, groundNormal, mrr, additionalIrradiance), materialColor.a);
        `)):(x(I),q&&C(I),ie&&I.uniforms.add(new M("ovNormalTex",e=>e.overlay?.getTexture(3))),I.main.add(D`
        ${T(q,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        float shadow = ${k?q?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow())":"evaluateShadow()":q?"lightingGlobalFactor * (1.0 - additionalAmbientScale)":"0.0"};

        ${T(k&&!U,D`
            float dotFL = dot(fragmentFaceNormal, mainLightDirection);
            if( dotFL <= 0.0) shadow = 1.0;
        `)}
        ${T(G,D`float snow = getSnow(fragmentFaceNormal, normalize(positionWorld()));
               materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)}

        // At global scale we create some additional ambient light based on the main light to simulate global illumination
        float ssao = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());

        ${T(K,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec4 shadedColor = vec4(evaluateSceneLighting(fragmentShadingNormal, materialColor.rgb, shadow, ssao, additionalLight), materialColor.a);
        ${T(ie,D`vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
                 float waterNormalLength = length(overlayWaterMask);
                 if (waterNormalLength > 0.95) {
                   mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                   vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                   vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                   // un-gamma the ground color to mix in linear space
                   shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
                 }`)}
      `)),I.main.add(`outputColorHighlightOID(shadedColor, vPositionWorldCameraRelative, materialColor.rgb ${T(G,", snow")});`),F.sphereDepthInterpolate&&(B.include(P,{radius:ae*e}),B.fragment.include(h),I.main.add(D`if (sphereFade()>0.0) {
vec3 worldRay = normalize(vPositionWorldCameraRelative);
vec3 viewRay = normalize(vPosition_view);
gl_FragDepth = delinearizeDepth(sphereDepthInterpolate(worldRay, viewRay, linearizeDepth(gl_FragCoord.z)));
} else {
gl_FragDepth = gl_FragCoord.z;
}`)),B;const de=3===E,se=10===E,ge=9===E,me=ee||7===E||8===E;return me&&B.include(c,F),de&&B.include(w,F),K&&B.include(u,F),B.include(v,F),I.main.add(D`
    discardBySlice(vPositionWorldCameraRelative);

    vec4 textureColor = readBaseColorTexture();
    discardOrAdjustAlpha(textureColor);

    ${T(me,"outputDepth(linearDepth);")}
    ${T(de,D`fragColor = vec4(vec3(0.5) + 0.5 * fragmentFaceNormalView, 1.0);`)}
    ${T(se,K?"fragColor = getOverlayColorTexel();":"outputObjectAndLayerIdColor();")}
    ${T(ge,T(K,D`calculateOcclusionAndOutputHighlight(getAllOverlayHighlightValuesEncoded());`,D`calculateOcclusionAndOutputHighlight();`))}`),B}const B=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:"Module"}));export{B as C,F as b};
