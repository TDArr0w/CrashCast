/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isColorOrColorEmission as e}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as r}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as i}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as o}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{OutputHighlight as a}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientLighting as t}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js";import{addMainLightDirection as n,addMainLightIntensity as s}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{NormalUtils as l}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{ReadShadowMapDraw as d}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as g}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{Water as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js";import{WaterDistortion as c}from"../views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl.js";import{ColorConversion as v}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as p,addCameraPosition as w}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float4PassUniform as u}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as f}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as h}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{outputColorHighlightOID as b}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as y}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as j}from"../webscene/support/AlphaCutoff.js";function L(L){const C=new y,{vertex:P,fragment:x,varyings:S}=C,{output:O,draped:D,receiveShadows:M}=L;p(P,L),C.include(i),C.attributes.add("position","vec3"),C.attributes.add("uv0","vec2");const _=new u("waterColor",e=>e.color);if(S.add("vpos","vec3",{invariant:!0}),P.uniforms.add(_),e(O)){if(D)return P.main.add(h`
      if (waterColor.a < ${h.float(j)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      vpos = position;
      gl_Position = transformPosition(proj, view, vpos);`),x.uniforms.add(_),x.main.add(h`fragColor = waterColor;`),C;C.include(l,L),S.add("vuv","vec2"),S.add("vnormal","vec3"),S.add("vtbnMatrix","mat3"),P.main.add(h`
      if (waterColor.a < ${h.float(j)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      vuv = uv0;
      vpos = position;

      vnormal = getLocalUp(vpos, localOrigin);
      vtbnMatrix = getTBNMatrix(vnormal);
      forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);

      gl_Position = transformPosition(proj, view, vpos);
      forwardLinearDepthToReadShadowMap();`)}switch(C.include(d,L),C.include(g,L),O){case 0:case 1:C.include(t,{pbrMode:0,lightingSphericalHarmonicsOrder:2}),C.include(c),C.include(m,L),x.include(r,L),C.include(b,L),x.include(v),w(x,L),n(x),s(x),x.uniforms.add(_,new f("timeElapsed",({timeElapsed:e})=>e),P.uniforms.get("view"),P.uniforms.get("localOrigin")).main.add(h`
        discardBySlice(vpos);
        discardByTerrainDepth();
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${M?h`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        fragColor = delinearizeGamma(final);
        outputColorHighlightOID(fragColor, vpos, final.rgb);`);break;case 3:C.include(l,L),C.include(c,L),x.include(r,L),S.add("vuv","vec2"),P.main.add(h`
        if (waterColor.a < ${h.float(j)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        gl_Position = transformPosition(proj, view, vpos);`),x.uniforms.add(new f("timeElapsed",({timeElapsed:e})=>e)).main.add(h`discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
fragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);`);break;case 9:C.include(a,L),P.main.add(h`
        if (waterColor.a < ${h.float(j)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);`),x.include(r,L),x.main.add(h`discardBySlice(vpos);
calculateOcclusionAndOutputHighlight();`);break;case 10:C.include(o,L),P.main.add(h`
        if (waterColor.a < ${h.float(j)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
        forwardObjectAndLayerIdColor();`),x.include(r,L),x.main.add(h`discardBySlice(vpos);
outputObjectAndLayerIdColor();`)}return C}const C=Object.freeze(Object.defineProperty({__proto__:null,build:L},Symbol.toStringTag,{value:"Module"}));export{C as W,L as b};
