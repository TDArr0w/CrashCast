/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{ZEROS as e}from"../core/libs/gl-matrix-2/factories/vec2f64.js";import{ZEROS as n}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{terrainDepthTest as a}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{ComputeCovariance as i}from"../views/3d/webgl-engine/core/shaderLibrary/util/ComputeCovariance.glsl.js";import{GaussianSplatUnpacking as t}from"../views/3d/webgl-engine/core/shaderLibrary/util/GaussianSplatUnpacking.glsl.js";import{QuaternionToRotationMatrix as o}from"../views/3d/webgl-engine/core/shaderLibrary/util/QuaternionToRotationMatrix.glsl.js";import{Float2PassUniform as r}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float3BindUniform as s}from"../views/3d/webgl-engine/core/shaderModules/Float3BindUniform.js";import{Float3PassUniform as c}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as l}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as d,If as u}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{IntegerBindUniform as p}from"../views/3d/webgl-engine/core/shaderModules/IntegerBindUniform.js";import{IntegerPassUniform as v}from"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js";import{Matrix4BindUniform as m}from"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js";import{Texture2DUintPassUniform as f}from"../views/3d/webgl-engine/core/shaderModules/Texture2DUintPassUniform.js";import{NoParameters as g}from"../views/webgl/NoParameters.js";import{ShaderBuilder as h}from"../views/webgl/ShaderBuilder.js";class x extends g{constructor(){super(...arguments),this.totalGaussians=-1,this.focalLength=-1,this.minSplatRadius=-1,this.minSplatOpacity=-1,this.tanFov=e,this.cameraDelta=n,this.cameraPos8k=n}}function w(e){const n=new h;n.varyings.add("vColor","vec4"),n.varyings.add("conicOpacity","vec4"),n.varyings.add("depth","float"),n.varyings.add("gaussianCenterScreenPos","vec2"),n.varyings.add("fragScreenPos","vec2"),n.outputs.add("fragColor","vec4",0),n.vertex.uniforms.add(new f("splatOrderTexture",e=>e.splatOrder),new f("splatAtlasTexture",e=>e.splatAtlas),new v("numSplats",e=>e.totalGaussians),new l("focalLength",e=>e.focalLength),new l("minSplatRadius",e=>e.minSplatRadius),new l("minSplatOpacity",e=>e.minSplatOpacity),new r("tanFov",e=>e.tanFov),new c("cameraDelta",e=>e.cameraDelta),new c("cameraPos8k",e=>e.cameraPos8k),new p("fullWidth",({camera:e})=>e.viewport[2]),new p("fullHeight",({camera:e})=>e.viewport[3]),new m("proj",e=>e.camera.projectionMatrix),new m("view",e=>e.camera.viewMatrix),new s("cameraPosition",e=>e.camera.eye)),n.vertex.include(t),n.vertex.include(o),n.vertex.include(i),n.include(a,e),n.vertex.code.add(d`float ndcToPixel(float ndcCoord, float screenSize) {
return ((ndcCoord + 1.0) * screenSize - 1.0) * 0.5;
}`),n.vertex.main.add("\n    uint instanceID = uint(gl_InstanceID);\n\n    // Transform the instanceID into 2D coordinates\n    uint orderTextureWidth = uint(textureSize(splatOrderTexture, 0).x);\n    uint x = instanceID % orderTextureWidth;\n    uint y = instanceID / orderTextureWidth;\n\n    // Fetch the index of the remaining frontmost Gaussian\n    uint gaussianIndex = texelFetch(splatOrderTexture, ivec2(x, y), 0).r;\n\n    uint splatAtlasSize = uint(textureSize(splatAtlasTexture, 0).x);\n\n    // Fetch the packed Gaussian according to the index\n    uint gaussianIndexX = gaussianIndex % uint(splatAtlasSize);\n    uint gaussianIndexY = gaussianIndex / uint(splatAtlasSize);\n    uvec4 packedGaussian = texelFetch(splatAtlasTexture, ivec2(gaussianIndexX, gaussianIndexY), 0);\n\n    // Fetch the header associated with the packed Gaussian (contains tile origin and number of fractional bits)\n    uint pageNum = gaussianIndex / 1024u;\n    uint headerIndex = (pageNum + 1u) * 1024u - 1u;\n    uint headerIndexX = headerIndex % uint(splatAtlasSize);\n    uint headerIndexY = headerIndex / uint(splatAtlasSize);\n    uvec4 packedHeader = texelFetch(splatAtlasTexture, ivec2(headerIndexX, headerIndexY), 0);\n\n    // Unpack the Gaussian\n    vColor = unpackColor(packedGaussian);\n    // Ignore gaussians with very small contribution, with tolerance based on the quality profile\n    if(vColor.a < minSplatOpacity) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    vec3 scale = unpackScale(packedGaussian); \n    vec4 quaternion = unpackQuaternion(packedGaussian);\n    mat3 rotation = quaternionToRotationMatrix(quaternion);\n    vec3 tileOriginRelativePosition = unpackTileOriginRelativePosition(packedGaussian);\n\n    vec3 cameraRelativePosition = unpackCameraRelativeGaussianPosition(packedHeader, tileOriginRelativePosition, cameraPosition, cameraPos8k, cameraDelta);\n\n    vec4 viewPos = vec4(mat3(view) * cameraRelativePosition, 1);\n\n    if (viewPos.z > 1.0) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    forwardViewPosDepth(viewPos.xyz);\n\n    vec3 covarianceA;\n    vec3 covarianceB;\n    computeCovariance3D(rotation, scale.xyz, covarianceA, covarianceB);\n\n    float covariance3D[6] = float[6](covarianceA.x, covarianceA.y, covarianceA.z, covarianceB.x, covarianceB.y, covarianceB.z);\n\n    vec3 covariance2D = computeCovariance2D(viewPos.xyz, focalLength, tanFov, covariance3D, view);\n    \n    // Invert covariance (EWA algorithm)\n    float determinant = (covariance2D.x * covariance2D.z - covariance2D.y * covariance2D.y);\n    if (determinant == 0.) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n    float invDeterminant = 1. / determinant;\n    \n\n    vec4 projPos = proj * viewPos;\n    float invW = 1. / (projPos.w + 1e-7);\n    vec3 ndcPos = projPos.xyz * invW;\n\n    // Compute extent in screen space (by finding the eigenvalues of the 2D covariance matrix). \n    // Use the extent to compute the bounding rectangle of the Gaussian in screen space.\n    float mid = 0.5 * (covariance2D.x + covariance2D.z);\n    float lambda1 = mid + sqrt(max(0.1, mid * mid - determinant));\n    float lambda2 = mid - sqrt(max(0.1, mid * mid - determinant));\n    float radius = ceil(3. * sqrt(max(lambda1, lambda2)));\n    gaussianCenterScreenPos = vec2(ndcToPixel(ndcPos.x, float(fullWidth)), ndcToPixel(ndcPos.y, float(fullHeight)));\n\n    // Ignore gaussians with very small contribution, with tolerance based on the quality profile\n    if(minSplatRadius > 0.0) {\n      float effectiveSize = radius * vColor.a;\n      if(effectiveSize < minSplatRadius) {\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n    }\n\n    // This maps vertex IDs 0, 1, 2, 3 to (-1,-1), (1,-1), (-1,1), (1,1)\n    vec2 corner = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) - 1.0;\n\n    // Vertex (corner) position in screen space\n    fragScreenPos = gaussianCenterScreenPos + radius * corner;\n\n    // We use a conic function to derive the opacity\n    vec3 conic = vec3(covariance2D.z, -covariance2D.y, covariance2D.x) * invDeterminant;\n    conicOpacity = vec4(conic, vColor.a);\n\n    depth = ndcPos.z;\n    \n    // Convert from screen-space to clip-space\n    vec2 clipPos = fragScreenPos / vec2(fullWidth, fullHeight) * 2. - 1.;\n\n    gl_Position = vec4(clipPos, depth, 1.0);\n\n  ");const g=e.depthPass;return n.fragment.main.add(`\n    discardByTerrainDepth();\n    vec2 offsetFromCenter = gaussianCenterScreenPos - fragScreenPos;\n\n    // Evaluate the 2D elliptical Gaussian exponent using the general conic form: Ax^2+2Bxy+Cy^2\n    float x = offsetFromCenter.x;\n    float y = offsetFromCenter.y;\n    float A = conicOpacity.x;\n    float B = conicOpacity.y;\n    float C = conicOpacity.z;\n    float opacityScale = conicOpacity.w;\n    float gaussianExponent = -0.5 * (A * x * x + 2.0 * B * x * y + C * y * y);\n\n    // A positive exponent indicates alpha > 1, this should not happen\n    if (gaussianExponent > 0.0) {\n      discard;\n    }\n\n    float gaussianFalloff = exp(gaussianExponent);\n    \n      // cap at 0.99 to avoid blending issues, such as seams between overlapping Gaussians\n    float alpha = min(.99f, opacityScale * gaussianFalloff);\n\n    // discard low alpha fragments since their contribution would not be visible\n    if (alpha < 1./255.) {\n        discard;\n    }\n\n    // We cannot write color and depth in the same pass, as they require different blend modes.\n    // Regular depth writing based on first hit is not precise enough due to the inherently \n    // transparent nature of Gaussian Splats (especially at the borders of the Splat).\n    // We thus use a blended depth that computes a non-linear average using \n    // the splat order and opacity with geometric decay.\n    // This means the depth is averaged based on the order and opacity of the Gaussians,\n    // with the frontmost Gaussians contributing the most.\n    ${u(g,"fragColor = vec4(depth, 0, 0, alpha);","fragColor = vec4(vColor.rgb * alpha, alpha);")}\n  `),n}const y=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatPassParameters:x,build:w},Symbol.toStringTag,{value:"Module"}));export{x as G,y as a,w as b};
