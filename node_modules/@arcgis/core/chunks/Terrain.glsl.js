/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{translate as e}from"../core/libs/gl-matrix-2/math/mat4.js";import{create as r}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{n as o,j as a}from"./vec32.js";import{create as i}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{addLinearDepth as l}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{addNearFar as t}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepthToWriteShadowMap.glsl.js";import{SliceDraw as n}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as s}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{NormalAttribute as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexTangent as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js";import{OutputDepth as v}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as g}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{OutputHighlightOverlay as p}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlightOverlay.js";import{EvaluateAmbientOcclusion as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as f,addAmbientBoostFactor as w,addLightingGlobalFactor as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightDirection as h,addMainLightIntensity as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{NormalUtils as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{ReadShadowMapDraw as j}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{OverlayTerrain as x}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js";import{OverlayTerrainPassParameters as L,TerrainTexture as O}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js";import{addProjViewLocalOrigin as T,addViewNormal as M,addCameraPosition as P}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3BindUniform as $}from"../views/3d/webgl-engine/core/shaderModules/Float3BindUniform.js";import{If as z,glsl as S}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Matrix4DrawUniform as N}from"../views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js";import{Texture2DBindUniform as F}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{ShaderBuilder as D}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as _}from"../webscene/support/AlphaCutoff.js";class A extends L{}function V(r){const i=new D,{attributes:L,vertex:A,fragment:V,varyings:B}=i;L.add("position","vec3"),i.include(d,r),i.include(c,r);const k=()=>{i.include(C,r),A.code.add(S`vec3 getNormal() {
float z = 1.0 - abs(normalCompressed.x) - abs(normalCompressed.y);
vec3 n = vec3(normalCompressed + vec2(normalCompressed.x >= 0.0 ? 1.0 : -1.0,
normalCompressed.y >= 0.0 ? 1.0 : -1.0) * min(z, 0.0), z);
return normalize(n);
}`)};T(A,r),i.include(s);const{output:H,pbrMode:E,overlayMode:q,tileBorders:I,spherical:R,transparencyMode:G,overlayEnabled:J}=r,K=2===G||3===G,Q=J&&K;switch(H){case 1:case 0:{i.include(O,r),i.include(f,r),J&&(r.pbrMode=5===E?6:3,i.include(x,r),r.pbrMode=E);const l=2===q;l&&i.include(m,r),B.add("vnormal","vec3"),B.add("vpos","vec3",{invariant:!0}),B.add("vup","vec3"),k(),A.main.add(S`
          vpos = position;
          vec3 positionWorld = position + localOrigin;
          gl_Position = transformPosition(proj, view, vpos);
          vnormal = getNormal();
          vup = getLocalUp(position, localOrigin);
          ${z(l,S`forwardVertexTangent(vnormal);`)}

          forwardTextureCoordinatesWithTransform(uv0);
          ${z(J,"setOverlayVTC(uv0);")}
          ${z(I,"forwardTextureCoordinates();")}
          forwardLinearDepthToReadShadowMap();`),i.include(j,r),V.include(n,r),i.include(f,r),V.include(u,r),P(V,r),w(V),b(V),V.uniforms.add(A.uniforms.get("localOrigin"),new $("viewDirection",({camera:e})=>o(U,a(U,e.viewMatrix[12],e.viewMatrix[13],e.viewMatrix[14])))),l&&V.uniforms.add(new F("ovWaterTex",e=>e.overlay?.getTexture(3)),new N("view",({origin:r},{camera:o})=>e(W,o.viewMatrix,r)));const t=.2;V.code.add(S`float lum(vec3 c) {
return (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;
}`),h(V),y(V),V.main.add(S`
          vec3 normal = normalize(vnormal);
          float vndl = dot(normal, mainLightDirection);

          float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));
          float shadow = readShadow(additionalAmbientScale, vpos);
          float ssao = evaluateAmbientOcclusionInverse();
          vec4 tileColor = getTileColor();

          ${z(J,S`vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
                   vec4 overlayColor = overlayOpacity * overlayColorOpaque;
                   ${z(K,`if (overlayColor.a < ${S.float(_)}) { discard; }`)}
                   vec4 groundColor = tileColor;
                   tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;`)}

          // If combined alpha is 0 we can discard pixel. The performance impact by having a discard here
          // is neglectable because terrain typically renders first into the framebuffer.
          if(tileColor.a < ${S.float(_)}) {
            discard;
          }

          bool sliced = rejectBySlice(vpos);
          if (sliced) {
            tileColor *= ${S.float(t)};
          }

          vec3 albedo = tileColor.rgb;

          // heuristic shading function used in the old terrain, now used to add ambient lighting

          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

          ${5===E||6===E?S`fragColor = vec4(evaluatePBRSimplifiedLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight, normalize(vpos - cameraPosition), vup), tileColor.a);`:S`fragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);`}
          ${z(l,S`vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);
                   float waterNormalLength = length(overlayWaterMask);
                   if (waterNormalLength > 0.95) {
                     mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);
                     vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);
                     vec4 viewPosition = view*vec4(vpos, 1.0);
                     vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + localOrigin);
                     vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                     float opacity = sliced ? ${S.float(t)} : 1.0;
                     // un-gamma the ground color to mix in linear space
                     fragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w) * opacity;
                   }`)}
          ${z(r.visualizeNormals,R?S`
                  vec3 localUp = normalize(vpos + localOrigin);
                  vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), localUp));
                  vec3 forward = normalize(cross(localUp, right));
                  mat3 tbn = mat3(right, forward, localUp);
                  vec3 tNormal = normalize(normal * tbn);
                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);`:S`
                  vec3 tNormal = normalize(normal);
                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);`)}
          ${z(I,S`vec2 dVuv = fwidth(vuv0);
                 vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv0, 1.0 - vuv0));
                 float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);
                 fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);`)}
          fragColor = applySlice(fragColor, vpos);`)}break;case 2:Q&&i.include(x,r),A.main.add(S`
        ${z(Q,"setOverlayVTC(uv0);")}
        gl_Position = transformPosition(proj, view, position);`),V.main.add(`${z(Q,`if (getCombinedOverlayColor().a < ${S.float(_)}) discard;`)}`);break;case 4:case 5:case 6:case 7:case 8:i.include(v,r),l(i),t(i),A.main.add(S`gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);`),V.main.add(S`outputDepth(linearDepth);`);break;case 3:Q&&i.include(x,r),B.add("vnormal","vec3"),M(A),k(),A.main.add(S`
        ${z(Q,"setOverlayVTC(uv0);")}
        gl_Position = transformPosition(proj, view, position);
        vnormal = normalize((viewNormal * vec4(getNormal(), 1.0)).xyz);`),V.main.add(S`
        ${z(Q,`if (getCombinedOverlayColor().a < ${S.float(_)}) discard;`)}
        vec3 normal = normalize(vnormal);
        if (gl_FrontFacing == false) {
          normal = -normal;
        }
        fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);`);break;case 9:J&&(i.include(x,r),i.include(p,r)),A.main.add(S`
        ${z(J,"setOverlayVTC(uv0);")}
        gl_Position = transformPosition(proj, view, position);`),i.include(g,r),V.main.add(S`
        ${z(J,S`
           calculateOcclusionAndOutputHighlight(getAllOverlayHighlightValuesEncoded());`,"calculateOcclusionAndOutputHighlight();")}
      `)}if(10===H)if(J)r.pbrMode=0,i.include(x,r),r.pbrMode=E,A.main.add(S`gl_Position = transformPosition(proj, view, position);
setOverlayVTC(uv0);`),V.main.add(S`fragColor = getOverlayColorTexel();`);else{const e=0===G;A.main.add(S`${z(e,"gl_Position = transformPosition(proj, view, position);")}`),V.main.add(S`fragColor = vec4(0.0);`)}return i}const W=r(),U=i(),B=Object.freeze(Object.defineProperty({__proto__:null,TerrainPassParameters:A,build:V},Symbol.toStringTag,{value:"Module"}));export{A as T,B as a,V as b};
