/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{ScreenSpacePass as e}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{glsl as r,If as o}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DPassUniform as s}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{NoParameters as t}from"../views/webgl/NoParameters.js";import{ShaderBuilder as a}from"../views/webgl/ShaderBuilder.js";class i extends t{}function n(t){const i=new a;i.include(e);const{hasEmitters:n,dimEmissive:c}=t,m=i.fragment;return m.uniforms.add(new s("colorTexture",e=>e.colorTexture),new s("alphaTexture",e=>e.alphaTexture)),i.outputs.add("fragColor","vec4",0),n&&i.outputs.add("fragEmission","vec4",1),c?(m.main.add(r`float srcAlpha = texture(alphaTexture, uv).r;
vec4 srcColor = texture(colorTexture, uv);
srcColor.rgb = clamp(srcColor.rgb, vec3(0.0), srcColor.rgb);
vec3 dimming = srcAlpha > 1.0 ? mix(vec3(1.0), srcColor.rgb, 1.0 / srcAlpha) : mix(vec3(1.0), srcColor.rgb, srcAlpha);
fragEmission = vec4(dimming, 0.0);`),i):(m.uniforms.add(new s("frontFaceTexture",e=>e.frontFaceTexture)),n&&(m.uniforms.add(new s("emissionTexture",e=>e.emissionTexture)),m.uniforms.add(new s("emissionFrontFaceTexture",e=>e.emissionFrontFaceTexture))),m.main.add(r`
      float srcAlpha = texture(alphaTexture, uv).r;
      if(srcAlpha == 0.0){
        fragColor = vec4(0.0);
        ${o(n,"fragEmission = vec4(0.0);")}
        return;
      }

      vec4 srcColor = texture(colorTexture, uv);
      vec4 frontFace = texture(frontFaceTexture, uv);
      fragColor = vec4(mix(srcColor.rgb / srcAlpha, frontFace.rgb, frontFace.a), 1.0 - srcColor.a);

      ${o(n,"vec4 emission = texture(emissionTexture, uv);\n         vec4 emissionFrontFace = texture(emissionFrontFaceTexture, uv);\n\n         // Modulate transparent emitter by front faces. This case is important for surfaces which contain emitter and \n         // non-emitter at the same time. Non-emitter surface parts need to modulate emissions as well.\n         emission.rgb = emission.rgb * (1.0 - frontFace.a);\n\n         fragEmission = vec4(mix(emission.rgb / srcAlpha, emissionFrontFace.rgb, emissionFrontFace.a), 1.0 - srcColor.a);")}
    `),i)}const c=Object.freeze(Object.defineProperty({__proto__:null,OITBlendPassParameters:i,build:n},Symbol.toStringTag,{value:"Module"}));export{i as O,c as a,n as b};
