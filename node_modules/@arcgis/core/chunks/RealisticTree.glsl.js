/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{Offset as e}from"../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js";import{isColorOrColorEmission as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as r}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as i}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{InstanceColor as a}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstanceColor.glsl.js";import{InstancedDoublePrecision as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js";import{MaskedColorDefinition as t,CreateMaskedFromNaNColor as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/MaskedColor.glsl.js";import{NormalAttribute as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{SymbolColor as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VerticalOffset as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js";import{DefaultMaterialAuxiliaryPasses as v}from"../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js";import{EvaluateAmbientOcclusion as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as w,addAmbientBoostFactor as p,addLightingGlobalFactor as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightDirection as f,addMainLightIntensity as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{PhysicallyBasedRendering as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js";import{PhysicallyBasedRenderingParameters as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapPass as C,ReadShadowMapDraw as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as j}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{VisualVariables as M}from"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js";import{DiscardOrAdjustAlphaPass as O}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{MixExternalColor as N}from"../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js";import{addProjViewLocalOrigin as P,addCameraPosition as S}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as A}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as E}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as D}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as F,If as V}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DPassUniform as T}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnowCover as $}from"../views/3d/webgl-engine/effects/weather/SnowCover.glsl.js";import{colorMixModes as I}from"../views/3d/webgl-engine/materials/internal/MaterialUtil.js";import{outputColorHighlightOID as k}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as R}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as B}from"../webscene/support/AlphaCutoff.js";function _(_){const z=new R,{attributes:U,vertex:W,fragment:H,varyings:G}=z,{output:q,offsetBackfaces:J,pbrMode:K,snowCover:Q,spherical:X}=_,Y=1===K||2===K;if(P(W,_),U.add("position","vec3"),G.add("vpos","vec3",{invariant:!0}),z.include(M,_),z.include(l,_),z.include(m,_),z.include(j,_),!o(q))return z.include(v,_),z;S(z.vertex,_),z.include(n,_),z.include(i),J&&z.include(e),G.add("vNormalWorld","vec3"),G.add("localvpos","vec3",{invariant:!0}),z.include(c,_),z.include(d,_),z.include(a,_),z.include(g,_),W.include(t),W.include(s),W.uniforms.add(new E("externalColor",e=>e.externalColor,{supportsNaN:!0})),G.add("vcolorExt","vec4"),z.include(_.instancedDoublePrecision?C:L,_),W.main.add(F`
    forwardNormalizedVertexColor();

    MaskedColor maskedColorExt =
      applySymbolColor(applyVVColor(applyInstanceColor(createMaskedFromNaNColor(externalColor))));

    vcolorExt = maskedColorExt.color;
    forwardColorMixMode(maskedColorExt.mask);

    bool alphaCut = opacityMixMode != ${F.int(I.ignore)} && vcolorExt.a < ${F.float(B)};
    vpos = getVertexInLocalOriginSpace();

    localvpos = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
    vpos = addVerticalOffset(vpos, localOrigin);
    vec4 basePosition = transformPosition(proj, view, vpos);

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardTextureCoordinates();
    forwardLinearDepthToReadShadowMap();
    gl_Position = alphaCut ? vec4(1e38, 1e38, 1e38, 1.0) :
    ${V(J,"offsetBackfacingClipPosition(basePosition, vpos, vNormalWorld, cameraPosition);","basePosition;")}
  `);const{hasColorTexture:Z,hasColorTextureTransform:ee}=_;return z.include(w,_),H.include(b,_),z.include(O,_),H.include(r,_),z.include(k,_),S(H,_),f(H),p(H),u(H),H.uniforms.add(W.uniforms.get("localOrigin"),W.uniforms.get("view"),new A("ambient",e=>e.ambient),new A("diffuse",e=>e.diffuse),new D("opacity",e=>e.opacity),new D("layerOpacity",e=>e.layerOpacity)),Z&&H.uniforms.add(new T("tex",e=>e.texture)),z.include(x,_),H.include(y,_),H.include(N),H.include($,_),h(H),H.main.add(F`
      discardBySlice(vpos);
      discardByTerrainDepth();
      vec4 texColor = ${Z?`texture(tex, ${ee?"colorUV":"vuv0"})`:" vec4(1.0)"};
      ${V(Z,`${V(_.textureAlphaPremultiplied,"texColor.rgb /= texColor.a;")}\n        discardOrAdjustAlpha(texColor);`)}
      vec3 viewDirection = normalize(vpos - cameraPosition);
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse();
      ssao *= getBakedOcclusion();

      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
      float shadow = readShadow(additionalAmbientScale, vpos);
      vec3 matColor = max(ambient, diffuse);
      ${_.hasVertexColors?F`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, opacityMixMode);`:F`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, opacityMixMode);`}

      vec3 shadingNormal = normalize(vNormalWorld);
      vec3 groundNormal = ${X?"normalize(vpos + localOrigin)":"vec3(0.0, 0.0, 1.0)"};

      ${V(Q,"vec3 faceNormal = screenDerivativeNormal(vpos);\n         float snow = getRealisticTreeSnow(faceNormal, shadingNormal, groundNormal);\n         albedo = mix(albedo, vec3(1), snow);")}

      ${F`albedo *= 1.2;
             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
             float treeRadialFalloff = vColor.r;
             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
             additionalLight += backLightFactor * mainLightIntensity;`}

      ${Y?F`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
            ${V(Q,"mrr = applySnowToMRR(mrr, snow);")}
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, groundNormal, mrr, additionalAmbientIrradiance);`:F`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos, albedo ${V(Q,", 1.0")});`),z}const z=Object.freeze(Object.defineProperty({__proto__:null,build:_},Symbol.toStringTag,{value:"Module"}));export{z as R,_ as b};
