/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{create as e}from"../core/libs/gl-matrix-2/factories/vec2f64.js";import{clone as o,fromValues as r,create as t}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{ScreenSpacePass as s}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{BlendColorsPremultiplied as a,premultiplyAlpha as l}from"../views/3d/webgl-engine/core/shaderLibrary/util/BlendColorsPremultiplied.glsl.js";import{CameraSpace as n}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{Float2PassUniform as i}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float4PassUniform as d}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as h}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{If as m,glsl as c}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DPassUniform as u}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{S as g}from"./ShadowCastAccumulate.glsl.js";import{NoParameters as p}from"../views/webgl/NoParameters.js";import{ShaderBuilder as w}from"../views/webgl/ShaderBuilder.js";class f extends p{constructor(r){super(),this._data=r,this.sampleScale=e(),this.opacityFromElevation=1,this.gradientColor=o(C),this.thresholdColor=o(v),this.bandedGradientColor=o(y),this.bandSize=.1,this.threshold=.5}get shadowCastMap(){return this._data.shadowCastTexture}}const b=.7,S=50/255,C=r(0,0,1,b),v=r(1,0,0,b),y=r(S,S,S,b);function j(e){const o=new w,r=o.fragment;o.include(n),o.include(s);const{visualization:t}=e;r.constants.add("inverseSampleValue","float",g),r.uniforms.add(new u("shadowCastMap",e=>e.shadowCastMap),new i("sampleScale",e=>e.sampleScale),new h("opacityFromElevation",e=>e.opacityFromElevation));const p=2===t,f=3===t,b=1===t;switch(f&&r.include(a),t){case 0:r.uniforms.add(new d("uColor",e=>l($,e.gradientColor)));break;case 1:r.uniforms.add(new d("uColor",e=>l($,e.bandedGradientColor)),new h("bandSize",e=>e.bandSize));break;case 3:r.uniforms.add(new d("uColor",e=>l($,e.thresholdColor)),new d("gradientColor",e=>l($,e.gradientColor)),new h("threshold",e=>e.threshold));break;case 2:r.uniforms.add(new d("uColor",e=>l($,e.thresholdColor)),new h("threshold",e=>e.threshold))}const{type:S,selector:C,thresholdStrengthSelector:v}=f?{type:"vec2",selector:"rg",thresholdStrengthSelector:"strength.x"}:{type:"float",selector:"r",thresholdStrengthSelector:"strength"};return r.main.add(c`
    ${S} numSamples = texture(shadowCastMap, uv).${C} * inverseSampleValue;

    fragColor = vec4(0.0);

    // early out if we do not have any samples in one or more channels
    if (dot(numSamples, ${S}(1)) < 1.0) {
      return;
    }

    // sampleScale is the number of total samples taken, so this brings strength to a 0-1 range.
    // note that sampleScale is always a vec2 even if we have only the primary channel.
    ${S} strength = numSamples * sampleScale.${C};

    // in threshold mode, step the strength to 0 if we are at or below the threshold, 1 otherwise.
    ${m(p||f,c`
      ${v} = 1.0 - step(${v}, threshold);
    `)}

    // bail out if we are below the threshold
    ${m(p,c`if (${v} == 0.0) { return; }`)}

    ${m(b,c`strength = ceil(strength / bandSize) * bandSize;`)}

    ${S} attenuation = opacityFromElevation * strength;

    // in ThresholdAndGradient mode we blend the threshold color on top of the gradient color
    fragColor = ${m(f,c`blendColorsPremultiplied(uColor * attenuation.r, gradientColor * attenuation.g)`,c`uColor * attenuation`)};
  `),o}const $=t(),P=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastVisualizePassParameters:f,build:j},Symbol.toStringTag,{value:"Module"}));export{f as S,P as a,j as b};
