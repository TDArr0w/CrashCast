/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{ReadDepth as e}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{Gamma as o}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js";import{FloatPassUniform as r}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{FloatsPassUniform as i}from"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js";import{If as s,glsl as l}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{IntegerPassUniform as a}from"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js";import{Texture2DBindUniform as t}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{Texture2DPassUniform as d}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{lodFactorsPresets as n}from"../views/3d/webgl-engine/effects/glow/GlowPresets.glsl.js";import{RayDistanceFalloffPassParameters as m,RayDistanceFalloff as c}from"../views/3d/webgl-engine/effects/raymarching/RayDistanceFalloff.glsl.js";import{ScreenSpacePassAtmosphere as p}from"../views/3d/webgl-engine/shaders/ScreenSpacePassAtmosphere.glsl.js";import{ToneMapping as g}from"../views/3d/webgl-engine/shaders/ToneMapping.glsl.js";import{ShaderBuilder as u}from"../views/webgl/ShaderBuilder.js";class x extends m{constructor(){super(...arguments),this.lodFactors=[0,0,0,0,0,0],this.glowLod=-1,this.dispersionWeight=1,this.distanceModifier=1e-4}}function w(m){const x=new u,w=x.fragment,{blurEnabled:f,tonemappingEnabled:v}=m;return x.include(p,{needUVs:!0,needEyeDirection:!0}),w.include(o),w.include(c),w.include(e),x.outputs.add("fragColor","vec4",0),x.outputs.add("fragEmission","vec3",1),w.include(g),w.uniforms.add(new d("colorTexture",e=>e.color),new d("emissionTexture",e=>e.emission)),f?(w.uniforms.add(new t("depthTexture",e=>e.mainDepth),new r("distanceModifier",e=>e.distanceModifier),new d("lodTexture0",e=>e.lodTexture0),new d("lodTexture1",e=>e.lodTexture1),new d("lodTexture2",e=>e.lodTexture2),new d("lodTexture3",e=>e.lodTexture3),new d("lodTexture4",e=>e.lodTexture4),new a("glowLod",e=>e.glowLod),new i("minDisperse",()=>n.minDisperse.presets,6),new i("maxDisperse",()=>n.maxDisperse.presets,6),new r("dispersionWeight",e=>e.dispersionWeight)).main.add(l`
    vec4 color = texture(colorTexture, uv);
    color = vec4(linearizeGamma(color.rgb), color.a);

    vec3 lod0 = texture(emissionTexture, uv).rgb;
    vec3 lod1 = texture(lodTexture0, uv).rgb;
    vec3 lod2 = texture(lodTexture1, uv).rgb;
    vec3 lod3 = texture(lodTexture2, uv).rgb;
    vec3 lod4 = texture(lodTexture3, uv).rgb;
    vec3 lod5 = texture(lodTexture4, uv).rgb;

    float terrainDepth = -1.0;
    float depthSample = depthFromTexture(depthTexture, uv);
    if(depthSample < 1.0 && depthSample > 0.0){
      vec3 cameraSpaceRay = normalize(eyeDir);
      cameraSpaceRay /= cameraSpaceRay.z;
      cameraSpaceRay *= linearizeDepth(depthSample);
      terrainDepth = max(0.0, length(cameraSpaceRay));
    }
    vec3 rayDir = normalize(worldRay);
    float dispersionByDistance = getDistanceFalloff(terrainDepth, rayDir, distanceModifier);
    float dispersionPerPixel = dispersionWeight * dispersionByDistance;

    float lodFactor0 = mix(minDisperse[0], maxDisperse[0], dispersionPerPixel);
    float lodFactor1 = mix(minDisperse[1], maxDisperse[1], dispersionPerPixel);
    float lodFactor2 = mix(minDisperse[2], maxDisperse[2], dispersionPerPixel);
    float lodFactor3 = mix(minDisperse[3], maxDisperse[3], dispersionPerPixel);
    float lodFactor4 = mix(minDisperse[4], maxDisperse[4], dispersionPerPixel);
    float lodFactor5 = mix(minDisperse[5], maxDisperse[5], dispersionPerPixel);

    vec3 emission = lodFactor0 * lod0;
    emission += lodFactor1 * lod1;
    emission += lodFactor2 * lod2;
    emission += lodFactor3 * lod3;
    emission += lodFactor4 * lod4;
    emission += lodFactor5 * lod5;

    // only for glow editor lod debugging
    emission = glowLod == 0 ? lodFactor0 * lod0 : glowLod == 1 ? lodFactor1 * lod1 : glowLod == 2 ? lodFactor2 * lod2 : glowLod == 3 ? lodFactor3 * lod3 : glowLod == 4 ? lodFactor4 * lod4 : glowLod == 5 ? lodFactor5 * lod5 : emission;

    fragEmission = emission;
    // tonemapping is only applied to the emissive part since main color values are not in HDR.
    ${s(v,"emission = tonemapACES(emission);")}

    fragColor = delinearizeGamma(vec4(color.rgb + emission.rgb, color.w));
  `),x):(w.main.add(l`
      vec4 color = texture(colorTexture, uv);
      color = vec4(linearizeGamma(color.rgb), color.a);

      // emission is already in linear color space here.
      vec3 emission = texture(emissionTexture, uv).rgb;

      ${s(v,"emission = tonemapACES(emission);")}
      fragColor = delinearizeGamma(vec4(color.rgb + emission, color.w));
    `),x)}const f=Object.freeze(Object.defineProperty({__proto__:null,GlowCompositionPassParameters:x,build:w},Symbol.toStringTag,{value:"Module"}));export{x as G,f as a,w as b};
