/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{cyclical2PI as t}from"../core/Cyclical.js";import{deg2rad as e,rad2deg as r,asinClamped as s,lerp as o,clamp as a}from"../core/mathUtils.js";import{fromRotation as n,rotate as i}from"../core/libs/gl-matrix-2/math/mat4.js";import{create as c}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{i as l,f as m,n as p,t as u,u as f,b as h,h as d,k as y,l as g,x as M,c as j}from"./vec32.js";import{fromValues as b,create as v,ZEROS as x,clone as T}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{s as w,b as R}from"./vec42.js";import{create as C}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{getEpsilon as S}from"../core/libs/gl-matrix-2/math/common.js";import{getReferenceEllipsoid as U}from"../geometry/ellipsoidUtils.js";import P from"../geometry/Extent.js";import I from"../geometry/Polygon.js";import H from"../geometry/SpatialReference.js";import{isClockwise as k}from"../geometry/support/coordsUtils.js";import{fromPoints as q,create as A}from"../geometry/support/lineSegment.js";import{gcsCyclical as E}from"../geometry/support/normalizeUtils.js";import{fromPositionAndNormal as _,create as z,isPointInside as F,intersectLineOrRay as G,getNormal as W}from"../geometry/support/plane.js";import{wrap as O}from"../geometry/support/ray.js";import{b as D,c as L,d as N}from"./sphere.js";import{geographicToWebMercator as Y}from"../geometry/support/webMercatorUtils.js";import{Frustum as B}from"../views/3d/state/Frustum.js";import{minNearDistanceInMeters as J}from"../views/3d/state/NearFarHeuristic.js";import{viewAngle as K}from"../views/3d/state/utils/viewUtils.js";import{createDirectionUp as Q,directionToHeadingTilt as V,clampLineSegmentToPlane as X}from"../views/3d/support/cameraUtilsInternal.js";import{getLonDeltaForDistance as Z}from"../views/3d/support/earthUtils.js";import{slerp as $}from"../views/3d/support/mathUtils.js";const tt=b(0,0,1),et=p(v(),b(1,1,1)),rt=c(),st=v(),ot=v();function at(t,r,s,o=Q()){l(st,t,tt),0===m(st,st)&&l(st,t,et),n(rt,-e(r),t),i(rt,rt,-e(s),st);const{up:a,direction:c}=o;return l(a,st,t),p(a,a),u(a,a,rt),p(c,t),f(c,c),u(c,c,rt),o}function nt(t,e,r,s){const o=st,a=ot;return p(o,t),l(ot,o,tt),0===m(ot,ot)&&l(ot,o,et),l(a,ot,o),V(e,r,s,o,a)}function it(t,r,o,a){const n={eye:v(),up:null,tilt:a,heading:o},i=st;i[0]=t[0],i[1]=t[2],i[2]=-t[1];const c=r,l=e(o),m=e(a),p=Math.sin(l),u=Math.cos(l),f=Math.sin(m),y=Math.cos(m),g=h(i);let M;if(Math.abs(m)<1e-8)M=c+g;else{const t=g/f,e=s(c/t),r=Math.PI-m-e;M=t*Math.sin(r)}const j=y*c,b=c*c*(f*f),x=u*u*b,T=M-j,w=T*T,R=x*(x+w-i[1]*i[1]);if(R<0)return d(n.eye,i,M/g),n.tilt=0,lt(n,t);const C=Math.sqrt(R),S=i[1]*T,U=x+w;let P;if(P=u>0?-C+S:C+S,Math.abs(U)<1e-8)return g<1e-8?(n.eye[0]=0,n.eye[1]=0,n.eye[2]=c):d(n.eye,i,M/g),n.tilt=0,ct(n.eye),lt(n,t);n.eye[1]=P/U;const I=p*p*b,H=f*c,k=u*H*n.eye[1],q=n.eye[1]*n.eye[1],A=1-q,E=Math.sqrt(A),_=x*q+I-2*k*E*T+A*w;return Math.abs(_)<1e-8?(d(n.eye,i,M/g),n.tilt=0,ct(n.eye),lt(n,t)):(n.eye[0]=(A*(M*i[0]-j*i[0])-H*E*(i[0]*n.eye[1]*u+i[2]*p))/_,n.eye[2]=(A*(M*i[2]-j*i[2])-H*E*(i[2]*n.eye[1]*u-i[0]*p))/_,d(n.eye,n.eye,M),ct(n.eye),lt(n,t))}function ct(t){const e=t[1];t[1]=-t[2],t[2]=e}function lt(t,e){const r=at(e,t.heading,t.tilt);return t.up=r.up,t}function mt(t,e,o){const a=h(e),n=Math.sqrt(o*o+a*a-2*o*a*Math.cos(Math.PI-t)),i=s(o/(n/Math.sin(t)));return r(t-i)}function pt(t,r,o){const a=e(t),n=h(r);return s(o/(n/Math.sin(a)))+a}function ut(s,o,a,n,i){let c,l,m,p;const u=o.latitude,f=U(s.spatialReference).radius,h=o.longitude,d=Z(u,a,f)/2;c=h-d,l=h+d;const y=e(u),g=(1+Math.sin(y))/(1-Math.sin(y)),M=(g+1)*Math.tan(n/f/2),j=M*M;function b(e){const r=Math.PI/2;return(e=t.normalize(e,-r))>r&&(e=Math.PI-e),e}if(m=1.5*Math.PI-2*Math.atan(.5*(M+Math.sqrt(4*g+j))),p=m+n/f,m=b(m),p=b(p),p<m){const t=p;p=m,m=t}if(m=Math.max(r(m),-90),p=Math.min(r(p),90),l=E.monotonic(c,l),l-c>180){const t=(l-c-180)/2;c+=t,l-=t}const v=s.spatialReference&&s.spatialReference.isGeographic?s.spatialReference:H.WGS84;return i?(i.xmin=c,i.ymin=m,i.xmax=l,i.ymax=p,i.spatialReference=v):i=new P(c,m,l,p,v),s.spatialReference&&s.spatialReference.isWebMercator&&Y(i,!1,i),i}function ft(t,e){const{renderCoordsHelper:r}=t,s=t.state.camera.clone(),n=new B(r);s.near=J,n.update(s);const i=r.getAltitude(e),c=t.spatialReference,l=r.referenceEllipsoid.radius,m=s.eye,p=1+y(m,e)/(l+i),u=Math.sqrt(p*p-1),{minCurvature:f,maxCurvature:h,minSamples:d,maxSamples:j}=Mt,b=gt(t),v=a((u-f)/(h-f),0,1),C=Math.round(o(d,j,v)),S=s.aboveGround,U=n.planes[5],P=[],H=_(x,jt,z()),k=_(x,bt,z());w(Ct,0,0,0,0);const q=t=>{};for(let a=0;a<4;a++){const t=1===a&&!S||3===a&&S?1-b:0,e=1===a&&S||3===a&&!S?b:1,s=n.lines[a],c=n.lines[3===a?0:a+1];for(let n=0;n<C;n++){const l=n/C,p=0===n?0:o(t,e,1===a?1-(1-l)**2:3===a?l**2:l),u=g(xt,s.origin,c.origin,p),f=$(s.direction,c.direction,p,vt);r.intersectManifoldClosestSilhouette(O(u,f),i,Tt),X(Tt,m,Tt,U),P.push(T(Tt)),0!==P.length&&q(M(P.at(-1),Tt));const h=(F(H,Tt)?1:0)|(F(k,Tt)?2:0);Ct[h]=1}}P.length>2&&q(M(P[0],P.at(-1)));const A=ht(R(Ct)>1?dt(yt(P,H),k):[P],r,c);return new I({rings:A,spatialReference:c})}function ht(t,e,r){const s=2*S();return t.map(t=>{const o=[];let a=!1;for(const n of t)e.fromRenderCoords(n,Tt,r),Math.abs(n[0])<s&&Math.abs(n[1])<s?(o.push([null,Tt[1]]),o.push([null,Tt[1]]),a=!0):o.push([Tt[0],Tt[1]]);if(a)for(let e=0;e<o.length;e++){const t=o[e];if(null!=t[0])continue;const r=o[e+1],s=o.at(0===e?-1:e-1);t[0]=s[0],e++;const a=o.at(e===o.length-1?0:e+1);r[0]=a[0]}return o.push(o[0]),k(o)||o.reverse(),o})}function dt(t,e){const r=[];for(const s of t)r.push(...yt(s,e));return r}function yt(t,e){const r=[],s=[],o=S();for(let n=0;n<t.length;n++){const a=t[n],i=n===t.length-1?t[0]:t[n+1],c=q(a,i,Rt),l=G(e,c.origin,c.vector,0,Tt);switch(l){case 2:r.push(a);break;case 3:s.push(a);break;case 0:case 1:{const[t,n,i]=0===l?[1,r,s]:[-1,s,r],c=W(e),m=j(v(),Tt,c,t*o),p=j(v(),Tt,c,t*-o);n.push(a),n.push(m),i.push(p)}}}const a=[];return r.length&&a.push(r),s.length&&a.push(s),a}function gt(t){const{renderCoordsHelper:e,state:{camera:r}}=t,{center:s,eye:o}=r,a=Math.abs(e.getAltitude(s)),n=Math.abs(Math.PI/2-K(e,s,o));return D(wt,e.referenceEllipsoid.radius+a),N(wt,n,r.distance,r.fovY)}const Mt={minCurvature:e(5),maxCurvature:e(50),minSamples:1,maxSamples:6},jt=b(1,0,0),bt=b(0,1,0),vt=v(),xt=v(),Tt=v(),wt=L(),Rt=A(),Ct=C(),St=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:nt,eyeForCenterWithHeadingTilt:it,eyeTiltToLookAtTilt:pt,headingTiltToDirectionUp:at,lookAtTiltToEyeTilt:mt,toArea:ft,toExtent:ut},Symbol.toStringTag,{value:"Module"}));export{pt as a,ft as b,St as c,nt as d,it as e,at as h,mt as l,ut as t};
