/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{Offset as e}from"../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js";import{isColorOrColorEmission as r}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as o}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as i}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{InstanceColor as a}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstanceColor.glsl.js";import{InstancedDoublePrecision as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js";import{MaskedColorDefinition as s,CreateMaskedFromNaNColor as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/MaskedColor.glsl.js";import{NormalAttribute as t}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{SymbolColor as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VerticalOffset as u}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js";import{DefaultMaterialAuxiliaryPasses as v}from"../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js";import{ComputeNormalTexture as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{EvaluateAmbientOcclusion as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as b,addAmbientBoostFactor as f,addLightingGlobalFactor as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{Normals as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{PhysicallyBasedRendering as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js";import{PhysicallyBasedRenderingParameters as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapPass as j,ReadShadowMapDraw as P}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as M}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{colorTextureUV as N,normalTextureUV as T,emissiveTextureUV as O,occlusionTextureUV as S,metallicRoughnessTextureUV as V}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TextureTransformUV.glsl.js";import{VisualVariables as $}from"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js";import{DiscardOrAdjustAlphaPass as A}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{MixExternalColor as D}from"../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js";import{addProjViewLocalOrigin as U,addCameraPosition as I}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as B}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as E}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as k}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{If as _,glsl as R}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DPassUniform as F}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnowCover as z}from"../views/3d/webgl-engine/effects/weather/SnowCover.glsl.js";import{colorMixModes as W}from"../views/3d/webgl-engine/materials/internal/MaterialUtil.js";import{outputColorHighlightOID as G}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as H}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as q}from"../webscene/support/AlphaCutoff.js";function J(J){const K=new H,{attributes:Q,vertex:X,fragment:Y,varyings:Z}=K,{output:ee,normalType:re,offsetBackfaces:oe,spherical:ie,snowCover:ae,pbrMode:le,textureAlphaPremultiplied:se,instancedDoublePrecision:ne,hasVertexColors:te,hasVertexTangents:de,hasColorTexture:ce,hasNormalTexture:me,hasNormalTextureTransform:ge,hasColorTextureTransform:ue}=J;if(U(X,J),Q.add("position","vec3"),Z.add("vpos","vec3",{invariant:!0}),K.include($,J),K.include(l,J),K.include(u,J),K.include(N,J),!r(ee))return K.include(v,J),K;K.include(T,J),K.include(O,J),K.include(S,J),K.include(V,J),I(X,J),K.include(t,J),K.include(i);const ve=0===re||1===re;return ve&&oe&&K.include(e),K.include(w,J),K.include(g,J),K.include(a,J),Z.add("vPositionLocal","vec3"),K.include(c,J),K.include(d,J),K.include(m,J),X.uniforms.add(new E("externalColor",e=>e.externalColor,{supportsNaN:!0})),Z.add("vcolorExt","vec4"),K.include(M,J),X.include(s),X.include(n),K.include(ne?j:P,J),X.main.add(R`
    forwardNormalizedVertexColor();

    MaskedColor maskedColor =
      applySymbolColor(applyVVColor(applyInstanceColor(createMaskedFromNaNColor(externalColor))));

    vcolorExt = maskedColor.color;
    forwardColorMixMode(maskedColor.mask);

    vpos = getVertexInLocalOriginSpace();
    vPositionLocal = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    ${_(ve,"vNormalWorld = dpNormal(vvLocalNormal(normalModel()));")}
    vpos = addVerticalOffset(vpos, localOrigin);
    ${_(de,"vTangent = dpTransformVertexTangent(tangent);")}
    gl_Position = transformPosition(proj, view, vpos);
    ${_(ve&&oe,"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);")}

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardTextureCoordinates();
    forwardColorUV();
    forwardNormalUV();
    forwardEmissiveUV();
    forwardOcclusionUV();
    forwardMetallicRoughnessUV();

    if (opacityMixMode != ${R.int(W.ignore)} && vcolorExt.a < ${R.float(q)}) {
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
    }
    forwardLinearDepthToReadShadowMap();
  `),K.include(b,J),Y.include(p,J),K.include(A,J),Y.include(o,J),K.include(G,J),I(Y,J),Y.uniforms.add(X.uniforms.get("localOrigin"),new B("ambient",e=>e.ambient),new B("diffuse",e=>e.diffuse),new k("opacity",e=>e.opacity),new k("layerOpacity",e=>e.layerOpacity)),ce&&Y.uniforms.add(new F("tex",e=>e.texture)),K.include(L,J),Y.include(C,J),Y.include(D),K.include(x,J),Y.include(z,J),f(Y),h(Y),y(Y),Y.main.add(R`
    discardBySlice(vpos);
    discardByTerrainDepth();
    ${ce?R`
            vec4 texColor = texture(tex, ${ue?"colorUV":"vuv0"});
            ${_(se,"texColor.rgb /= texColor.a;")}
            discardOrAdjustAlpha(texColor);`:R`vec4 texColor = vec4(1.0);`}
    shadingParams.viewDirection = normalize(vpos - cameraPosition);
    ${2===re?R`vec3 normal = screenDerivativeNormal(vPositionLocal);`:R`shadingParams.normalView = vNormalWorld;
                vec3 normal = shadingNormal(shadingParams);`}
    applyPBRFactors();
    float ssao = evaluateAmbientOcclusionInverse() * getBakedOcclusion();

    vec3 posWorld = vpos + localOrigin;

    float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
    float shadow = readShadow(additionalAmbientScale, vpos);

    vec3 matColor = max(ambient, diffuse);
    vec3 albedo = mixExternalColor(${_(te,"vColor.rgb *")} matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
    float opacity_ = layerOpacity * mixExternalOpacity(${_(te,"vColor.a * ")} opacity, texColor.a, vcolorExt.a, opacityMixMode);

    ${me?`mat3 tangentSpace = computeTangentSpace(${de?"normal":"normal, vpos, vuv0"});\n            vec3 shadingNormal = computeTextureNormal(tangentSpace, ${ge?"normalUV":"vuv0"});`:"vec3 shadingNormal = normal;"}
    vec3 normalGround = ${ie?"normalize(posWorld);":"vec3(0.0, 0.0, 1.0);"}

    ${_(ae,R`
          float snow = getSnow(normal, normalGround);
          albedo = mix(albedo, vec3(1), snow);
          shadingNormal = mix(shadingNormal, normal, snow);
          ssao = mix(ssao, 1.0, snow);`)}

    vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

    ${1===le||2===le?R`
            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
            ${_(ae,"mrr = applySnowToMRR(mrr, snow);")}
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, additionalAmbientIrradiance);`:R`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
    vec4 finalColor = vec4(shadedColor, opacity_);
    outputColorHighlightOID(finalColor, vpos, albedo ${_(ae,", snow")});
  `),K}const K=Object.freeze(Object.defineProperty({__proto__:null,build:J},Symbol.toStringTag,{value:"Module"}));export{K as D,J as b};
