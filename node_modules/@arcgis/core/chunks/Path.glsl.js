/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{addNearFar as e}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepthToWriteShadowMap.glsl.js";import{isColorOrColorEmission as i}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as o}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as a}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as r}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{PathVertexPosition as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js";import{OutputDepth as l}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as s}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientOcclusion as d}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as t,addAmbientBoostFactor as c,addLightingGlobalFactor as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as g}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{Normals as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{NormalUtils as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{PhysicallyBasedRenderingParameters as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapDraw as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{ColorConversion as b}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as f,addViewNormal as y,addCameraPosition as j}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as L}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as P}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as S,If as O}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{SnowCover as C}from"../views/3d/webgl-engine/effects/weather/SnowCover.glsl.js";import{outputColorHighlightOID as A}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as D}from"../views/webgl/ShaderBuilder.js";function B(B){const I=new D,{vertex:M,fragment:_,varyings:F}=I;f(M,B),F.add("vpos","vec3",{invariant:!0}),I.include(n,B);const{output:V,spherical:x,pbrMode:z,snowCover:T}=B;switch((i(V)||10===V)&&(I.include(a),I.include(u,B),I.include(r,B),I.include(h,B),F.add("vnormal","vec3"),F.add("vcolor","vec4"),M.main.add(S`vpos = calculateVPos();
vnormal = normalize(localNormal());
forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
forwardObjectAndLayerIdColor();
vcolor = getColor();
forwardLinearDepthToReadShadowMap();`)),V){case 1:case 0:I.include(w,B),I.include(t,B),_.include(d,B),I.include(v,B),_.include(o,B),I.include(A,B),j(_,B),c(_),m(_),_.uniforms.add(M.uniforms.get("localOrigin"),new L("ambient",e=>e.ambient),new L("diffuse",e=>e.diffuse),new P("opacity",e=>e.opacity)),_.include(b),_.include(C,B),g(_),_.main.add(S`
        discardBySlice(vpos);
        discardByTerrainDepth();

        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        vec3 posWorld = vpos + localOrigin;
        vec3 normalGround = ${x?"normalize(posWorld);":"vec3(0.0, 0.0, 1.0);"}

        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;

        ${O(T,S`float snow = getSnow(normal, normalGround);
                 albedo = mix(albedo, vec3(1), snow);
                 ssao = mix(ssao, 1.0, snow);`)}

        float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
        vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        float shadow = readShadow(additionalAmbientScale, vpos);

        ${O(2===z,`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];\n           ${O(T,"mrr = applySnowToMRR(mrr, snow);")}`)}

        vec3 shadedColor = ${2===z?"evaluateSceneLightingPBR(normal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, additionalAmbientIrradiance);":"evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);"}
        vec4 finalColor = vec4(shadedColor, combinedOpacity);
        outputColorHighlightOID(finalColor, vpos, albedo ${O(T,", snow")});`);break;case 2:I.include(a),M.main.add(S`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`),I.fragment.include(o,B),_.main.add(S`discardBySlice(vpos);`);break;case 4:case 5:case 6:case 7:I.include(a),e(I),F.add("depth","float"),M.main.add(S`vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);`),I.fragment.include(o,B),I.include(l,B),_.main.add(S`discardBySlice(vpos);
outputDepth(depth);`);break;case 10:I.fragment.include(o,B),_.main.add(S`discardBySlice(vpos);
outputObjectAndLayerIdColor();`);break;case 3:I.include(a),I.include(p,B),y(M),F.add("vnormal","vec3"),M.main.add(S`vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);`),I.fragment.include(o,B),_.main.add(S`discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);`);break;case 9:I.include(a),I.include(p,B),F.add("vnormal","vec3"),M.main.add(S`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`),I.fragment.include(o,B),I.include(s,B),_.main.add(S`discardBySlice(vpos);
calculateOcclusionAndOutputHighlight();`)}return I}const I=Object.freeze(Object.defineProperty({__proto__:null,build:B},Symbol.toStringTag,{value:"Module"}));export{I as P,B as b};
