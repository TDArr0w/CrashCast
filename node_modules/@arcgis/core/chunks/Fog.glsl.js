/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{create as e}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{ReadDepth as o}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{Gamma as r}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js";import{Float3PassUniform as i}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as s}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{If as t,glsl as a}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DBindUniform as n}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{Texture2DPassUniform as l}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{RayDistanceFalloffPassParameters as m,RayDistanceFalloff as g}from"../views/3d/webgl-engine/effects/raymarching/RayDistanceFalloff.glsl.js";import{ScreenSpacePassAtmosphere as c}from"../views/3d/webgl-engine/shaders/ScreenSpacePassAtmosphere.glsl.js";import{ToneMapping as d}from"../views/3d/webgl-engine/shaders/ToneMapping.glsl.js";import{ShaderBuilder as f}from"../views/webgl/ShaderBuilder.js";class p extends m{constructor(){super(...arguments),this.color=e(),this.strength=4e-6,this.amount=0,this.fogColorDistanceWeight=1}}function u(e){const m=new f;m.include(c,{needUVs:!0,needEyeDirection:!0});const p=m.fragment,{hasEmissive:u}=e;return p.uniforms.add(new n("depthTexture",e=>e.mainDepth),new s("fogStrength",e=>e.strength),new s("fogAmount",e=>e.amount),new i("fogColor",e=>e.color),new s("fogColorDistanceWeight",e=>e.fogColorDistanceWeight)),u&&p.uniforms.add(new l("emissionTexture",e=>e.emission)),p.include(g),p.include(r),p.include(d),p.include(o),p.main.add(a`
    vec3 rayDir = normalize(worldRay);
    float terrainDepth = -1.0;

    float depthSample = depthFromTexture(depthTexture, uv);
    if(depthSample < 1.0 && depthSample > 0.0){
      vec3 cameraSpaceRay = normalize(eyeDir);
      cameraSpaceRay /= cameraSpaceRay.z;
      cameraSpaceRay *= linearizeDepth(depthSample);
      terrainDepth = max(0.0, length(cameraSpaceRay));
    }

    float fogAmount = fogAmount * getDistanceFalloff(terrainDepth, rayDir, fogStrength);

    ${t(u,a`vec3 emission = texture(emissionTexture, uv).rgb;
           vec3 emissionDistanceCorrected = mix(emission, vec3(0.0), fogAmount * fogColorDistanceWeight);
           vec3 finalFogColor = fogColor * fogAmount + emissionDistanceCorrected;
           vec4 fog = vec4(finalFogColor, fogAmount);`,a`vec4 fog = vec4(fogColor, 1.0) * fogAmount;`)}
    fragColor = delinearizeGamma(vec4(tonemapACES(fog.rgb), fog.a));`),m}const h=Object.freeze(Object.defineProperty({__proto__:null,FogPassParameters:p,build:u},Symbol.toStringTag,{value:"Module"}));export{p as F,h as a,u as b};
