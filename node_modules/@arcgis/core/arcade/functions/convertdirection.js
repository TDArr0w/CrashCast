/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../Dictionary.js";import{StringEnum as n}from"../enum.js";import{ArcadeExecutionError as t}from"../executionError.js";import{u as r,s,j as i}from"../../chunks/languageUtils.js";import{assertIsSome as o}from"../../core/maybe.js";import{isString as c,isNumber as a,isArray as u}from"../../support/guards.js";const l=e=>(n,t,r=14)=>+e(n,t).toFixed(r),d=(e,n)=>e+n,h=(e,n)=>e-n,g=(e,n)=>e*n,m=(e,n)=>e/n,f=(e,n,t)=>l(d)(e,n,t),w=(e,n,t)=>l(h)(e,n,t),A=(e,n,t)=>l(g)(e,n,t),D=(e,n,t)=>l(m)(e,n,t),p=360,T=400,E=2*Math.PI,S=3600,_=3240,R=60,F=60,M=180*S/Math.PI,v=p*R*F,L=90*S,U=180*S,x=270*S,N=String.fromCharCode(7501),b="Â°";function O(e){if(!1===c(e))throw new t(null,"InvalidParameter",null);return e}function G(e,n){const t=10**n;return Math.round(e*t)/t}function I(e,n){return e%n}function y(e){const n=parseFloat(e.toString().replace(Math.trunc(e).toString(),"0"))*Math.sign(e);if(e<0){return{fraction:n,integer:Math.ceil(e)}}return{fraction:n,integer:Math.floor(e)}}function H(e,n){switch(e){case 0:return"SHORT"===n?"N":"North";case 1:return"SHORT"===n?"E":"East";case 2:return"SHORT"===n?"S":"South";case 3:return"SHORT"===n?"W":"West"}}function k(e,n){return e-Math.floor(e/n)*n}function P(e){switch(e){case 6:case 1:return p;case 4:return E;case 5:return T;case 2:return v;case 7:return R;case 8:return F;default:throw new t(null,"LogicError",null,{reason:"unsupported evaluations"})}}const j=new n([],[["NORTH",1],["NORTH AZIMUTH",1],["POLAR",2],["QUADRANT",3],["SOUTH",4],["SOUTH AZIMUTH",4]]);function z(e){const n=j.lookup(e);if(null==n)throw new t(null,"LogicError",null,{reason:"unsupported directionType"});return n}const Q=new n([],[["D",1],["DD",1],["DECIMAL DEGREE",1],["DEGREE",1],["DECIMAL DEGREES",1],["DEGREES",1],["DMS",3],["DEGREES MINUTES SECONDS",3],["R",4],["RAD",4],["RADS",4],["RADIAN",4],["RADIANS",4],["G",5],["GON",5],["GONS",5],["GRAD",5],["GRADS",5],["GRADIAN",5],["GRADIANS",5]]);function C(e){const n=Q.lookup(e);if(null==n)throw new t(null,"LogicError",null,{reason:"unsupported units"});return n}class W{constructor(e,n,t){this.m_degrees=e,this.m_minutes=n,this.m_seconds=t}getField(e){switch(e){case 1:case 6:return this.m_degrees;case 7:return this.m_minutes;case 2:case 8:return this.m_seconds;default:throw new t(null,"LogicError",null,{reason:"unexpected evaluation"})}}static secondsToDMS(e){const n=y(e).fraction;let t=y(e).integer;const r=Math.floor(t/S);t-=r*S;const s=Math.floor(t/F);return t-=s*F,new W(r,s,t+n)}static numberToDms(e){const n=y(e).fraction,t=y(e).integer,r=A(y(100*n).fraction,100),s=y(100*n).integer;return new W(t,s,r)}format(e,n){let t=G(this.m_seconds,n),r=this.m_minutes,s=this.m_degrees;if(2===e||8===e)F<=t&&(t-=F,++r),R<=r&&(r=0,++s),p<=s&&(s=0);else if(7===e)t=0,r=30<=this.m_seconds?this.m_minutes+1:this.m_minutes,s=this.m_degrees,R<=r&&(r=0,++s),p<=s&&(s=0);else if(1===e||6===e){const e=D(this.m_seconds,S),n=D(this.m_minutes,R);s=Math.round(this.m_degrees+n+e),r=0,t=0}return new W(s,r,t)}static dmsToSeconds(e,n,t){return e*S+n*F+t}}class B{constructor(e,n,t){this.meridian=e,this.angle=n,this.direction=t}fetchAzimuth(e){return 0===e?this.meridian:this.direction}}class V{constructor(e){this._angle=e}static createFromAngleAndDirection(e,n){return new V(new Z(V._convertDirectionFormat(e.extractAngularUnits(2),n,1)))}getAngle(e){const n=this._angle.extractAngularUnits(2);switch(e){case 1:case 4:case 2:return new Z(V._convertDirectionFormat(n,1,e));case 3:{const e=V.secondsNorthAzimuthToQuadrant(n);return new Z(e.angle)}}}getMeridian(e){const n=this._angle.extractAngularUnits(2);switch(e){case 1:return 0;case 4:return 2;case 2:return 1;case 3:return V.secondsNorthAzimuthToQuadrant(n).meridian}}getDirection(e){const n=this._angle.extractAngularUnits(2);switch(e){case 1:return 1;case 4:return 3;case 2:return 0;case 3:return V.secondsNorthAzimuthToQuadrant(n).direction}}static secondsNorthAzimuthToQuadrant(e){const n=e<=L||e>=x?0:2,t=0===n?Math.min(v-e,e):Math.abs(e-U);return new B(n,t,e>U?3:1)}static createFromAngleMeridianAndDirection(e,n,t){return new V(new Z(V.secondsQuadrantToNorthAzimuth(e.extractAngularUnits(2),n,t)))}static secondsQuadrantToNorthAzimuth(e,n,t){return 0===n?1===t?e:v-e:1===t?U-e:U+e}static _convertDirectionFormat(e,n,r){let s=0;switch(n){case 1:s=e;break;case 2:s=L-e;break;case 3:throw new t(null,"LogicError",null,{reason:"unexpected evaluation"});case 4:s=e+U}let i=0;switch(r){case 1:i=s;break;case 2:i=L-s;break;case 3:throw new t(null,"LogicError",null,{reason:"unexpected evaluation"});case 4:i=s-U}return i=I(i,v),i<0?v+i:i}}function X(e,n,r){let s=null;switch(n){case 1:s=A(e,S);break;case 2:s=e;break;case 5:s=A(e,_);break;case 4:s=A(e,M);break;default:throw new t(null,"LogicError",null,{reason:"unexpected evaluation"})}switch(r){case 1:return D(s,S);case 2:return s;case 5:return D(s,_);case 4:return s/M;default:throw new t(null,"LogicError",null,{reason:"unexpected evaluation"})}}class Z{constructor(e){this._seconds=e}static createFromAngleAndUnits(e,n){return new Z(X(e,n,2))}extractAngularUnits(e){return X(this._seconds,2,q(e))}static createFromDegreesMinutesSeconds(e,n,t){return new Z(f(f(A(e,S),A(n,F)),t))}}function q(e){switch(o(e),e){case 1:case 6:case 3:return 1;case 5:return 5;case 7:return 7;case 4:return 4;case 2:case 8:return 2}}class J{constructor(e,n,t,r){this.view=e,this.angle=n,this.merdian=t,this.direction=r,this._dms=null,this._formattedDms=null}static createFromStringAndBearing(e,n,t){return new J(e,n.getAngle(t),n.getMeridian(t),n.getDirection(t))}fetchAngle(){return this.angle}fetchMeridian(){return this.merdian}fetchDirection(){return this.direction}fetchView(){return this.view}fetchDms(){return null===this._dms&&this._calculateDms(),this._dms}fetchFormattedDms(){return null===this._formattedDms&&this._calculateDms(),this._formattedDms}_calculateDms(){let e=null,n=6,t=0;for(let r=0;r<this.view.length;r++){const s=this.view[r];switch(s){case"m":e=ae(this.view,r,s),n=6===n?7:n,r=e.newpos;continue;case"s":e=ae(this.view,r,s),n=8,t=t<e.rounding?e.rounding:t,r=e.newpos;continue;default:continue}}this._dms=W.secondsToDMS(this.angle.extractAngularUnits(2)),this._formattedDms=W.secondsToDMS(this.angle.extractAngularUnits(2)).format(n,t)}}function K(e,n,r,s,i){let o=null;switch(n){case 1:case 4:case 5:return o=k(G(e.extractAngularUnits(n),s),P(n)),o.toFixed(s).padStart(r+s+(s>0?1:0),"0");case 6:case 7:return o=k(i.fetchFormattedDms().getField(n),P(n)),o.toFixed(s).padStart(r+s+(s>0?1:0),"0");case 8:return o=k(G(i.fetchDms().getField(n),s),P(n)),o.toFixed(s).padStart(r+s+(s>0?1:0),"0");default:throw new t(null,"LogicError",null,{reason:"unexpected evaluation"})}}function Y(e,n,r){if(3===r)throw new t(null,"LogicError",null,{reason:"conversion error"});if(3===n){const n=W.numberToDms(e);return V.createFromAngleAndDirection(Z.createFromDegreesMinutesSeconds(n.m_degrees,n.m_minutes,n.m_seconds),r)}return V.createFromAngleAndDirection(Z.createFromAngleAndUnits(e,q(n)),r)}function $(e){switch(s(e)){case 1:return{first:0,second:1};case 2:return{first:2,second:1};case 3:return{first:2,second:3};case 4:return{first:0,second:3}}return null}function ee(e){switch(e.toUpperCase().trim()){case"N":case"NORTH":return 0;case"E":case"EAST":return 1;case"S":case"SOUTH":return 2;case"W":case"WEST":return 3}return null}function ne(e){const n=parseFloat(e);if(a(n)){if(isNaN(n))throw new t(null,"LogicError",null,{reason:"invalid conversion"});return n}throw new t(null,"LogicError",null,{reason:"invalid conversion"})}function te(e,n,s){const i=3===s;let o=null,c=null,a=0,u=0,l=0;if(i){if(e.length<2)throw new t(null,"LogicError",null,{reason:"conversion error"});l=1;const n=$(r(e[e.length-1]));if(n?(o=n.first,c=n.second):(a=1,o=ee(r(e[0])),c=ee(r(e[e.length-1]))),null===o||null===c)throw new t(null,"LogicError",null,{reason:"invalid conversion"})}switch(n){case 1:case 4:case 5:if(0===e.length)throw new t(null,"LogicError",null,{reason:"invalid conversion"});return i?V.createFromAngleMeridianAndDirection(Z.createFromAngleAndUnits(ne(e[a]),q(n)),o,c):V.createFromAngleAndDirection(Z.createFromAngleAndUnits(ne(e[a]),q(n)),s);case 3:if(u=e.length-l-a,3===u){const n=Z.createFromDegreesMinutesSeconds(ne(e[a]),ne(e[a+1]),ne(e[a+2]));return i?V.createFromAngleMeridianAndDirection(n,o,c):V.createFromAngleAndDirection(n,s)}if(1===u){const n=ne(e[a]),t=W.numberToDms(n),r=Z.createFromDegreesMinutesSeconds(t.m_degrees,t.m_minutes,t.m_seconds);return i?V.createFromAngleMeridianAndDirection(r,o,c):V.createFromAngleAndDirection(r,s)}}throw new t(null,"LogicError",null,{reason:"invalid conversion"})}function re(e){const n=new Set([" ","-","/","'",'"',"\\","^",b,N,"\t","\r","\n","*"]);let t="";for(let r=0;r<e.length;r++){const s=e.charAt(r);n.has(s)?t+="RRSPLITRRSPLITRR":t+=s}return t.split("RRSPLITRRSPLITRR").filter(e=>""!==e)}function se(e,n,r){if(a(e))return Y(s(e),n,r);if(c(e))return te(re(e),n,r);if(u(e))return te(e,n,r);if(i(e))return te(e.toArray(),n,r);throw new t(null,"LogicError",null,{reason:"conversion error"})}function ie(e,n,r){const s=q(r);if(s&&3!==r){return e.getAngle(n).extractAngularUnits(s)}throw new t(null,"LogicError",null,{reason:"conversion error"})}function oe(e,n,t){const r=e.getAngle(n);if(3===n&&3===t){const t=W.secondsToDMS(r.extractAngularUnits(2));return[H(e.getMeridian(n),"SHORT"),t.m_degrees,t.m_minutes,t.m_seconds,H(e.getDirection(n),"SHORT")]}if(3===t){const e=W.secondsToDMS(r.extractAngularUnits(2));return[e.m_degrees,e.m_minutes,e.m_seconds]}return 3===n?[H(e.getMeridian(n),"SHORT"),r.extractAngularUnits(t),H(e.getDirection(n),"SHORT")]:[r.extractAngularUnits(t)]}function ce(e,n){let r="";switch(e){case 1:r=3===n?"DD.DD"+b:"DDD.DD"+b;break;case 3:r=3===n?"dd"+b+" mm' ss\"":"ddd"+b+" mm' ss.ss\"";break;case 4:r="R.RR";break;case 5:r="GGG.GG"+N;break;default:throw new t(null,"LogicError",null,{reason:"conversion error"})}return 3===n&&(r="p "+r+" b"),r}function ae(e,n,t){const r={padding:0,rounding:0,newpos:n};let s=!1;for(;n<e.length;){const i=e[n];if(i===t)s?r.rounding++:r.padding++,n++;else{if("."!==i)break;s=!0,n++}}return r.newpos=n-1,r}function ue(e,n,t){const r={escaped:"",newpos:n};for(n++;n<e.length;){const t=e[n];if(n++,"]"===t)break;r.escaped+=t}return r.newpos=n-1,r}function le(e,n,t){let r="",s=null,i=null;const o=J.createFromStringAndBearing(n,e,t),c={D:1,d:6,m:7,s:8,R:4,G:5};for(let a=0;a<n.length;a++){const u=n[a];switch(u){case"[":s=ue(n,a),r+=s.escaped,a=s.newpos;continue;case"D":case"d":case"m":case"s":case"R":case"G":s=ae(n,a,u),i=e.getAngle(t),r+=K(i,c[u],s.padding,s.rounding,o),a=s.newpos;continue;case"P":case"p":r+=H(o.fetchMeridian(),"p"===u?"SHORT":"LONG");continue;case"B":case"b":r+=H(o.fetchDirection(),"b"===u?"SHORT":"LONG");continue;default:r+=u}}return r}const de=new n(["TEXT","VALUE"]);function he(n,s,i){if(!(s instanceof e))throw new t(null,"InvalidParameter",null);if(!1===s.hasField("directionType"))throw new t(null,"LogicError",null,{reason:"missing directionType"});if(!1===s.hasField("angleType"))throw new t(null,"LogicError",null,{reason:"missing angleType"});const o=z(O(s.field("directiontype"))),c=se(n,C(O(s.field("angletype"))),o);if(!(i instanceof e))throw new t(null,"InvalidParameter",null);if(!1===i.hasField("directionType"))throw new t(null,"LogicError",null,{reason:"missing directionType"});if(!1===i.hasField("outputType"))throw new t(null,"LogicError",null,{reason:"missing angleType"});const a=z(O(i.field("directiontype"))),u=i.hasField("angleType")?C(O(i.field("angletype"))):null,l=de.get(O(i.field("outputType")));if(!a||!l)throw new t(null,"LogicError",null,{reason:"conversion error"});if(!(u||"TEXT"===l&&i.hasField("format")))throw new t(null,"LogicError",null,{reason:"invalid unit"});switch(l){case"VALUE":return 3===a||3===u?oe(c,a,u):ie(c,a,u);case"TEXT":{let e="";return i.hasField("format")&&(e=r(i.field("format"))),null!==e&&""!==e||(e=ce(u,a)),le(c,e,a)}default:throw new t(null,"InvalidParameter",null)}}export{he as convertDirection,f as preciseAdd,D as preciseDivide,w as preciseMinus,A as preciseMultiply};
