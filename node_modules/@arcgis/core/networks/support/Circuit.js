/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import{isSome as o}from"../../core/arrayUtils.js";import{JSONSupport as e}from"../../core/JSONSupport.js";import i from"../../core/Logger.js";import{watch as s,initial as r}from"../../core/reactiveUtils.js";import{property as n}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import{reader as a}from"../../core/accessorSupport/decorators/reader.js";import{subclass as c}from"../../core/accessorSupport/decorators/subclass.js";import{writer as p}from"../../core/accessorSupport/decorators/writer.js";import l from"./CircuitLocation.js";import u from"./CircuitSection.js";import d from"./Subcircuit.js";import{CircuitTypeKebabDict as h,CircuitStatusKebabDict as y}from"./typeUtils.js";let m=class extends e{constructor(t){super(t),this._sectionIdLookup=new Map,this.attributes=null,this.circuitManager=null,this.circuitType="physical",this.globalId=null,this.isDeleted=!1,this.lastExportedTime=null,this.lastVerifiedTime=null,this.name=null,this.sections=null,this.startLocation=null,this.status="dirty",this.stopLocation=null,this.subcircuits=[]}initialize(){this.addHandles([s(()=>this.sections,t=>{this._sectionIdLookup.clear(),null!=t&&Array.from(t.keys()).forEach(t=>this._sectionIdLookup.set(t.sectionId,t))},r)])}normalizeCtorArgs(t){if(void 0===t)return t;const{name:o,startLocation:e,stopLocation:s,sections:r}=t;return(e||s)&&r?(delete t.startLocation,delete t.stopLocation,i.getLogger(this).warn("Cannot instantiate Circuit with both start/stop locations and sections.",`Circuit '${o}' was defaulted to having sections only.`)):(e&&!s||!e&&s)&&!r&&i.getLogger(this).warn(`Non-sectioned circuit '${o}' must have both start and stop locations.`,"Create/alter operations involving this circuit will fail unless both are populated."),t}get isSectioned(){return null==this.startLocation&&null==this.stopLocation&&null!=this.sections}readSections(t,e){const{sectionOrder:i,sections:s}=e,r=new Map;if(null==s)return null;if(this._sectionIdLookup.clear(),s.forEach(t=>this._sectionIdLookup.set(t.sectionId,u.fromJSON(t))),null==i)return Array.from(this._sectionIdLookup.values()).forEach(t=>r.set(t,[])),r;for(const[n,a]of Object.entries(i)){const t=Number(n),e=this._sectionIdLookup.get(t);if(null==e)continue;const i=a.map(t=>this._sectionIdLookup.get(t)).filter(o);r.set(e,i)}return r}writeSections(t,o){const e={},i=[];t?.forEach((t,o)=>{const s=o.sectionId.toString(),r=t.map(t=>t.sectionId);e[s]=r,i.push(o.toJSON())}),o.sectionOrder=e,o.sections=i}getSectionById(t){return this._sectionIdLookup.get(t)??null}setStartStopLocations(t,o){this.startLocation=t,this.stopLocation=o,this.sections=null}setSections(t){this.sections=t,this.startLocation=null,this.stopLocation=null}getAttribute(t){return this.attributes?.[t]}setAttribute(t,o){this.attributes?this.attributes[t]=o:this.attributes={[t]:o}}};t([n({json:{write:{allowNull:!0,writer:(t,o)=>o.attributes=t??{}}}})],m.prototype,"attributes",void 0),t([n()],m.prototype,"circuitManager",void 0),t([n({type:h.apiValues,json:{type:h.jsonValues,read:h.read,write:h.write}})],m.prototype,"circuitType",void 0),t([n({type:String,json:{write:!0}})],m.prototype,"globalId",void 0),t([n({type:Boolean,readOnly:!0})],m.prototype,"isDeleted",void 0),t([n({type:Boolean,json:{write:!0},readOnly:!0})],m.prototype,"isSectioned",null),t([n({type:Date,json:{read:{reader:t=>"number"==typeof t?new Date(t):null}},readOnly:!0})],m.prototype,"lastExportedTime",void 0),t([n({type:Date,json:{read:{reader:t=>"number"==typeof t?new Date(t):null}},readOnly:!0})],m.prototype,"lastVerifiedTime",void 0),t([n({type:String,json:{write:!0}})],m.prototype,"name",void 0),t([n({json:{read:{source:["sectionOrder","sections"]},write:!0}})],m.prototype,"sections",void 0),t([a("sections")],m.prototype,"readSections",null),t([p("sections")],m.prototype,"writeSections",null),t([n({type:l,json:{write:!0}})],m.prototype,"startLocation",void 0),t([n({type:y.apiValues,json:{type:y.jsonValues,read:y.read}})],m.prototype,"status",void 0),t([n({type:l,json:{write:!0}})],m.prototype,"stopLocation",void 0),t([n({type:[d],json:{write:!0}})],m.prototype,"subcircuits",void 0),m=t([c("esri.networks.support.Circuit")],m);export{m as default};
