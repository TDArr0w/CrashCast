/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../request.js";import{JSONSupportMixin as s}from"../core/JSONSupport.js";import{Loadable as r}from"../core/Loadable.js";import{sqlIn as o,sqlAnd as n,sqlOr as i}from"../core/sql.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/Logger.js";import"../core/RandomLCG.js";import{subclass as c}from"../core/accessorSupport/decorators/subclass.js";import{getAssetFieldNames as u,getRuleValues as p,getCompatibleRuleElements as l,getFeatureSourceLayerId as d,doesRuleAllowAssociation as y}from"./support/utils.js";import{isGraphic as h}from"../support/guards.js";let f=class extends(s(r)){constructor(e){super(e),this.rulesCategorized={attachment:[],containment:[],connectivity:[]},this.request=t}initialize(){}async load(e){const t=this.rulesLayer.load(e).then(()=>this._initializeRulesTable());return this.addResolvingPromise(t),this}getFeaturesCanAssociateWithClause(e,t,s){const r=new Map,[i,a]=u(e.sourceLayer);if(!i||!a)return"";const c=p(e),d=p(t);s.forEach(e=>{const{type:t,direction:s}=e;this._getRulesForAssociationType(t).forEach(e=>{l(e,c,s).filter(e=>e.networkSource?.layerId===d.layerId).forEach(e=>{const t=e.assetGroup?.assetGroupCode,s=e.assetType?.assetTypeCode;if(null!=t&&null!=s){const e=r.get(t)??new Set;e.add(s),r.set(t,e)}})})});let y=[];return this._mergeAssetCodes(r).forEach((e,t)=>{const s=`${i} IN (${t})`,r=o(a,[...e]);s&&r&&y.push(n(s,r))}),y.length>1&&(y=y.map(e=>`(${e})`)),y.join(" OR ")}getFeaturesCanAssociateWith(e,t,s){return null==d(e)?[]:t.filter(t=>this.canAssociateFeatures(e,t,s))}canAssociateFeatures(e,t,s){if(!this._canSupportAssociations([e,t]))return!1;const r=p(e),o=p(t);return s.some(e=>{const{type:t,direction:s}=e;return this._getRulesForAssociationType(t).some(e=>"to"===s?y(e,o,r):y(e,r,o))})}getLayersCanAssociateWith(e,t,s){return null==d(e)?[]:t.filter(t=>this.canAssociateFeatureToLayer(e,t,s))}canAssociateFeatureToLayer(e,t,s){if(!this._canSupportAssociations([e,t]))return!1;const r=p(e),o=p(t);return s.some(e=>{const{type:t,direction:s}=e;return this._getRulesForAssociationType(t).some(e=>"to"===s?y(e,o,r):y(e,r,o))})}getFeatureSQL(e,t){const s=e.layerId.toString(),r=e.fieldsIndex?.normalizeFieldName("assetGroup"),o=e.fieldsIndex?.normalizeFieldName("assetType"),n=r?t.attributes[r]:null,i=o?t.attributes[o]:null,a=this.rulesHash[s];if(a){const e=a.assetGroupHash[n];if(e){return e.assetTypeHash[i]||null}}return null}_initializeRulesTable(){const e={},t=[{networkSourceId:"fromNetworkSource",assetGroupId:"fromAssetGroup",assetTypeId:"fromAssetType"},{networkSourceId:"toNetworkSource",assetGroupId:"toAssetGroup",assetTypeId:"toAssetType"},{networkSourceId:"viaNetworkSource",assetGroupId:"viaAssetGroup",assetTypeId:"viaAssetType"}];this.rulesCategorized={attachment:[],containment:[],connectivity:[]};for(const s of this.rules){if(3===s.ruleType){this.rulesCategorized.attachment.push(s);continue}if(2===s.ruleType){this.rulesCategorized.containment.push(s);continue}if(1===s.ruleType){this.rulesCategorized.connectivity.push(s);continue}this.rulesCategorized.connectivity.push(s);let r=[[0,1],[1,0]];5===s.ruleType&&(r=[[0,2],[2,0],[1,2],[2,1]]);for(const o of r){const r=o.shift(),a=o.shift();let c=!1;switch(s.ruleType){case 5:c=0===r||1===r;break;case 4:c=1===r}const u=t[r],p=s[u.networkSourceId]?.layerId.toString()??"",l=s[u.assetGroupId]?.assetGroupCode?.toString(),d=s[u.assetTypeId],y=d?.assetTypeCode?.toString(),h=t[a],f=s[h.networkSourceId]?.layerId.toString()??"",m=s[h.assetGroupId]?.assetGroupCode?.toString(),g=s[h.assetTypeId],T=g?.assetTypeCode?.toString(),S=e[p]??{assetGroupHash:{}};if(!(l&&y&&m&&T))continue;const v=S.assetGroupHash[l]??{assetTypeHash:{}},A=v.assetTypeHash[y]??{};if(A[f]=A[f]??{},c){A[p]=A[p]??{};const e=n(`assetgroup = ${l}`,`assettype = ${y}`);"esriNECPEndVertex"===g?.connectivityPolicy?A[p].endVertex=A[p]?.endVertex?`${A[p].endVertex}`:`(${e})`:A[p].anyVertex=A[p].anyVertex?`${A[p].anyVertex}`:`(${e})`}const C=n(`assetgroup = ${m}`,`assettype = ${T}`);"esriNECPEndVertex"===g?.connectivityPolicy?A[f].endVertex=A[f]?.endVertex?i(A[f].endVertex,C):`(${C})`:A[f].anyVertex=A[f]?.anyVertex?i(A[f].anyVertex,C):`(${C})`,v.assetTypeHash[y]=A,S.assetGroupHash[l]=v,e[p]=S}}this._set("rulesHash",e)}_getRulesForAssociationType(e){const{rulesCategorized:t}=this;switch(e){case"attachment":return t.attachment;case"containment":return t.containment;case"connectivity":case"junction-junction-connectivity":return t.connectivity.filter(e=>1===e.ruleType);case"junction-edge-from-connectivity":case"junction-edge-midspan-connectivity":case"junction-edge-to-connectivity":return t.connectivity.filter(e=>4===e.ruleType||5===e.ruleType);default:return[]}}_areSetsEqual(e,t){if(e.size!==t.size)return!1;for(const s of e)if(!t.has(s))return!1;return!0}_mergeAssetCodes(e){const t=new Map,s=new Set;for(const[r,o]of e){const n=new Set([r]);for(const[t,a]of e)r!==t&&!s.has(t)&&this._areSetsEqual(o,a)&&(n.add(t),s.add(t));const i=Array.from(n).sort().join(",");t.set(i,o)}return t}_canSupportAssociations(e){return e.every(e=>{const t=h(e)?e.sourceLayer:e,[s,r]=u(t);return null!=s&&null!=r})}};e([a({constructOnly:!0})],f.prototype,"rulesLayer",void 0),e([a({constructOnly:!0})],f.prototype,"rules",void 0),e([a({readOnly:!0})],f.prototype,"rulesHash",void 0),e([a()],f.prototype,"rulesCategorized",void 0),e([a({constructOnly:!0})],f.prototype,"request",void 0),f=e([c("esri.networks.RulesTable")],f);export{f as default};
