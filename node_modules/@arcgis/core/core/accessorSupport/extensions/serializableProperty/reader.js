/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../../Logger.js";import{setDeepValue as e}from"../../../object.js";import r from"../../../Warning.js";import{getPropertiesMetadata as n}from"../../metadata.js";import{isCollection as o}from"./type.js";import{originSpecificReadPropertyDefinition as i}from"./utils.js";const p=()=>t.getLogger("esri.core.accessorSupport.extensions.serializableProperty.reader");function u(t,r,n){t&&(!n&&!r.read||r.read?.reader||!1===r.read?.enabled||m(t)&&e("read.reader",s(t),r))}function s(t){const e=t.ndimArray??0;if(e>1)return a(t);if(1===e)return d(t);if("type"in t&&l(t.type)){const e=t.type.prototype?.itemType?.Type,r=d("function"==typeof e?{type:e}:{types:e});return(e,n,o)=>{const i=r(e,n,o);return i?new t.type(i):i}}return y(t)}function y(t){return"type"in t?f(t.type):v(t.types)}function f(t){return t.prototype.read?(e,r,n)=>{if(null==e)return e;const o=typeof e;if("object"!==o)return void p().error(`Expected JSON value of type 'object' to deserialize type '${t.prototype.declaredClass}', but got '${o}'`);const i=new t;return i.read(e,n),i}:t.fromJSON}function c(t,e,r,n){return 0!==n&&Array.isArray(e)?e.map(e=>c(t,e,r,n-1)):t(e,void 0,r)}function a(t){const e=y(t),r=c.bind(null,e),n=t.ndimArray??0;return(t,e,o)=>{if(null==t)return t;t=r(t,o,n);let i=n,p=t;for(;i>0&&Array.isArray(p);)i--,p=p[0];if(void 0!==p)for(let r=0;r<i;r++)t=[t];return t}}function d(t){const e=y(t);return(t,r,n)=>{if(null==t)return t;if(Array.isArray(t)){const r=[];for(const o of t){const t=e(o,void 0,n);void 0!==t&&r.push(t)}return r}const o=e(t,void 0,n);return void 0!==o?[o]:void 0}}function l(t){if(!o(t))return!1;const e=t.prototype.itemType;return!(!e||!e.Type)&&("function"==typeof e.Type?j(e.Type):g(e.Type))}function m(t){return"types"in t?g(t.types):j(t.type)}function j(t){return!Array.isArray(t)&&(!!t&&t.prototype&&("read"in t.prototype||"fromJSON"in t||l(t)))}function g(t){for(const e in t.typeMap){if(!j(t.typeMap[e]))return!1}return!0}function v(t){let e=null;const n=t.errorContext??"type",o=t.validate;return(i,u,s)=>{if(null==i)return i;const y=typeof i;if("object"!==y)return void p().error(`Expected JSON value of type 'object' to deserialize, but got '${y}'`);e||(e=b(t));const f=t.key;if("string"!=typeof f)return;const c=i[A(f,e,s)],a=c?e[c]:t.defaultKeyValue?t.typeMap[t.defaultKeyValue]:void 0;if(!a){const t=`Type '${c||"unknown"}' is not supported`;return s?.messages&&i&&s.messages.push(new r(`${n}:unsupported`,t,{definition:i,context:s})),void p().error(t)}const d=new a;return d.read(i,s),o?o(d):d}}function A(t,e,r){const o=Object.values(e)[0],p=n(o.prototype)[t],u=i(p,r),s=u?.read?.source;return s&&"string"==typeof s?s:t}function b(t){const e={};for(const r in t.typeMap){const o=t.typeMap[r],i=n(o.prototype);if("function"==typeof t.key)continue;const p=i[t.key];if(!p)continue;if(p.json?.type&&Array.isArray(p.json.type)&&1===p.json.type.length&&"string"==typeof p.json.type[0]){e[p.json.type[0]]=o;continue}const u=p.json?.write;if(!u?.writer){e[r]=o;continue}const s=u.target,y="string"==typeof s?s:t.key,f={};u.writer(r,f,y),f[y]&&(e[f[y]]=o)}return e}export{u as create,s as createTypeReader};
