/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clock as t}from"./clock.js";import r from"./Error.js";import{once as e}from"./events.js";import n from"./Logger.js";import{removeMaybe as o}from"./maybe.js";async function i(t,r){const e=t.slice(),n=await Promise.all(t.map((t,e)=>r(t,e)));return e.filter((t,r)=>n[r])}function u(t="Aborted"){return new r("AbortError",t)}function s(t,r="Aborted"){if(a(t))throw u(r)}function c(t,r="Aborted"){if(t?.destroyed)throw u(r)}function l(t){return t instanceof AbortSignal?t:t?.signal??void 0}function a(t){const r=l(t);return null!=r&&r.aborted}function f(t){if(d(t))throw t}function m(t){if(!d(t))throw t}function w(t,r){const n=l(t);if(null!=n){if(!n.aborted)return e(n,"abort",()=>r());r()}}function h(t,r){const n=l(t);if(null!=n)return s(n),e(n,"abort",()=>r(u()))}function p(t,r){return null==l(r)?t:new Promise((e,n)=>{let i=w(r,()=>n(u()));const s=()=>{i=o(i)};t.then(s,s),t.then(e,n)})}function b(t,e,n){return Promise.race([t,T(e).then(()=>{throw new r("timeout",`Did not resolve within ${e} milliseconds (${n??"timeout"})`)})])}function d(t){return"AbortError"===t?.name}async function y(t){try{return await t}catch(r){if(!d(r))throw r;return}}async function v(t,r=n.getLogger("esri")){try{return await t}catch(e){d(e)||r.error(e)}}async function j(t){if(!t)return;if("function"!=typeof t.forEach){const r=Object.keys(t),e=r.map(r=>t[r]),n=await j(e),o={};return r.map((t,r)=>o[t]=n[r]),o}const r=t;return Promise.allSettled(r).then(t=>Array.from(r,(r,e)=>{const n=t[e];return"fulfilled"===n.status?{promise:r,value:n.value}:{promise:r,error:n.reason}}))}async function g(t){return(await j(t)).filter(t=>!!t.value).map(t=>t.value)}async function A(t){return(await Promise.allSettled(t)).filter(t=>"fulfilled"===t.status).map(t=>t.value)}async function P(t){return(await Promise.allSettled(t)).filter(t=>"rejected"===t.status).map(t=>t.reason)}function T(t,r=void 0,e){const n=new AbortController;return w(e,()=>n.abort()),new Promise((e,o)=>{let i=setTimeout(()=>{i=0,e(r)},t);w(n,()=>{i&&(clearTimeout(i),o(u()))})})}function E(t,e,n,o){const i=n&&"abort"in n?n:null;null!=o||i||(o=n);let u=setTimeout(()=>{u=0,i?.abort()},e);const s=()=>o||new r("promiseUtils:timeout","The wrapped promise did not resolve within "+e+" ms");return t.then(t=>{if(0===u)throw s();return clearTimeout(u),t},t=>{throw clearTimeout(u),0===u?s():t})}function S(t,r){const e=new AbortController,n=setTimeout(()=>e.abort(),r);return w(t,()=>{e.abort(),clearTimeout(n)}),{...t,signal:e.signal}}function C(t){return t&&"function"==typeof t.then}function k(t){return C(t)?t:Promise.resolve(t)}function L(t,r=-1){let e,n,o,i,s=null;const c=(...l)=>{if(e){n=l,i&&i.reject(u()),i=$();const t=i.promise;if(s){const t=s;s=null,t.abort()}return t}if(o=i||$(),i=null,r>0){const n=new AbortController;e=k(t(...l,n.signal));const o=e;T(r).then(()=>{e===o&&(i?n.abort():s=n)})}else e=1,e=k(t(...l));const a=()=>{const t=n;n=o=e=s=null,null!=t&&c(...t)},f=e,m=o;return f.then(a,a),f.then(m.resolve,m.reject),m.promise};return c}function $(){let r,e;const n=new Promise((t,n)=>{r=t,e=n}),o=t=>{r(t)};return o.resolve=t=>r(t),o.reject=t=>e(t),o.timeout=(r,e)=>t.setTimeout(()=>o.reject(e),r),o.promise=n,o}function x(t,r){return t.then(r,r)}function D(t,r){r.then(t.resolve,t.reject)}async function O(t){await Promise.resolve(),s(t)}export{T as after,P as allSettledErrors,A as allSettledValues,x as always,u as createAbortError,$ as createResolver,L as debounce,j as eachAlways,g as eachAlwaysValues,i as filter,y as ignoreAbortErrors,d as isAbortError,a as isAborted,C as isPromiseLike,v as logOnError,w as onAbort,h as onAbortOrThrow,D as settleWithPromise,l as signalFromSignalOrOptions,f as throwIfAbortError,s as throwIfAborted,c as throwIfDestroyed,m as throwIfNotAbortError,E as timeout,O as waitTick,k as when,p as whenOrAbort,b as whenOrTimeout,S as wrapAbortWithTimeout};
