/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../../core/RandomLCG.js";import{Placement as s}from"../CIMPlacements.js";const i=512,e=10,h=24,n=1e-6;class _{static{this.instance=null}static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(t,s,i,e){return new r(t,s,i,e)}}class r{constructor(e,h,n,_){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(h.stepX??16)*n,this._stepY=Math.abs(h.stepY??16)*n,this._stepX=Math.round(128*this._stepX)/128,this._stepY=Math.round(128*this._stepY)/128,0!==this._stepX&&0!==this._stepY){if(this._gridType=h.gridType??"Fixed","Random"===this._gridType){const s=h.seed??13,i=1;this._randomLCG=new t(s*i),this._randomness=(h.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues()}else{if(this._randomness=0,this._gridAngle=h.gridAngle??0,this._shiftOddRows=h.shiftOddRows??!1,this._offsetX=(h.offsetX??0)*n,this._offsetY=(h.offsetY??0)*n,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=_){const[t,s,e,h]=_.split("/"),n=parseFloat(t),r=parseFloat(s),a=parseFloat(e),o=parseFloat(h);this._graphicOriginX=-(o*2**n+a)*i,this._graphicOriginY=r*i,this._testInsidePolygon=!0}this._internalPlacement=new s,this._calculateMinMax(e),this._geometryCursor=e}}next(){return this._geometryCursor?this._nextInside():null}_buildRandomValues(){if(!r._randValues){r._randValues=[];for(let t=0;t<h;t++)for(let s=0;s<h;s++)r._randValues.push(this._randomLCG.getFloat()),r._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(t){let s,e,h,n,_,r,a,o,l,f,c,u,p,M;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,a=o=p=c=Number.MAX_VALUE,l=f=M=u=-Number.MAX_VALUE;const g=1!==this._cosAngle;for(t.reset();t.nextPath();)for(;t.nextPoint();)r=t.x,_=t.y,s=r-this._graphicOriginX-this._offsetX,e=_-this._graphicOriginY-this._offsetY,g?(h=this._cosAngle*s-this._sinAngle*e,n=this._sinAngle*s+this._cosAngle*e):(h=s,n=e),a=Math.min(a,h),l=Math.max(l,h),o=Math.min(o,n),f=Math.max(f,n),c=Math.min(c,_),u=Math.max(u,_),p=Math.min(p,r),M=Math.max(M,r);c=c!==Number.MAX_VALUE?c:-i-this._stepY,u=u!==-Number.MAX_VALUE?u:this._stepY,p=p!==Number.MAX_VALUE?p:-this._stepX,M=M!==-Number.MAX_VALUE?M:i+this._stepX;const d=u-c,X=M-p;if(this._verticalSubdivision=d>=X,this._polygonMin=this._verticalSubdivision?c:p,this._testInsidePolygon){let t=0-this._graphicOriginX-this._offsetX-this._stepX,s=i-this._graphicOriginX-this._offsetX+this._stepX,e=-i-this._graphicOriginY-this._offsetY-this._stepY,h=0-this._graphicOriginY-this._offsetY+this._stepY;if(g){const i=[[t,e],[t,h],[s,e],[s,h]];t=e=Number.MAX_VALUE,s=h=-Number.MAX_VALUE;for(const n of i){const i=this._cosAngle*n[0]-this._sinAngle*n[1],_=this._sinAngle*n[0]+this._cosAngle*n[1];t=Math.min(t,i),s=Math.max(s,i),e=Math.min(e,_),h=Math.max(h,_)}}a=a!==Number.MAX_VALUE?Math.max(a,t):t,o=o!==Number.MAX_VALUE?Math.max(o,e):e,l=l!==-Number.MAX_VALUE?Math.min(l,s):s,f=f!==-Number.MAX_VALUE?Math.min(f,h):h}this._xMin=Math.round(a/this._stepX),this._xMax=Math.round(l/this._stepX),this._yMin=Math.round(o/this._stepY),this._yMax=Math.round(f/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._buildAccelerationMap(t,p,M,c,u)}_buildAccelerationMap(t,s,h,n,_){t.reset();const r=new Map,a=this._verticalSubdivision,l=a?_-n:h-s;let f=Math.ceil(l/e);if(f<=1)return;const c=Math.floor(l/f);let u,p,M,g,d,X,m,x,A,Y,y;for(f++,this._delta=c,a?(A=-i-2*this._stepY,Y=2*this._stepY,y=n):(A=-2*this._stepX,Y=i+2*this._stepX,y=s);t.nextPath();)if(!(t.pathSize<2)&&t.nextPoint())for(u=t.x,p=t.y;t.nextPoint();u=M,p=g){if(M=t.x,g=t.y,a){if(p===g||p<A&&g<A||p>Y&&g>Y)continue;d=Math.min(p,g),X=Math.max(p,g)}else{if(u===M||u<A&&M<A||u>Y&&M>Y)continue;d=Math.min(u,M),X=Math.max(u,M)}for(;d<X;)m=Math.floor((d-y)/c),o(m,u,p,M,g,r),d+=c;x=Math.floor((X-y)/c),x>m&&o(x,u,p,M,g,r)}this._accelerationMap=r}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let t=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(t+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let i,e;if(this._currentX++,"Random"===this._gridType){const n=(this._currentX%h+h)%h,_=(this._currentY%h+h)%h;i=this._graphicOriginX+t+this._stepX*this._randomness*(.5-r._randValues[_*h+n])*2/3,e=this._graphicOriginY+s+this._stepY*this._randomness*(.5-r._randValues[_*h+n+1])*2/3}else i=this._graphicOriginX+this._cosAngle*t+this._sinAngle*s,e=this._graphicOriginY-this._sinAngle*t+this._cosAngle*s;if(!this._testInsidePolygon||this._isInsidePolygon(i,e,this._geometryCursor))return this._internalPlacement.setTranslate(i,e),this._internalPlacement}}_isInsidePolygon(t,s,i){if(null==this._accelerationMap)return a(t,s,i);t+=n,s+=n;const e=this._verticalSubdivision,h=e?s:t,_=Math.floor((h-this._polygonMin)/this._delta),r=this._accelerationMap.get(_);if(!r)return!1;let o,l,f,c=0;for(const n of r){if(o=n[0],l=n[1],e){if(o[1]>s==l[1]>s)continue;f=(l[0]-o[0])*(s-o[1])-(l[1]-o[1])*(t-o[0])}else{if(o[0]>t==l[0]>t)continue;f=(l[1]-o[1])*(t-o[0])-(l[0]-o[0])*(s-o[1])}f>0?c++:c--}return 0!==c}}function a(t,s,i){let e,h,_,r,a=0;for(t+=n,s+=n,i.reset();i.nextPath();)if(i.nextPoint())for(e=i.x,h=i.y;i.nextPoint();e=_,h=r){if(_=i.x,r=i.y,h>s==r>s)continue;(_-e)*(s-h)-(r-h)*(t-e)>0?a++:a--}return 0!==a}function o(t,s,i,e,h,n){let _=n.get(t);_||(_=[],n.set(t,_)),_.push([[s,i],[e,h]])}export{_ as PlacementInsidePolygon};
