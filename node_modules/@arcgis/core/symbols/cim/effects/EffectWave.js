/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{GeometryCursor as t}from"../../../geometry/GeometryCursor.js";import{DashPattern as e,GeometryWalker as i,Pos as s}from"../GeometryWalker.js";class h{static{this.instance=null}static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(t,e,i){return new n(t,e,i)}}class n{constructor(t,s,h){this._inputGeometries=t,this._height=(void 0!==s.amplitude?s.amplitude:2)*h,this._period=(void 0!==s.period?s.period:3)*h,this._style=s.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new e,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new i,this._walker.updateTolerance(h)}next(){let t=this._inputGeometries.next();for(;t;){if(0===this._height||0===this._period)return t;const e=this._processGeom(t);if(e)return e;t=this._inputGeometries.next()}return null}_processGeom(e){const i=t.createEmptyOptimizedCIM(e.geometryType);for(;e.nextPath();){i.startPath();const t=e.pathLength();if(this._walker.init(e,this._pattern))switch(this._style){case"Sinus":default:this._constructCurve(i,t,!1);break;case"Square":this._constructSquare(i,t);break;case"Triangle":this._constructTriangle(i,t);break;case"Random":this._constructCurve(i,t,!0)}else for(;e.nextPoint();)i.pushXY(e.x,e.y)}return i}_constructCurve(t,e,i){let h=Math.round(e/this._period);0===h&&(h=1);const n=h*16+1,r=e/h,a=this._period/16,o=1/n,p=2*Math.PI*e/r,_=2*Math.PI*Math.random(),c=2*Math.PI*Math.random(),l=2*Math.PI*Math.random(),u=.75-Math.random()/2,d=.75-Math.random()/2,g=new s;this._walker.curPointAndAngle(g),t.pushPoint(g.pt);let w=0;for(;;){if(!this._walker.nextPointAndAngle(a,g)){t.pushPoint(this._walker.getPathEnd());break}{const e=w;let s;if(w+=o,i){const t=this._height/2*(1+.3*Math.sin(u*p*e+_));s=t*Math.sin(p*e+c),s+=t*Math.sin(d*p*e+l),s/=2}else s=.5*this._height*Math.sin(.5*p*e);t.pushXY(g.pt[0]-s*g.sa,g.pt[1]+s*g.ca)}}}_constructSquare(t,e){Math.round(e/this._period);let i=!0;for(;;){let e=!1;if(this._walker.curPositionIsValid()){const h=new s;this._walker.curPointAndAngle(h);const n=new s;if(this._walker.nextPointAndAngle(this._period,n)){const r=new s;this._walker.nextPointAndAngle(this._period,r)&&(i?(t.pushPoint(h.pt),i=!1):t.pushPoint(h.pt),t.pushXY(h.pt[0]-this._height/2*h.sa,h.pt[1]+this._height/2*h.ca),t.pushXY(n.pt[0]-this._height/2*n.sa,n.pt[1]+this._height/2*n.ca),t.pushXY(n.pt[0]+this._height/2*n.sa,n.pt[1]-this._height/2*n.ca),t.pushXY(r.pt[0]+this._height/2*r.sa,r.pt[1]-this._height/2*r.ca),e=!0)}}if(!e){t.pushPoint(this._walker.getPathEnd());break}}}_constructTriangle(t,e){Math.round(e/this._period);let i=!0;for(;;){let e=!1;if(this._walker.curPositionIsValid()){const h=new s;this._walker.curPointAndAngle(h);const n=new s;if(this._walker.nextPointAndAngle(this._period/2,n)){const r=new s;this._walker.nextPointAndAngle(this._period,r)&&(this._walker.nextPosition(this._period/2)&&(i?(t.pushPoint(h.pt),i=!1):t.pushPoint(h.pt),t.pushXY(n.pt[0]-this._height/2*n.sa,n.pt[1]+this._height/2*n.ca),t.pushXY(r.pt[0]+this._height/2*r.sa,r.pt[1]-this._height/2*r.ca)),e=!0)}}if(!e){t.pushPoint(this._walker.getPathEnd());break}}}}export{h as EffectWave};
