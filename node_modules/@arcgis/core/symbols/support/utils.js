/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../Color.js";import{forEach as t}from"../../core/asyncUtils.js";import"../../core/has.js";import{px2pt as r}from"../../core/screenUtils.js";import{ONES as o}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{effectFunctionsFromJSON as n}from"../../layers/effects/jsonUtils.js";import{applyCIMSymbolRotation as l,getCIMSymbolColor as i}from"./cimSymbolUtils.js";import{getStroke as c}from"./gfxUtils.js";import{Symbol3DMaterial as s}from"./Symbol3DMaterial.js";import{isSymbol3D as u,isSymbol2D as a}from"./typeUtils.js";function f(e){const t=e.symbolLayers?.at(-1);if(t&&"outline"in t)return t?.outline?.size}function m(e){if(!e)return 0;if(u(e)){const t=f(e);return null!=t?t:0}return r(c(e)?.width)}function y(e){const t=e.symbolLayers?.at(-1);if(t&&"outline"in t)return t?.outline?.color}function p(t){if(!t)return null;if(u(t))return y(t);const r=c(t)?.color;return r?new e(r):null}function h(e){if(null==e||!("symbolLayers"in e)||null==e.symbolLayers)return!1;switch(e.type){case"point-3d":return e.symbolLayers.some(e=>"object"===e.type);case"line-3d":return e.symbolLayers.some(e=>"path"===e.type);case"polygon-3d":return e.symbolLayers.some(e=>"object"===e.type||"extrude"===e.type);default:return!1}}function d(e){return e.resource?.href??""}function b(t,r){if(!t)return null;let o=null;return u(t)?o=w(t):a(t)&&(o="cim"===t.type?i(t):t.color?new e(t.color):null),o?k(o,r):null}function w(t){const r=t.symbolLayers;if(!r)return null;let o=null;return r.forEach(e=>{"object"===e.type&&e.resource?.href||(o="water"===e.type?e.color:e.material?e.material.color:null)}),o?new e(o):null}function k(t,r){if(null==r||null==t)return t;const o=t.toRgba();return o[3]=o[3]*r,new e(o)}function j(t,r,o){const n=t.symbolLayers;if(!n)return;const l=(t,n=!1)=>{let l=r??t??null;return null!=o?.override&&(!l&&n&&(l=new e([255,255,255])),l&&(l.a=o.override)),k(l,o?.add)};n.forEach(e=>{if("water"===e.type)return void(e.color=k(e.color,o?.add));const t=null!=e.material?e.material.color:null,r=l(t,"icon"===e.type&&null!=e.resource?.href);null==e.material?e.material=new s({color:r}):e.material.color=r,"outline"in e&&e.outline?.color&&null!=o?.add&&(e.outline.color=k(e.outline.color,o.add)),"marker"in e&&null!=e.marker&&(e.marker.color=l(e.marker.color))})}function g(e,t,r){t=t??e.color,null!=r?.override&&t&&(t.a=r.override),t&&(e.color=k(t,r?.add)),"outline"in e&&e.outline?.color&&(e.outline.color=k(e.outline.color,r?.add))}function L(t,r,o){t&&(r||null!=o)&&(r&&(r=new e(r)),u(t)?j(t,r,o):a(t)&&g(t,r,o))}async function v(e,r){const o=e.symbolLayers;o&&await t(o,async e=>z(e,r))}async function z(e,t){switch(e.type){case"extrude":U(e,t);break;case"icon":case"line":case"text":x(e,t);break;case"path":O(e,t);break;case"object":await E(e,t)}}function x(e,t){const r=S(t);null!=r&&(e.size=r)}function S(e){for(const t of e)if("number"==typeof t)return t;return null}function U(e,t){const r=t[2];"number"==typeof r&&(e.size=r)}async function E(e,t){const{resourceSize:r,symbolSize:o}=await C(e),n=R(t,r,o);null!=n&&(e.width=D(t[0],o[0],r[0],n),e.depth=D(t[1],o[1],r[1],n),e.height=D(t[2],o[2],r[2],n))}function O(e,t){const r=R(t,o,[e.width,void 0,e.height]);null!=r&&(e.width=D(t[0],e.width,1,r),e.height=D(t[2],e.height,1,r))}function R(e,t,r){for(let o=0;o<3;o++){const n=e[o];switch(n){case"symbol-value":{const e=r[o];return null!=e?e/t[o]:1}case"proportional":break;default:if(n&&t[o])return n/t[o]}}return null}async function C(e){const{computeObjectLayerResourceSize:t}=await import("./symbolLayerUtils.js"),r=await t(e,10),{width:o,height:n,depth:l}=e,i=[o,l,n];let c=1;for(let s=0;s<3;s++){const e=i[s];if(null!=e){c=e/r[s];break}}for(let s=0;s<3;s++)null==i[s]&&(i[s]=r[s]*c);return{resourceSize:r,symbolSize:i}}function D(e,t,r,o){switch(e){case"proportional":return r*o;case"symbol-value":return null!=t?t:r;default:return e}}function J(e,t){const r=S(t);if(null!=r)switch(e.type){case"simple-marker":e.size=r;break;case"picture-marker":{const t=e.width/e.height;t>1?(e.width=r,e.height=r*t):(e.width=r*t,e.height=r);break}case"simple-line":e.width=r;break;case"text":e.font.size=r}}async function M(e,t){if(e&&t)return u(e)?v(e,t):void(a(e)&&J(e,t))}function N(e,t,r){if(e&&null!=t)if(u(e)){const o=e.symbolLayers;o&&o.forEach(e=>{if("object"===e.type)switch(r){case"tilt":e.tilt=(e.tilt??0)+t;break;case"roll":e.roll=(e.roll??0)+t;break;default:e.heading=(e.heading??0)+t}"icon"===e.type&&(e.angle+=t)})}else if(a(e))switch(e.type){case"simple-marker":case"picture-marker":case"text":e.angle+=t;break;case"cim":l(e,t,!0)}}function q(e,t){if(!e)return null;const r=(t?e.effects:e.effects.filter(e=>"bloom"!==e.type)).map(e=>e.toJSON());return n(r)}function A(e){return null!=e&&"polygon-3d"===e.type&&e.symbolLayers.some(e=>"extrude"===e.type)}export{L as applyColorToSymbol,k as applyOpacityToColor,N as applyRotationToSymbol,M as applySizesToSymbol,q as getCSSFilterFromEffectList,b as getColorFromSymbol,d as getIconHref,p as getSymbolOutlineColor,m as getSymbolOutlineSize,h as isVolumetricSymbol,A as symbolHasExtrudeSymbolLayer};
