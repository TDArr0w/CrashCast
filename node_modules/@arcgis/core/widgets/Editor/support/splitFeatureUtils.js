/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{splitSegmentAtPoint as t}from"../../../editing/geometry/lineUtils.js";import n from"../../../geometry/Polyline.js";import{isCurvedGeometry as o,getEndpoint as r}from"../../../geometry/support/curves/curveUtils.js";import{createCoordinateHelper as i}from"../../../views/interactive/coordinateHelper.js";async function a(t,n){if("point"===t.type||"extent"===t.type||"mesh"===t.type)throw new e("editing:unsupported-split-geometry",`Cannot split geometry of type ${t.type}`);if("point"===n.type&&c(t))return await l(t,n);if("polyline"===n.type&&y(t))return s(t,n);if("polygon"===n.type&&u(t))return p(t,n);throw new e("editing:unsupported-split-geometry",`Geometry of type ${n.type} cannot be used to split geometry of type ${t.type}`)}async function l(a,l){const{apiConverter:p,arcadeMeasures:{pointToCoordinate:s},lengthOperator:c}=await f(),u=p.fromSpatialReference(a.spatialReference)?.getTolerance()??.001,y=s(a,l);if(null==y||null==y.distance||y.distance>u)return null;const d=s(a,y.coordinate);if(null==d||null==d.distanceAlong||null==d.partId||null==d.segmentId)throw new e("editing:split-by-point-failed","Failed to determine the split point on the polyline.");const m=d.coordinate.hasZ&&a.hasZ,g=i(m,a.hasM,a.spatialReference),h=o(a),w=h?a.curvePaths:a.paths,j=[],I=[];for(let e=0;e<w.length;e++){const n=w[e];if(e<d.partId)j.push(n);else if(e>d.partId)I.push(n);else{const e=[],o=[];for(let i=0;i<n.length;i++){const a=n[i];if(i<d.segmentId)e.push(a);else if(i>d.segmentId)o.push(a);else{const l=r(a),p=n.at(i+1),s=g.pointToArray(d.coordinate);if(i++,!p){e.push(a,s),o.push(s);continue}const[c,y]=t(l,p,s,m,u);e.push(...c),o.push(...y)}}e.length>0&&j.push(e),o.length>0&&I.push(o)}}const P=new n({[h?"curvePaths":"paths"]:j,spatialReference:a.spatialReference,hasZ:a.hasZ,hasM:a.hasM}),O=new n({[h?"curvePaths":"paths"]:I,spatialReference:a.spatialReference,hasZ:a.hasZ,hasM:a.hasM}),v=c.execute(P),F=c.execute(O),b=Math.max(v,F);if(0===b)return null;const x=b===v?P:O;return{remainingPart:x,newPart:0===Math.min(v,F)?null:x===P?O:P}}async function p(e,t){const{differenceOperator:n,intersectionOperator:o}=await d(),r=o.execute(e,t);if(!r)return null;const i=n.execute(e,t);return i?{newPart:r,remainingPart:i}:{newPart:null,remainingPart:r}}async function s(e,t){const{cutOperator:n}=await m(),o=n.execute(e,t);if(2!==o.length)return null;const r=o[0];return{newPart:o[1]??null,remainingPart:r}}function c(e){return"polyline"===e.type}function u(e){return"polygon"===e.type||"polyline"===e.type||"multipoint"===e.type}function y(e){return"polygon"===e.type||"polyline"===e.type}async function f(){const[e,t,n]=await Promise.all([import("../../../geometry/operators/support/apiConverter.js"),import("../../../arcade/functions/measures.js"),import("../../../geometry/operators/lengthOperator.js")]);return{apiConverter:e,lengthOperator:n,arcadeMeasures:t}}async function d(){const[e,t]=await Promise.all([import("../../../geometry/operators/differenceOperator.js"),import("../../../geometry/operators/intersectionOperator.js")]);return{differenceOperator:e,intersectionOperator:t}}async function m(){return{cutOperator:await import("../../../geometry/operators/cutOperator.js")}}function g(e){return"multipoint"===e||"polygon"===e||"polyline"===e}function h(t){if(!t)throw new e("editing:cannot-split-geometry","No geometry provided.");if(u(t)||y(t)||c(t))return t;throw new e("editing:cannot-split-geometry",`Cannot split geometry of type ${t.type}`)}function w(e,t){return"point"===t&&c(e)||"polyline"===t&&y(e)||"polygon"===t&&u(e)?t:j(e)}function j(e){return"polyline"===e.type?"point":"polyline"}function I(e){const t=e?.type;return"point"===t||"polyline"===t||"polygon"===t}function P(e,t){const{fieldsIndex:n}=t,o={...e};if("globalIdField"in t&&t.globalIdField){delete o[n.get(t.globalIdField)?.name??t.globalIdField]}if(t.objectIdField){delete o[n.get(t.objectIdField)?.name??t.objectIdField]}if("relationships"in t&&t.relationships)for(const r of t.relationships)if("one-to-one"===r.cardinality||"origin"===r.role&&"one-to-many"===r.cardinality){const e=n.get(r.keyField)?.name??r.keyField;null!=o[e]&&delete o[e]}return o}export{c as canSplitByPoint,h as ensureSplittableGeometry,w as getCompatibleSpitterGeometryType,j as getDefaultSplitterGeometryType,g as isSplittableGeometryType,I as isSplitterGeometry,P as makeNewFeatureAttributes,a as splitGeometry};
