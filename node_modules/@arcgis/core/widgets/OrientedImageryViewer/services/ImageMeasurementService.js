/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{throwIfAborted as e}from"../../../core/promiseUtils.js";import{distance as t}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{projectWithZConversion as a}from"../../../geometry/projectionUtils.js";import{imageToWorld as i,imageToWorldPanoramic as r}from"../../../layers/orientedImagery/transformations/imageToWorld.js";import{getImageToWorldProperties as n,convertSphereVertexToPixelLocation as s}from"../../../layers/orientedImagery/transformations/utils.js";import{formatPixels as l,heightMeasurementPanoramic as c,heightMeasurement2D as o,calculateHeightAccuracyPanoramic as u,calculateHeightAccuracy as m,pixelAreaMeasurement2D as w,pixelAreaMeasurementPanoramic as d,pixelDistanceMeasurement2D as M,pixelDistanceMeasurementPanoramic as h,generateCombinations as g,getRootOfSumOfSquaredErrors as v,generateCombinationsPanoramic as p,calculateLocationAccuracyFromDeviations as f,calculateReferenceImagePointPanoramic as y,calculateAnglePano as _,calculateTempImagePoint as P,calculateAngle as A,computeTriangulatedAreaMeasurement as z,computeTriangulatedDistanceMeasurement as x}from"../imageMeasurementUtils.js";class b{constructor(e){this._viewModel=e}async computeHeight(e,t,a=!0){const{currentBestFeature:i,activeViewer:r,layer:s,footprintExtent:w}=this._viewModel,d=r?.imageSize,M=i?.attributes,h=s?.orientationAccuracy;if(!M||!d||!e||e.length<2||!h)return;const g="panoramic"===t?await this._viewModel.getMeasurementPropertiesPanoramic():n(M,d[0],d[1]),v=e.at(0),p=e.at(-1);if(!(g&&v&&p&&h&&w))return;const f=[p,v],y=l(f,!1),_="panoramic"===t?await c(f,g,h,i,!0,!1):await o(f,g,h,!0,a);if(!_)return;const P="panoramic"===t?await u(h,y,g,_,i,!0):await m(h,y,g,_,!0);return P?{value:_,accuracy:P}:{value:_}}async calculateAreaMeasurement(t,a,i){if(t.length<3||!this._viewModel.currentBestFeature||!this._viewModel.activeViewer?.imageSize||"none"===this._viewModel.mode)return null;const r="default"===a?await this._viewModel.getMeasurementProperties():await this._viewModel.getMeasurementPropertiesPanoramic();return e(i),r?"default"===a?await w(t,r,!0):await d(t,r,!0,i):null}async calculateDistanceMeasurement(t,a,i){const{currentBestFeature:r,activeViewer:n}=this._viewModel;if(t.length<2||!r||!n?.imageSize||"none"===a)return null;const s="default"===a?await this._viewModel.getMeasurementProperties():await this._viewModel.getMeasurementPropertiesPanoramic();return e(i),s?"default"===a?await M([t.at(0),t.at(-1)],s,!0):await h([t.at(0),t.at(-1)],s,!0):null}async calculateAccuracy(t,a,i){const{layer:r,currentBestFeature:n,activeViewer:s,currentBestFeatureMeasurementImage:l,triangularMeasurementActive:c,imageMeasurementViewer:o}=this._viewModel,u=r?.orientationAccuracy,m=u?.every(e=>0===e)||!u?.length;if("area"===a&&t.length<3||"distance"===a&&t.length<2||!n||!s?.imageSize||m)return null;let d=null;if(c&&l&&o?d=await this._viewModel.getMeasurementProperties(l,o):(d=await this._viewModel.getMeasurementProperties(),e(i)),!d)return null;const h="area"===a?await w(t,d,!0):await M([t.at(0),t.at(-1)],d,!0);e(i);const{updateElevationProps:p,...f}=d,y=g(f,u);if(!y?.length)return null;const _=y.map(e=>({...e,updateElevationProps:p})).map(async r=>{const n="area"===a?await w(t,r,!0):await M([t.at(0),t.at(-1)],r,!0);if(e(i),n&&h){if("area"===a){const e="number"!=typeof n?n.area:null;return e?Math.abs(e-h.area):null}return Math.abs(n-h)}return null}),P=await Promise.all(_);e(i);const A=P.filter(e=>null!==e);return 0===A.length?null:v(A)}async calculateLocationAccuracy(t,n,s="default",l){const{layer:c,currentBestFeature:o}=this._viewModel,u=c?.orientationAccuracy,m=this._viewModel.view?.spatialReference,w=u?.every(e=>0===e)||!u?.length;if(!o||w)return null;const d="default"===s?await this._viewModel.getMeasurementProperties():await this._viewModel.getMeasurementPropertiesPanoramic();if(e(l),!d)return null;const{updateElevationProps:M,...h}=d,v="default"===s?g(h,u):p(h,u);if(!v?.length)return null;const y=v.map(e=>({...e,updateElevationProps:M})).map(async c=>{const{updateElevationProps:o,...u}=c;let w="default"===s?await i(t,u,o):await r(t,u,o);return e(l),m&&!w.spatialReference.equals(m)&&(w=await a(w,m),e(l)),w&&n?[Math.abs(w.x-n.x),Math.abs(w.y-n.y),w.z&&n.z?Math.abs(w.z-n.z):0]:null}),_=await Promise.all(y);if(e(l),!_?.length)return null;const P=_.map(e=>[e?.[0]??0,e?.[1]??0,e?.[2]??0]),[A,z,x]=f(P);return{x:A,y:z,z:x}}async calculateAccuracyPanoramic(t,a,i=!1,r){const{layer:n,currentBestFeature:s,activeViewer:l,mode:c,currentBestFeatureMeasurementImage:o,activeTriangulatedViewer:u}=this._viewModel,m=n?.orientationAccuracy,w=m?.every(e=>0===e)||!m?.length;if("area"===a&&t.length<3||"distance"===a&&t.length<2||!s||!l?.imageSize||w||"panoramic"!==c)return null;const M=i&&o&&u?await this._viewModel.getMeasurementPropertiesPanoramic(o,u):await this._viewModel.getMeasurementPropertiesPanoramic();if(e(r),!M)return null;const g="area"===a?await d(t,M,!0):await h([t.at(0),t.at(-1)],M,!0);e(r);const{updateElevationProps:f,...y}=M,_=p(y,m);if(!_?.length)return null;const P=_.map(e=>({...e,updateElevationProps:f})).map(async i=>{const n="area"===a?await d(t,i,!0):await h([t.at(0),t.at(-1)],i,!0);if(e(r),n&&g){if("area"===a){const e="number"!=typeof n?n.area:null;return e?Math.abs(e-g.area):null}return Math.abs(n-g)}return null}),A=await Promise.all(P);e(r);const z=A.filter(e=>null!==e);return 0===z.length?null:v(z)}async calculateHeightMeasurementInfo(e,a,i){const{currentBestFeature:r,activeViewer:s}=this._viewModel,c=s?.imageSize;if(!r||!s||!c?.length||"none"===a)return;const{attributes:o}=r,[u]=l([e],"panoramic"!==a),m="panoramic"===a?await this._viewModel.getMeasurementPropertiesPanoramic():n(o,c[0],c[1]);if("panoramic"===a){if(!m)return;const e=await y(u,m,r,i);if(!e)return;e?.heading>180&&(e.heading-=360);const a=_(u,e),n=t([u.x,u.y],[e.x,e.y]);if(!a||!n)return;return{measurementAngle:a,tempDistance:n}}const w=await P(u,m,i);if(!w)return;const d=A(u,w),M=t([u.x,u.y],[w.x,w.y]);return d&&M?{measurementAngle:d,tempDistance:M}:void 0}async calculateTriangulatedMeasurements(e){if(!this._viewModel.activeTriangulatedViewer?.imageSize)return;const[t,a]=this._viewModel.activeTriangulatedViewer.imageSize;switch(this._viewModel.measureType){case"distance":{this._viewModel.triangulatedDistanceMeasurement=await x(this._viewModel.measurementVectors);const i=e.map(([e,i,r])=>s({x:e,y:i,z:r},t,a)).map(({x:e,y:t})=>[e,t]),r="default"===this._viewModel.mode?await this.calculateAccuracy(e,"distance"):await this.calculateAccuracyPanoramic(i,"distance",!0);if(r&&this._viewModel.triangulatedDistanceMeasurement?.distance){const e=Math.atan(r/this._viewModel.triangulatedDistanceMeasurement.distance);this._viewModel.triangulatedDistanceAccuracy={distanceAccuracy:r,angleAccuracy:e}}break}case"area":if(this._viewModel.currentBestFeatureMeasurementImage?.geometry.spatialReference)if(this._viewModel.triangulatedAreaMeasurement=await z(this._viewModel.measurementVectors,this._viewModel.currentBestFeatureMeasurementImage.geometry.spatialReference),"default"===this._viewModel.mode)this._viewModel.triangulatedAreaAccuracy=await this.calculateAccuracy(e,"area")??this._viewModel.triangulatedAreaAccuracy;else if("panoramic"===this._viewModel.mode){const i=e.map(([e,i,r])=>s({x:e,y:i,z:r},t,a)).map(({x:e,y:t})=>[e,t]);this._viewModel.triangulatedAreaAccuracy=await this.calculateAccuracyPanoramic(i,"area",!0)??this._viewModel.triangulatedAreaAccuracy}}if("panoramic"===this._viewModel.mode){this._viewModel.activeTriangulatedViewer.viewModel.restoreNavigationHandles()}}}export{b as ImageMeasurementService};
