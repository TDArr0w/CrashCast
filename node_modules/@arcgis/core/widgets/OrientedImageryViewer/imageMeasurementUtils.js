/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{rad2deg as t}from"../../core/mathUtils.js";import{throwIfAborted as e}from"../../core/promiseUtils.js";import{formatArea as n,formatLength as r}from"../../core/quantityFormatUtils.js";import{createArea as a,createLength as o}from"../../core/quantityUtils.js";import{set as i,determinant as s}from"../../core/libs/gl-matrix-2/math/mat3.js";import{create as c}from"../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as u,fromValues as l}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{distance as f}from"../../core/libs/gl-matrix-2/math/vec2.js";import{j as m,i as p,a as h}from"../../chunks/vec32.js";import y from"../../geometry/Point.js";import g from"../../geometry/Polygon.js";import w from"../../geometry/Polyline.js";import{projectWithZConversion as x,project as R}from"../../geometry/projectionUtils.js";import M from"../../geometry/SpatialReference.js";import{e as z}from"../../chunks/areaOperator.js";import{l as d,e as P}from"../../chunks/geodeticAreaOperator.js";import{l as v,e as j}from"../../chunks/geodeticDensifyOperator.js";import{l as b,e as O}from"../../chunks/geodeticLengthOperator.js";import{e as E}from"../../chunks/lengthOperator.js";import{e as L}from"../../chunks/simplifyOperator.js";import{isSupported as I,geodesicLengths as W,geodesicAreas as k}from"../../geometry/support/geodesicUtils.js";import{imageToWorldPanoramic as q,imageToWorld as G}from"../../layers/orientedImagery/transformations/imageToWorld.js";import{convertSphereVertexToPixelLocation as A,scaleWithFactor as D}from"../../layers/orientedImagery/transformations/utils.js";import{worldToImagePanoramic as U,worldToImage as B}from"../../layers/orientedImagery/transformations/worldToImage.js";const S=1e5,F="meters",T="square-meters";function H(t,e){let n=180*Math.atan2(-t.y+e.y,t.x-e.x)/Math.PI;return n<0&&(n+=180),n*Math.PI/180}function V(t,e){let n=180*Math.atan2(-t.y+e.y,t.x-e.x)/Math.PI;return n<0&&(n+=180),n*Math.PI/180}function C(t,e,n){if(!t?.length||!e?.length||!n)return;const[r,a]=t,[,o]=e,i=o-a;return[r+i*Math.cos(n),a+i*Math.sin(n)]}async function J(t,e,n){if(await v(),I(t)){const t=W([e],F)[0];return{area:k([n],T)[0],perimeter:t}}const r=M.WGS84,a=R(e,r),o=R(n,r);let i=j(o,S);if(i=i?L(i):null,!i)return null;const s=W([a],F)[0];return{area:k([i],T)[0],perimeter:s}}async function K(t,n,r,a,o=!1,i){if(n.length<2||!a||!r||!t)return null;const s=zt(r,t);if(!s)return null;const c=n.map(t=>[t.x,t.y]),u=c.at(0),l=c.at(-1);if(!u||!l)return null;const f=s.map(e=>It([u,l],e,t,o,!1)),m=await Promise.all(f);e(i);let p=0;for(const e of m){if(!e)return null;const t=Math.abs(e-a);p=Math.max(t,p)}return p}async function N(t,n,r,a,o,i=!1,s){if(n.length<2||!a||!r||!t)throw new Error("Missing parameters");const c=dt(r,t),u=n.map(t=>[t.x,t.y]),l=u.at(0),f=u.at(-1),m=c.map(e=>Wt([l,f],e,t,o,i,!1)),p=await Promise.all(m);e(s);let h=0;for(const e of p){if(!e)return 0;const t=Math.abs(e-a);h=Math.max(t,h)}return h}function Q(t,e,n=1){const r=Rt(t,!1);if(!r?.length)return;return 20*f([r[0].x,r[0].y],[r.at(-1).x,r.at(-1).y])*n/e}async function X(t){await b();const e=t.spatialReference;if(e.isGeographic){if(I(e))return W([t],F)[0];const n=R(t,M.WGS84);return W([n],F)[0]}return e.isWebMercator?O(t,{unit:F}):E(t,{unit:F})}function Y(t){if(!t?.length)throw new Error("Invalid deviations array");const[e,n,r]=[0,1,2].map(e=>t.map(t=>t[e]).filter(t=>null!==t)).map(t=>t.length?jt(t):0);return[e,n,r]}function Z(t,e){const n=L(e);if(!n)return null;const r=E(t,{unit:F});return{area:z(n,{unit:T}),perimeter:r}}function $(t,e){return[(t[1][0]-t[0][0])/e,(t[1][1]-t[0][1])/e,(t[1][2]-t[0][2])/e]}async function _(t,e){await Promise.all([d(),v(),b()]);let n=j(e,S);if(n=n?L(n):null,!n)return null;const r=O(t,{unit:F});return{area:P(n,{unit:T}),perimeter:r}}async function tt(t,n,r){if(!n||!t)throw new Error("Missing required parameters");const a=await G(t,n);e(r);const o=a.clone();o.z?o.z+=20:o.z=20;const{averageElevation:i,cameraPitch:s,cameraRoll:c,farDistance:u,...l}=n;return B(o,l)}async function et(t,n,r,a){const{attributes:o}=r,{location:i}=o,{updateElevationProps:s,...c}=n;if(!t||!n)throw new Error("Missing parameters");let u=i.clone();u.spatialReference.isGeographic&&(u=await x(u,M.WebMercator));const l=await q(t,{...c,cameraLocation:u},s);e(a);const f=l.clone();return f.z?f.z+=20:f.z=20,U(f,c)}function nt(t,e,n,r,a=0,o=1,i){const{averageElevation:s,cameraPitch:c,cameraRoll:u,farDistance:l,...m}=r;if(a>=5||o<=.1){return{value:t*Ot(r.cameraLocation.spatialReference)}}const p=new y({x:e.x,y:e.y,z:e.z?e.z+t:t,spatialReference:r.cameraLocation.spatialReference}),h=B(p,m),g=f([n[0].x,n[0].y],[h.x,h.y]),w=n.at(0),x=n.at(-1);if(!w||!x)return null;const R=f([w.x,w.y],[x.x,x.y])*t/g;return nt(R,e,n,r,a+1,Math.abs(t-R))}function rt(t,e,n,r,a=0,o=1,i){const{averageElevation:s,horizontalFieldOfView:c,verticalFieldOfView:u,farDistance:l,...m}=r;if(a>=5||o<=.1){return{value:t*Ot(r.cameraLocation.spatialReference)}}const p=new y({x:e.x,y:e.y,z:e.z?e.z+t:t,spatialReference:r.cameraLocation.spatialReference}),h=U(p,m),g=f([n[0].x,n[0].y],[h.x,h.y]),w=n.at(0),x=n.at(-1);if(!w||!x)return null;const R=f([w.x,w.y],[x.x,x.y])*t/g;return rt(R,e,n,r,a+1,Math.abs(t-R))}async function at(t,e,n){return t.spatialReference&&!e.spatialReference.equals(t.spatialReference)&&(e=await x(e,t.spatialReference)),new w({paths:[[[t.x,t.y,t.z??0],[e.x,e.y,e.z??0]]],spatialReference:n})}function ot(t){return 1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/6378137)))}function it(t,e){return Math.sqrt((Math.sqrt((t[0][0]-t[1][0])**2+(t[0][1]-t[1][1])**2)/e)**2+(t[0][2]-t[1][2])**2)}function st(t,e){return Math.sqrt((t[0][0]-t[1][0])**2+(t[0][1]-t[1][1])**2)/e}function ct(e){return t(Math.atan((e[1][2]-e[0][2])/Math.sqrt((e[1][0]-e[0][0])**2+(e[1][1]-e[0][1])**2)))}function ut(e){let n=90-t(Math.atan2(e[1][1]-e[0][1],e[1][0]-e[0][0]));return n<0&&(n+=360),n}function lt(t,e){return new y({x:(t.pointOnA[0]+t.pointOnB[0])/2,y:(t.pointOnA[1]+t.pointOnB[1])/2,z:(t.pointOnA[2]+t.pointOnB[2])/2,spatialReference:e})}async function ft(t){if(2===t?.length){const e=[];let n=1;const[r,a]=t,o=r.camera.spatialReference,{measurePoints:i}=r;for(let t=0;t<i.length;t++){const i=await at(r.camera,r.measurePoints[t],o),s=await at(a.camera,a.measurePoints[t],o),c=await Dt(i,s);if(!c)return null;const u=lt(c,o);u.spatialReference.isWebMercator&&(n=ot(u.y)),e.push([u.x,u.y,u.z??0])}if(e?.length>1){return{distance:it(e,n),horizontalDistance:st(e,n),verticalDistance:Math.abs(e[0][2]-e[1][2]),slope:ct(e),aspect:ut(e)}}}return null}async function mt(t){const e=t[0].camera.spatialReference;if(2!==t?.length)return null;const[n,r]=t,{camera:a,measurePoints:o}=n,{camera:i,measurePoints:s}=r,c=await at(a,o[0],e),u=await at(i,s[0],e),l=await Dt(c,u);return l?lt(l,e)??null:null}async function pt(t,e){if(!t?.length)return null;const n=[],r=t[0],a=t[1],o=r.camera.spatialReference,{measurePoints:i}=r;for(let l=0;l<i.length;l++){const t=await at(r.camera,r.measurePoints[l],o),e=await at(a.camera,a.measurePoints[l],o),i=await Dt(t,e);if(!i)return null;const s=lt(i,o);n.push([s.x,s.y,s.z??0])}if(n?.length<2)return null;const s=new w({paths:[n],spatialReference:e}),c=new g({rings:[n],spatialReference:e});if(e.isGeographic){const t=await J(e,s,c);return t?.area??null}if(e.isWebMercator){const t=await _(s,c);return t?.area??null}const u=Z(s,c);return u?.area??null}function ht(t,e){if(!t)return null;return{camera:e.geometry.clone(),measurePoints:Array.isArray(t)?t:[t]}}async function yt(t,e){const{updateElevationProps:n,...r}=e;return await G(t,r,n)}async function gt(t,e){const{updateElevationProps:n,...r}=e;return q(t,r,n)}function wt(t){navigator.clipboard.writeText(t).catch(t=>{throw t})}function xt(t){const e=t.map(t=>[t.x,t.y]),n=t[0].spatialReference;return new w({paths:[e],spatialReference:n})}function Rt(t,e){return t.map(t=>({x:e?.5+t[0]:t[0],y:e?.5-t[1]:t[1]}))}function Mt(t,e,n,a,i){const s="measurement"===t?e:n;if(i&&s)return r(a,o(s,F),i,3)||null}function zt(t,e){const{cameraPitch:n,cameraRoll:r,cameraLocation:a}=t,{x:o,y:i,z:s,spatialReference:c}=a;if(e.every(t=>0===t)||!e||!e.length)return null;const[u,l,,f,m]=e,p=[-f,0,f],h=[-m,0,m],g=[-u,0,u],w=[-l,0,l],x=[];for(const R of p)for(const e of h)for(const a of g)for(const u of g)for(const l of w){const f={...t};f.cameraPitch=n+R,f.cameraRoll=r+e,f.cameraLocation=new y({x:o+a,y:i+u,z:s?s+l:0,spatialReference:{wkid:c.wkid}}),x.push(f)}return x}function dt(t,e){const{cameraHeading:n,cameraLocation:r}=t,{x:a,y:o,z:i,spatialReference:s}=r;if(e.every(t=>0===t)||!e||!e.length)throw new Error("Invalid parameters");const[c,u,l]=e,f=l>0?[-l,0,l]:[],m=c>0?[-c,0,c]:[],p=u>0?[-u,0,u]:[],h=[];for(const g of f)for(const e of m)for(const r of m)for(const c of p){const u={...t};u.cameraHeading=n+g,u.cameraLocation=new y({x:a+e,y:o+r,z:i?i+c:0,spatialReference:{wkid:s.wkid}}),h.push(u)}return h}function Pt(t,e,n,a,i){const s="measurement"===t?e:jt(n);if(i&&s)return r(a,o(s,F),i,3)||null}function vt(t,e,r,o,i){const s="measurement"===t?e:r;if(i&&s)return n(o,a(s,T),i,3)||null}function jt(t){return Math.sqrt(t.reduce((t,e)=>t+e**2,0))}function bt(t,e,n){if("default"===e)return t;const r={x:t[0],y:t[1],z:t[2]},a=A(r,n[0],n[1]);return[a.x,a.y]}function Ot(t){return t.metersPerUnit}function Et(t,e,n){let r=[];return r="panoramic"===e?t.map(([t,e,r])=>{const{x:a,y:o}=A({x:t,y:e,z:r},n[0],n[1]);return[a-.5,-.5-o]}):t.map(([t,e])=>[t-.5,-.5-e]),r}function Lt(t,e){return t.map(t=>A({x:t[0],y:t[1],z:t[2]},e[0],e[1]))}async function It(t,n,r,a=!1,o=!1,i){if(!t||!n||t.length<2)return null;const s=Rt(t,a);if(!s||s.length<2)return null;const[c,u]=[s[0],s.at(-1)];if(!u)return null;const l=[c],m=await G(c,n);e(i);const p=m.clone();p.z?p.z+=20:p.z=20;const{averageElevation:h,cameraPitch:y,cameraRoll:g,farDistance:w,...x}=n,R=B(p,x),M=f([c.x,c.y],[R.x,R.y]),z=H(c,R);if(!z)return;const d=C([c.x,c.y],[u.x,u.y],z);if(!d?.length)return;l.push({x:d[0],y:d[1]});const P=20*f([l[0].x,l[0].y],[l[1].x,l[1].y])*Ot(n.cameraLocation.spatialReference)/M;if(!o)return P;const v=nt(P,m,l,n,0,1);return v?.value}async function Wt(t,n,r,a,o=!1,i=!1,s){const{attributes:c}=a,{location:u}=c,{updateElevationProps:l,...m}=n;if(!t||!n||t.length<2)throw new Error("Invalid parameters");const p=Rt(t,o),[h,y]=[p[0],p.at(-1)],g=[h];let w=u.clone();w.spatialReference.isGeographic&&(w=await x(w,M.WebMercator));const R=await q(h,{...m,cameraLocation:w},l);e(s);const z=R.clone();z.z?z.z+=20:z.z=20;const d=U(z,m),P=f([h.x,h.y],[d.x,d.y]),v=H(h,d);if(!v)return;const j=C([h.x,h.y],[y.x,y.y],v);if(!j?.length)return;g.push({x:j[0],y:j[1]});const b=20*f([g[0].x,g[0].y],[g[1].x,g[1].y])*Ot(n.cameraLocation.spatialReference)/P;if(!i)return b;const O=rt(b,R,g,n,0,1);return O?.value}async function kt(t,e,n=!1){if(t.length<3)return null;const r=Rt(t,n),a=await yt(r,e),o=a.map(({x:t,y:e})=>[t,e]);t.push(t[0]),o.push(o[0]);const i=a[0].spatialReference,s=new w({paths:[o],spatialReference:i}),c=new g({rings:[o],spatialReference:i});return i.isGeographic?J(i,s,c):i.isWebMercator?_(s,c):Z(s,c)}async function qt(t,n,r=!1,a){if(t.length<3)return null;const o=Rt(t,r),i=await gt(o,n);e(a);const s=i.map(({x:t,y:e})=>[t,e]);t.push(t[0]),s.push(s[0]);const c=i[0].spatialReference,u=new w({paths:[s],spatialReference:c}),l=new g({rings:[s],spatialReference:c});return c.isGeographic?J(c,u,l):c.isWebMercator?_(u,l):Z(u,l)}async function Gt(t,e,n=!1){const r=Rt(t,n);return X(xt(await yt(r,e)))}async function At(t,n,r=!1,a){const o=Rt(t,r),i=await gt(o,n);e(a);return X(xt(i))}async function Dt(t,e){const n=c(),r=t.paths[0][0],a=e.paths[0][0];let o,u;t.spatialReference.isWGS84||t.spatialReference.isWebMercator?(await b(),o=O(t),u=O(e)):(o=E(t),u=E(e));const l=$(t.paths[0],o),f=$(e.paths[0],u),m=Ut(l,f),[p,h,y]=l,[g,w,x]=f.map(t=>-t),[R,M,z]=m,[d,P,v]=[a[0]-r[0],a[1]-r[1],a[2]-r[2]];i(n,p,g,R,h,w,M,y,x,z);const j=s(n);if(0===j)return null;i(n,d,g,R,P,w,M,v,x,z);const L=s(n);i(n,p,d,R,h,P,M,y,v,z);const I=s(n);i(n,p,g,d,h,w,P,y,x,v);const W=L/j,k=I/j,q=s(n)/j;return{distance:Math.abs(q/Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2])),pointOnA:Bt(r,W,l),pointOnB:Bt(a,k,f)}}function Ut(t,e){const n=u(),r=m(u(),t[0],t[1],t[2]),a=m(u(),e[0],e[1],e[2]),o=p(n,r,a);return[o[0],o[1],o[2]]}function Bt(t,e,n){return[t[0]+e*n[0],t[1]+e*n[1],t[2]+e*n[2]]}function St(t,e){const n=l(t[0],t[1],t[2]),r=l(e[0],e[1],e[2]);return h(u(),n,r)}function Ft(t,e,n){const r=D(t,e,n);return[r[0],r[1],r[2]]}export{H as calculateAngle,V as calculateAnglePano,C as calculateCorrectedPixel,K as calculateHeightAccuracy,N as calculateHeightAccuracyPanoramic,Q as calculateHeightFromTemporaryDistance,Y as calculateLocationAccuracyFromDeviations,et as calculateReferenceImagePointPanoramic,tt as calculateTempImagePoint,nt as computeHeightIteratively,rt as computeHeightIterativelyPanoramic,pt as computeTriangulatedAreaMeasurement,ft as computeTriangulatedDistanceMeasurement,mt as computeTriangulatedPoint,ht as computeTriangulatedVector,wt as copyToClipboard,Rt as formatPixels,zt as generateCombinations,dt as generateCombinationsPanoramic,vt as getConvertedArea,Pt as getConvertedDistance,Mt as getConvertedHeight,bt as getModeCorrectedPoint,Et as getModeCorrectedPoints,Lt as getPixelLocationFromSphereVertices,jt as getRootOfSumOfSquaredErrors,Ot as getUnitRateFromSpatialReference,It as heightMeasurement2D,Wt as heightMeasurementPanoramic,kt as pixelAreaMeasurement2D,qt as pixelAreaMeasurementPanoramic,Gt as pixelDistanceMeasurement2D,At as pixelDistanceMeasurementPanoramic,Ft as scale,Dt as solveSkewLinesIntersection,St as subtract};
