/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import{throwIfAborted as i,waitTick as o}from"../../../../core/promiseUtils.js";import a from"../../../../geometry/Mesh.js";import r from"../../../../geometry/Point.js";import{projectWithZConversion as s}from"../../../../geometry/projectionUtils.js";import{MeshVertexAttributes as n}from"../../../../geometry/support/MeshVertexAttributes.js";import{projectVertices as l,updateFrustum as c,createCoveragePolygon as p}from"../../../../layers/orientedImagery/core/coverageUtils.js";import{fixedImageSize as m}from"../../constants.js";import{activeFrustumSymbol as u,additionalFrustumSymbol as d}from"../../symbols.js";class f{constructor(r){this.viewModel=r,this._updateBestFeatureFootprintElevation=!1,this._updatedElevationSampler=null,this.createFootprints=async o=>{const{coverageFrustums:r,currentBestFeature:c,isAdditionalCoverageVisible:p,view:m}=this.viewModel,f=r.filter(t);for(const t of f){let r=t.clone();if(!m.spatialReference.equals(r.spatialReference)){const{components:e,spatialReference:t,origin:c,vertexAttributes:p,vertexSpace:u}=r;if("local"===u.type){const e=await s(c,m.spatialReference,o);i(o),r.centerAt(e)}else{const s=p.position,c=Float64Array.from(await l([...s],t.clone(),m.spatialReference.clone(),o));i(o),r=new a({vertexAttributes:new n({position:c}),components:e,spatialReference:m.spatialReference.clone()})}}t.imageID===c.attributes.objectId?(this._updateBestFeatureFootprintElevation=!0,this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:t.imageID},geometry:r,symbol:u.clone(),visible:!1})):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:t.imageID},geometry:r,symbol:d.clone(),visible:p}))}},this.updateFootprint=async(o,a,r)=>{const{bestFeatureFootprint:n,currentBestFeature:l,activeViewer:p,footprintExtent:d,view:f,mode:g}=this.viewModel,y="video"===g?m:p?.imageSize,b=a??l;if(!(l&&n?.geometry&&y&&d&&b&&f?.spatialReference))return void this.viewModel.updateCurrentCoveragePolygon(null);const{attributes:{cameraHeight:F,location:R,cameraPitch:M,horizontalFieldOfView:A,verticalFieldOfView:E,cameraRoll:x},elevationSample:S}=b;let j=null;if(a&&(this._updatedElevationSampler=l.elevationSample,j=await w(a,f.spatialReference),this._updatedElevationSampler)){const e=this._updatedElevationSampler?.extent,t=a.attributes.geometry;if(e&&!e.contains(t)){const e=this.viewModel.selectedPoint;if(!e)return;e.x=a.geometry.x,e.y=a.geometry.y;const t=await this.viewModel.processFeatureElevation([a],e);t&&(this._updatedElevationSampler=t)}const[i]=h([j],this._updatedElevationSampler,a);i&&(j=i)}S&&this._updateBestFeatureFootprintElevation&&(this.updateGroundElevation([n],S),this._updateBestFeatureFootprintElevation=!1);const I=R.toArray(),V=a&&j?j:n,{vertexAttributes:{position:z},spatialReference:P}=V.geometry,C=await v(z,P,R.spatialReference),_=await this.viewModel.getMapPoint(o,{feature:b,mode:"default",imageSize:y});i(r);let D=_.filter(t);if(!D.length)return;D[0].spatialReference.equals(R.spatialReference)||(D=await Promise.all(D.map(async e=>{const t=await s(e,R.spatialReference,r);return i(r),t})));const B=await c(o.map(({x:e,y:t})=>[e,t]),D.map(e=>e.toArray()),{cameraHeight:F,cameraLocation:I,cameraPitch:M,frustumVertices:C,horizontalFieldOfView:A,imageHeight:y[1],imageWidth:y[0],inSRS:{wkid:R.spatialReference.wkid},outSRS:{wkid:f.spatialReference.wkid},verticalFieldOfView:E,cameraRoll:x??0,options:r});this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:b.attributes.objectId},geometry:B,symbol:u.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(t,i)=>{await o(i);const{horizontalFieldOfView:a,pitch:r,verticalFieldOfView:s,yaw:n,feature:l}=t,c=l?.clone()??this.viewModel.currentBestFeature?.clone();if(!c)return;const{attributes:m}=c;m.orientedImageryType=null,m.cameraHeading=(n+m.cameraHeading)%360,m.cameraPitch=r,m.horizontalFieldOfView=a,m.verticalFieldOfView=s,m.cameraRoll=0;const{frustum:d}=p(m);d?this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:m.objectId},geometry:d,symbol:u.clone(),visible:this.viewModel.currentCoverageVisible})):this.viewModel.updateCurrentCoveragePolygon(null)}}updateGroundElevation(e,t){const{geometry:i,attributes:{elevation:o}}=this.viewModel.currentBestFeature,a=o??t.queryElevation(i)?.z??0;e.forEach(e=>{const{geometry:t}=e;switch(t?.type){case"mesh":{const{vertexAttributes:{position:e}}=t,i=Math.floor(e.length/3);for(let t=0;t<i;t+=1)e[3*t+2]+=a;break}case"point":t.z=(t.z??0)+a}})}}async function v(e,t,i,o){return Float64Array.from((await Promise.all(e.reduce((e,t,i)=>{const o=Math.floor(i/3);return e[o]=e[o]??[],e[o].push(t),e},new Array).map(async e=>(await s(new r(e,t),i,o)).toArray()))).flat())}const w=async(t,o,r)=>{const{frustum:c}=p(t.attributes);let m=c.clone();if(!o.equals(m.spatialReference)){const{components:e,spatialReference:t,origin:o,vertexAttributes:c,vertexSpace:p}=m;if("local"===p.type){const e=await s(o,t,r);i(r),m.centerAt(e)}else{const o=c.position,s=Float64Array.from(await l([...o],t.clone(),t.clone(),r));i(r),m=new a({vertexAttributes:new n({position:s}),components:e,spatialReference:t.clone()})}}return new e({attributes:{imageID:c.imageID},geometry:m,symbol:u.clone(),visible:!1})},h=(e,t,i)=>{const{geometry:o}=i,a=t.queryElevation(o);for(const r of e){const{geometry:e}=r;switch(e?.type){case"mesh":{const{vertexAttributes:{position:t}}=e,i=Math.floor(t.length/3);for(let e=0;e<i;e++)t[3*e+2]+=a?.z??0;break}case"point":e.z=(e.z??0)+(a?.z??0)}}return e};export{f as default};
