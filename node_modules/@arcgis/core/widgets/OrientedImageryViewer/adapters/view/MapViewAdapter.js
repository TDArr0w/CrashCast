/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import o from"../../../../core/Logger.js";import{waitTick as i,throwIfAborted as r,isAbortError as s}from"../../../../core/promiseUtils.js";import a from"../../../../geometry/Polygon.js";import{convertOrientationToPixelLocation as n}from"../../../../layers/orientedImagery/transformations/utils.js";import{fixedImageSize as l}from"../../constants.js";import{activePolygonSymbol as u,polygonSymbol as c}from"../../symbols.js";class m{constructor(m){this.viewModel=m,this.createFootprints=async t=>{await i(t);const{coveragePolygons:o,currentBestFeature:r,isAdditionalCoverageVisible:s}=this.viewModel;for(const i of o)i?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:i?.imageID},geometry:i,symbol:u,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:i?.imageID},geometry:i,symbol:c.clone(),visible:s}))},this.updateFootprint=async(i,n,c)=>{const{activeViewer:m,mode:p,currentBestFeature:d,currentCoverageVisible:g,footprintExtent:v}=this.viewModel,f="video"===p?l:m?.imageSize,h=n??d;if(d&&f&&v&&h)try{const o=await this.viewModel.getMapPoint(i,{feature:h,mode:"default",imageSize:f});r(c);const s=o.filter(t);if(!s.length)return;const n=[s.map(({x:e,y:t})=>[e,t,1])];n[0].push(n[0][0]);const l=new a({rings:n,spatialReference:s[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:l,attributes:{imageID:h.attributes.objectId},symbol:u,visible:g}))}catch(w){s(w)||o.getLogger(this.viewModel).error("update-footprint",w)}else this.viewModel.updateCurrentCoveragePolygon(null)},this.updateFootprintPanorama=async(t,o)=>{const{horizontalFieldOfView:i,pitch:s,verticalFieldOfView:c,yaw:m,feature:p}=t,{activeViewer:d,currentBestFeature:g,currentCoverageVisible:v,footprintExtent:f,mode:h}=this.viewModel,w="video"===h||"panoramic-video"===h?l:d?.imageSize,y=p??g;if(!y||!w||!f)return void this.viewModel.updateCurrentCoveragePolygon(null);const{cameraPitch:b,objectId:M}=y.attributes;if(s+b-c/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const C=[],P=c/2,j=i/2,F=s-P,I=b+F,D=b+(s+P);if(I>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const V=F<0,x=[-j,P],z=[j,P],R=[j,-P],S=[-j,-P];if(I<180&&D>180){C.push(V?R:S);const e=Math.floor(i/5),t=i/e;for(let o=0;o<=e;o++)C.push([o*t-j,90-s]);C.push(V?S:R)}D<180&&(C.push(x,z),V?C.push(S,R):C.push(R,S));const B=C.map(([e,t])=>n(m+e,s+t,w[0],w[1])),E=await this.viewModel.getMapPoint(B,{feature:y,mode:"panorama",imageSize:w});r(o);const L=[E.map(({x:e,y:t})=>[e,t,1])];L[0].push(L[0][0]);const O=new a({rings:L,spatialReference:E[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:O,attributes:{imageID:M},symbol:u.clone(),visible:v}))}}}export{m as default};
