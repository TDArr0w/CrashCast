/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import{EsriPromise as t}from"../../../../core/Promise.js";import{throwIfAborted as a}from"../../../../core/promiseUtils.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as i}from"../../../../core/accessorSupport/decorators/subclass.js";import{projectWithZConversion as s}from"../../../../geometry/projectionUtils.js";import{convertSphereVertexToPixelLocation as o}from"../../../../layers/orientedImagery/transformations/utils.js";import{getModeCorrectedPoints as n,computeTriangulatedVector as c,computeTriangulatedAreaMeasurement as m,computeTriangulatedDistanceMeasurement as u}from"../../imageMeasurementUtils.js";import{TriangulatedSketchHandlerMixin as l}from"../../mixins/TriangulatedSketchHandlerMixin.js";let d=[],p=class extends(l(t)){constructor(e){super(e),this.type="measurement"}async handleUpdate(e){const{measureType:t,updatingTriangularMeasurementState:a}=this.viewModel;if(this._preventLeftMouseDrag(),"distance"===t){const t=e.graphics[0].geometry;d=t.paths[0]}else if("area"===t){const t=e.graphics[0].geometry;d=t.rings[0]}"complete"===e.state&&(this.viewModel.triangulatedMeasurementGraphic=e.graphics.at(-1),a?await this._updateTriangularMeasurements(d):await this.viewModel.processMeasurementVectors(d))}async _computeMeasurementVector(e,t){const{activeViewer:a,mode:r,view:i}=this.viewModel,o=a?.imageSize;if(!e||!t||!o)return;const m=n(e,r,o),u=i?.spatialReference,l=[];for(let n=0;n<m.length;n++){const e={x:m[n][0],y:m[n][1]};let a=await this.viewModel.getMapPoint(e,{feature:t,imageSize:o,mode:r});u&&!a.spatialReference.equals(u)&&(a=await s(a,u)),l.push(a)}return c(l,t)}async _updateTriangularMeasurements(e,t){const{measureType:r,mode:i,activeTriangulatedViewer:s,triangularMeasurementActive:n,currentBestFeatureMeasurementImage:c,updatingTriangularMeasurementState:l}=this.viewModel;if(!(n&&c&&l&&s?.imageSize&&2===this.viewModel.measurementVectors?.length))return;const[d,p]=s.imageSize;this.viewModel.measurementVectors.splice(-1);const g=await this._computeMeasurementVector(e,c);if(a(t),g&&this.viewModel.measurementVectors.push(g),2===this.viewModel.measurementVectors.length){switch(r){case"distance":{this.viewModel.triangulatedDistanceMeasurement=await u(this.viewModel.measurementVectors),a(t);const r=e.map(([e,t,a])=>{const{x:r,y:i}=o({x:e,y:t,z:a},d,p);return[r,i]}),s="default"===i?await this.viewModel.calculateAccuracy(e,"distance"):await this.viewModel.calculateAccuracyPanoramic(r,"distance",!0);if(a(t),s&&this.viewModel.triangulatedDistanceMeasurement?.distance){const e=Math.atan(s/this.viewModel.triangulatedDistanceMeasurement.distance);this.viewModel.triangulatedDistanceAccuracy={distanceAccuracy:s,angleAccuracy:e}}break}case"area":if(c?.geometry.spatialReference){const e=await m(this.viewModel.measurementVectors,c.geometry.spatialReference);a(t),this.viewModel.triangulatedAreaMeasurement=e}}if(this.viewModel.updatingTriangularMeasurementState=!1,"panoramic"===this.viewModel.mode){this.viewModel.activeTriangulatedViewer.viewModel.restoreNavigationHandles()}}}_preventLeftMouseDrag(){const{mode:e,activeTriangulatedViewer:t}=this.viewModel;if("panoramic"!==e||!t)return;let a=null;t.imageRenderer.on("pointer-down",e=>{a=e.button}),t.imageRenderer.on("drag",e=>{0===a&&e.stopPropagation()})}};e([r()],p.prototype,"type",void 0),p=e([i("esri.widgets.OrientedImageryViewer.adapters.sketch.TriangulatedMeasurementAdapter")],p);const g=p;export{g as default};
