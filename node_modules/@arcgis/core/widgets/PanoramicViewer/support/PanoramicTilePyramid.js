/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../core/Accessor.js";import i from"../../../core/Error.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import o from"../../../geometry/Extent.js";import{RasterJobHandlerMixin as a}from"../../../layers/mixins/RasterJobHandlerMixin.js";import{pixelAngleThreshold as l,defaultImageSphereSize as n}from"../constants.js";import m from"./ClosestMap.js";import h from"./getVisibleTiles.js";import c from"./PanoramicTileNode.js";let p=class extends(a(t)){constructor(e){super(e),this._maximumPyramidLevel=-1,this._pixelAngleToLevelMap=new m,this._tileMap=new Map,this.raster=null,this._fetchRawTile=async(e,t,i,r)=>{await this._initJobHandler();const{pyramidBlockWidth:s,pyramidBlockHeight:a}=this.storageInfo,{minCol:l,maxCol:n,minRow:m,maxRow:h}=this.storageInfo.blockBoundary[e],c=n-l+1,p=h-m+1,g=i*this.imageSize[0]/c,d=t*this.imageSize[1]/p,f=Math.min((i+1)*this.imageSize[0]/c,this.imageSize[0]),u=Math.min((t+1)*this.imageSize[1]/p,this.imageSize[1]),x=f-g,w=u-d,y=new o({xmin:g-.5,ymin:.5-u,xmax:f-.5,ymax:.5-d,spatialReference:this.raster.rasterInfo.spatialReference}),{pixelBlock:_}=await this.raster.fetchPixels(y,s??x,a??w,r);return _},this.getLevelTiles=e=>{const t=[],{minCol:i,maxCol:r,minRow:s,maxRow:o}=this.storageInfo.blockBoundary[e];for(let a=s;a<=o;a++)for(let s=i;s<=r;s++){const i=this._tileMap.get(`${e}/${a}/${s}`);i&&t.push(i)}return t.length?t:null},this.getLevelWithPixelAngle=e=>this._pixelAngleToLevelMap.get(e)??0,this.getLowResolutionTiles=()=>{const e=this.maximumPyramidLevel;return e<0?null:this.getLevelTiles(e)},this.getTiles=(e,t,i,r,s)=>{const{minCol:o,minRow:a,maxCol:l,maxRow:n}=this.storageInfo.blockBoundary[e];return h(e,[o,a],[l,n],this._tileMap,t,i,r,s)}}initialize(){this._processLevels()}destroy(){this.raster.rasterJobHandler=null,this.raster=null,this._shutdownJobHandler(),this._tileMap.clear(),this._pixelAngleToLevelMap.clear()}async _initJobHandler(){this._rasterJobHandler||(await super._initJobHandler(),this.raster.rasterJobHandler=this._rasterJobHandler)}_processLevels(){const{blockBoundary:e,tileInfo:t}=this.storageInfo,r=e?.length;if(!r)throw new i("panoramic-viewer:missing-pyramid-resolutions","TIFF/MRF must have pyramid resolutions defined",{rasterId:this.raster.rasterId});this._tileMap.clear();for(let i=0;i<r;i++){const{maxCol:r,maxRow:s,minCol:o,minRow:a}=e[i],m=180/(s-a+1),h=360/(r-o+1),p=h/t.size[0];if(p>l)break;this._pixelAngleToLevelMap.set(p,i);for(let e=a;e<=s;e++){const t=180-(e+.5)*m;for(let s=o;s<=r;s++){const r=(s+.5)*h-180;this._tileMap.set(`${i}/${e}/${s}`,new c(i,e,s,h,m,r,t,n/2,this._fetchRawTile))}}this._maximumPyramidLevel=i}}get rasterInfo(){return this.raster.rasterInfo}get storageInfo(){return this.rasterInfo.storageInfo}get imageSize(){const{width:e,height:t}=this.rasterInfo;return[e,t]}get maximumPyramidLevel(){return this._maximumPyramidLevel}};e([r()],p.prototype,"raster",void 0),p=e([s("esri.widgets.PanoramicViewer.support.PanoramicTilePyramid")],p);const g=p;export{g as default};
