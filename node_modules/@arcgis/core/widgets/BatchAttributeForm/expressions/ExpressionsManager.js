/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../core/Accessor.js";import r from"../../../core/Error.js";import o from"../../../core/Logger.js";import{getOrCreateMapValue as s}from"../../../core/MapUtils.js";import{whenOrAbort as a}from"../../../core/promiseUtils.js";import i from"../../../core/ReactiveMap.js";import{property as n}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/RandomLCG.js";import{subclass as l}from"../../../core/accessorSupport/decorators/subclass.js";import{DateOnly as u}from"../../../core/sql/DateOnly.js";import{TimeOnly as c}from"../../../core/sql/TimeOnly.js";import{makeUseId as p}from"../inputs/support/inputUtils.js";import{isGroupElementTemplate as d,isFieldElementTemplate as f}from"../templates/support/templateUtils.js";let m=null,h=class extends t{constructor(e){super(e),this.calculating=!1,this.arcadeContext=null,this._abortController=new AbortController,this.layerExpressionsModelMap=new Map,this.evaluatedExpressions=new i,this.expressionEvaluationFailed=!1}abort(){this._abortController.abort()}async runAllExpressions(e,t=!1){return this._evaluateSpecifiedComponentsForEachFeature(e,v,t)}async runGeometryDependentExpressions(e,t=!1){return this._evaluateSpecifiedComponentsForEachFeature(e,x,t)}async valueChanged(e,t,r=!0){try{this.calculating=!0;const o=t.map(t=>this.evaluateValueChangedForFeature(e,t,r));await Promise.all(o)}catch(s){o.getLogger(this).error(s),this.expressionEvaluationFailed=!0}finally{this.calculating=!1}}async evaluateValueChangedForFeature(e,t,r){if(this._abortController.signal.aborted)return;const o=this.layerExpressionsModelMap.get(t.layer);if(!o||0===o.components.length)return;const s=new Set,a=new Set([e]),i=new Set;for(;a.size>0;){const[e]=a;if(a.delete(e),s.has(e))continue;s.add(e);const n=o.fieldReferencesMap.get(e.toLowerCase());if(!n)continue;for(const t of n)i.has(t)&&n.delete(t);if(0===n.size)continue;const l=new Set;await this.evaluateAffectedComponents([...n],t,o,r,l);for(const t of n)i.add(t);for(const t of l)s.has(t)||a.add(t)}}async evaluateAffectedComponents(e,t,r,o,s){const a=new Map;for(const n of e)a.has(n)||a.set(n,this.createSccEvaluator(n,t,a,r));if(0===a.size)return;const i=[...a.values()].map(e=>e.evaluate(o,s));await Promise.all(i)}createSccEvaluator(e,t,r,o){const a=new g(e,t,this.arcadeContext,o,this.evaluatedExpressions,this._abortController);for(const i of e.adjacencyList)a.dependentEvaluators.push(s(r,i,()=>this.createSccEvaluator(i,t,r,o)));return a}async _evaluateSpecifiedComponentsForEachFeature(e,t,r=!1){this.calculating=!0;try{const o=[];for(const s of e){const e=this.layerExpressionsModelMap.get(s.layer);if(!e||0===e.components.length)continue;const a=new Set;o.push(this.evaluateAffectedComponents(t(e),s,e,r,a))}await a(Promise.all(o),this._abortController)}catch(s){o.getLogger(this).error(s),this.expressionEvaluationFailed=!0}finally{this.calculating=!1}}};e([n()],h.prototype,"calculating",void 0),e([n({constructOnly:!0})],h.prototype,"arcadeContext",void 0),e([n()],h.prototype,"_abortController",void 0),e([n()],h.prototype,"layerExpressionsModelMap",void 0),e([n()],h.prototype,"evaluatedExpressions",void 0),e([n()],h.prototype,"expressionEvaluationFailed",void 0),h=e([l("esri.widgets.BatchAttributeForm.expressions.ExpressionsManager")],h);class g{constructor(e,t,r,o,s,a){this.scc=e,this.feature=t,this.arcadeContextInfo=r,this.expressionsModel=o,this.evaluatedExpressions=s,this._abortController=a,this.dependentEvaluators=[],this._evaluatorPromise=null}get baseContext(){const{editType:e,map:t,spatialReference:r,timeZone:o}=this.arcadeContextInfo,s=this.feature.layer,a="scene"===s?.type&&null!=s.associatedLayer?s.associatedLayer:s;return{variables:{$originalfeature:this.feature.original,$editcontext:{editType:e},$layer:a,$featureset:a,$datastore:a?.url,$feature:this.feature.plainGraphic,$map:t},executeContext:{rawOutput:!0,spatialReference:r??void 0,timeZone:o,abortSignal:this._abortController.signal}}}evaluate(e,t){return null==this._evaluatorPromise&&(this._evaluatorPromise=this._evaluate(e,t)),this._evaluatorPromise}async _evaluate(e,t){null===m&&(m=await import("../../../arcade/languageUtils.js"));const o=this.dependentEvaluators.map(r=>r.evaluate(e,t));await a(Promise.all(o),this._abortController);for(const a of this.scc.executors){const o=this.baseContext;if(this._abortController.signal.aborted)break;const l=this.expressionsModel.arcadeExecutorUses.get(a)??[],u=s(this.evaluatedExpressions,this.feature,()=>new i);let c=null,m=null;try{c=a.isAsync?await a.executeAsync(o.variables,o.executeContext):a.execute(o.variables,o.executeContext),m={result:c,status:"success"}}catch(n){m={error:n,status:"error"}}for(const r of l){const o=this.expressionsModel.elementTemplateMap.get(r.elementId);switch(r.executorPurpose){case"editable":case"required":u.set(p(r.elementId,r.executorPurpose),m);break;case"value":{if("error"===m?.status)continue;const e=o.getExpressionExecutorsForLayer(this.feature.layer);let r=!0;if(e?.editableExpression&&(r=!1===u.get(p(o.elementId,"editable"))?.result),r){const e=this.feature.getAttribute(o.fieldName)??null,r=y(m.result,this.feature,o.fieldName,this.arcadeContextInfo.timeZone);r!==e&&(this.feature.setAttribute(o.fieldName,r),t.add(o.fieldName))}}break;case"visibility":if(u.set(p(r.elementId,r.executorPurpose),m),!this.expressionsModel.preserveFieldValuesWhenHidden&&!1===m.result&&e)if(d(o)){for(const e of o.elements)if(f(e)){null!==this.feature.getAttribute(e.fieldName)&&t.add(e.fieldName),this.feature.setAttribute(e.fieldName,null)}}else if(f(o)){null!==this.feature.getAttribute(o.fieldName)&&t.add(o.fieldName),this.feature.setAttribute(o.fieldName,null)}}}if("error"===m?.status){const e=new Set;for(const t of l){const r=this.expressionsModel.elementTemplateMap.get(t.elementId);if(r)switch(t.executorPurpose){case"editable":e.add(r.label+" - Editable expression");break;case"required":e.add(r.label+" - Required expression");break;case"value":e.add(r.label+" - Value expression");break;case"visibility":e.add(r.label+" - Visibility expression")}}if(e.size>0)throw new r("expression-evaluation-failed","Arcade evaluation failed ("+[...e].join(",")+")");throw new r("expression-evaluation-failed","Arcade evaluation failed ")}}}}function y(e,t,o,s){if(null===e)return null;const a=t.layer.fieldsIndex.get(o);if(!a)throw new r("field-not-found","Unable set field value as the field cannot be found. ("+o+")");switch(a.type){case"big-integer":case"integer":case"long":case"oid":case"small-integer":case"single":case"double":return m.toNumber(e);case"global-id":case"guid":case"string":return m.toString(e);case"date":{if(m.isDate(e))return e.getTime();const t=m.toDate(e,s);if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type. ("+o+")");return t.getTime()}case"date-only":{if(m.isDateOnly(e))return e.toStorageFormat();if(m.isDate(e))return u.fromDateTime(e.toDateTime()).toStorageFormat();const t=u.fromString(m.toString(e));if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type.");return t.toStorageFormat()}case"time-only":{if(m.isTime(e))return e.toStorageString();if(m.isDate(e)){return c.fromDateTime(e.toDateTime()).toStorageString()}const t=c.fromString(m.toString(e));if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type.");return t.toStorageString()}case"timestamp-offset":{if(m.isDate(e))return e.toISOString(!1);const t=m.toDate(e,s);if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type. ("+o+")");return t.toISOString(!1)}}throw new r("unsupported-value-type","Arcade return type is not a supported field type. ("+o+")")}function v(e){return e.components}function x(e){return Array.from(e.geometryReferences)}export{h as ExpressionsManager};
