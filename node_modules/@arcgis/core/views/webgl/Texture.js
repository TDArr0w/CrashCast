/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../core/Error.js";import has from"../../core/has.js";import e from"../../core/Logger.js";import{abortMaybe as i}from"../../core/maybe.js";import{hasValue as r}from"../../core/object.js";import{throwIfAborted as s,isAbortError as o}from"../../core/promiseUtils.js";import{checkWebGLError as a}from"./checkWebGLError.js";import{ResourceType as n,CompressedTextureFormat as p}from"./enums.js";import{estimateMemory as l}from"./TextureDescriptor.js";import{isCompressedData as m,deriveInternalFormat as h,isTexImageSource as d,is3DTarget as c,validateTexture as _,isCompressedFormat as u,getDimensions as g,calcMipmapLevels as x,isSizedPixelFormat as T,isSizedDepthFormat as M,isSizedDepthStencilFormat as b}from"./textureUtils.js";import{ValidatedTextureDescriptor as f}from"./ValidatedTextureDescriptor.js";const w=null,D=!!has("esri-tests-disable-gpu-memory-measurements"),E=()=>e.getLogger("esri/views/webgl/Texture");let A=class e{static{this.TEXTURE_UNIT_FOR_UPDATES=0}static{this.compressionWorkerHandle=null}constructor(e,i=null,r=null){if(this.type=1,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._shadowFilterDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=i;else{const r=f.validate(e,i);if(!r)throw new t("texture:invalid-descriptor","Texture descriptor invalid");this._descriptor=r}34067===this._descriptor.target?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return D?0:l(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty||this._shadowFilterDirty}get hasWebGLTextureObject(){return!!this._glName}dispose(){this.abortCompression(),this.hasWebGLTextureObject&&this._descriptor.context?.gl&&(this._descriptor.context.instanceCounter.decrement(n.Texture,this),this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null,this._descriptor=null)}release(){this.dispose()}[Symbol.dispose](){this.dispose()}resize(e,i){const r=this._descriptor;if(r.width!==e||r.height!==i){if(this._wasImmutablyAllocated)throw new t("texture:immutable-resize","Immutable textures can't be resized!");r.width=e,r.height=i,34067===this._descriptor.target?this._setDataCubeMap(null):this.setData(null)}}enableCompression(t){this._descriptor.compress=t}disableCompression(){this._descriptor.compress=void 0}setData(t){this.abortCompression(),!m(t)&&this._descriptor.internalFormat&&r(p,this._descriptor.internalFormat)&&(this._descriptor.internalFormat=void 0),this._setData(t),!m(t)&&this._descriptor.compress&&this._compressOnWorker(t)}updateData(i,r,s,o,a,n,p=0){n||E().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||E().error("An attempt to update uninitialized texture!");const l=this._descriptor;l.internalFormat=h(l);const{context:c,pixelFormat:_,dataType:u,target:g,isImmutable:x}=l;if(x&&!this._wasImmutablyAllocated)throw new t("texture:uninitialized","Cannot update immutable texture before allocation!");const T=c.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||r+o>l.width||s+a>l.height)&&E().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:M}=c;p&&(o&&a||E().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),M.pixelStorei(M.UNPACK_SKIP_ROWS,p)),d(n)?M.texSubImage2D(g,i,r,s,o,a,_,u,n):m(n)?M.compressedTexSubImage2D(g,i,r,s,o,a,l.internalFormat,n.levels[i]):M.texSubImage2D(g,i,r,s,o,a,_,u,n),p&&M.pixelStorei(M.UNPACK_SKIP_ROWS,0),c.bindTexture(T,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(i,r,s,o,a,n,p,l){l||E().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||E().error("An attempt to update an uninitialized texture!");const d=this._descriptor;d.internalFormat=h(d);const{context:_,pixelFormat:u,dataType:g,isImmutable:x,target:T}=d;if(x&&!this._wasImmutablyAllocated)throw new t("texture:uninitialized","Cannot update immutable texture before allocation!");c(T)||E().warn("Attempting to set 3D texture data on a non-3D texture");const M=_.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);_.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||o<0||r+a>d.width||s+n>d.height||o+p>d.depth)&&E().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:b}=_;if(m(l))l=l.levels[i],b.compressedTexSubImage3D(T,i,r,s,o,a,n,p,d.internalFormat,l);else{const t=l;b.texSubImage3D(T,i,r,s,o,a,n,p,u,g,t)}_.bindTexture(M,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const i=this._descriptor;if(0===i.width||0===i.height)return;if(!i.hasMipmap){if(this._wasImmutablyAllocated)throw new t("texture:immutable-change","Cannot add mipmaps to immutable texture after allocation");i.hasMipmap=!0,this._samplingModeDirty=!0,_(i)}9729===i.samplingMode?(this._samplingModeDirty=!0,i.samplingMode=9985):9728===i.samplingMode&&(this._samplingModeDirty=!0,i.samplingMode=9984);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(i.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new t("texture:immutable-change","Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,_(e)}9985===e.samplingMode?(this._samplingModeDirty=!0,e.samplingMode=9729):9984===e.samplingMode&&(this._samplingModeDirty=!0,e.samplingMode=9728)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,_(this._descriptor),this._wrapModeDirty=!0)}setShadowFiltering(t){t!==this._descriptor.linearFilterDepth&&(this._descriptor.linearFilterDepth=this._descriptor.compareEnabled=t,this.setSamplingMode(t?9729:9728),_(this._descriptor),this._shadowFilterDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1),this._shadowFilterDirty&&(this._applyShadowMode(),this._shadowFilterDirty=!1)}abortCompression(){this._compressionAbortController=i(this._compressionAbortController)}_setData(i,r){const s=this._descriptor,o=s.context?.gl;if(!o)return;a(o),this.hasWebGLTextureObject||(this._glName=o.createTexture(),s.context.instanceCounter.increment(n.Texture,this)),_(s);const p=s.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);s.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),a(o);const l=r??s.target,g=c(l);if(d(i))this._setDataFromTexImageSource(i,l);else{const{width:e,height:r,depth:n}=s;if(null==e||null==r)throw new t("texture:missing-size","Width and height must be specified!");if(g&&null==n)throw new t("texture:missing-depth","Depth must be specified!");if(s.internalFormat=h(s),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(l,s.internalFormat,s.hasMipmap,e,r,n),m(i)){if(!u(s.internalFormat))throw new t("texture:format-mismatch","Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(i,s.internalFormat,l)}else this._texImage(l,0,s.internalFormat,e,r,n,i),a(o),s.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),this._applyShadowMode(),a(o),s.context.bindTexture(p,e.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(t=null){for(let e=34069;e<=34074;e++)this._setData(t,e)}_configurePixelStorage(){const t=this._descriptor.context.gl,{unpackAlignment:e,flipped:i,preMultiplyAlpha:r}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)}_setDataFromTexImageSource(t,e){const{gl:i}=this._descriptor.context,r=this._descriptor;r.internalFormat=h(r);const s=c(e),{width:o,height:n,depth:p}=g(t);r.width&&r.height,r.width||(r.width=o),r.height||(r.height=n),s&&r.depth,s&&(r.depth=p),r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,r.internalFormat,r.hasMipmap,o,n,p),this._texImage(e,0,r.internalFormat,o,n,p,t),a(i),r.hasMipmap&&(this.generateMipmap(),a(i))}_setDataFromCompressedSource(t,e,i){const r=this._descriptor,{width:s,height:o,depth:a}=r,n=t.levels,p=x(i,s,o,a),l=Math.min(p,n.length)-1;this._descriptor.context.gl.texParameteri(r.target,33085,l),this._forEachMipmapLevel((t,r,s,o)=>{const a=n[Math.min(t,n.length-1)];this._compressedTexImage(i,t,e,r,s,o,a)},l)}_texStorage(e,i,r,s,o,a){const{gl:n}=this._descriptor.context;if(!T(i)&&!M(i)&&!b(i))throw new t("texture:missing-format","Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const p=r?x(e,s,o,a):1;if(c(e)){if(null==a)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");n.texStorage3D(e,p,i,s,o,a)}else n.texStorage2D(e,p,i,s,o);this._wasImmutablyAllocated=!0}_texImage(e,i,r,s,o,a,n){const p=this._descriptor.context.gl,l=c(e),{isImmutable:m,pixelFormat:h,dataType:d}=this._descriptor;if(m){if(null!=n){const r=n;if(l){if(null==a)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.texSubImage3D(e,i,0,0,0,s,o,a,h,d,r)}else p.texSubImage2D(e,i,0,0,s,o,h,d,r)}}else{const m=n;if(l){if(null==a)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.texImage3D(e,i,r,s,o,a,0,h,d,m)}else p.texImage2D(e,i,r,s,o,0,h,d,m)}}_compressedTexImage(e,i,r,s,o,a,n){const p=this._descriptor.context.gl,l=c(e);if(this._descriptor.isImmutable){if(null!=n)if(l){if(null==a)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.compressedTexSubImage3D(e,i,0,0,0,s,o,a,r,n)}else p.compressedTexSubImage2D(e,i,0,0,s,o,r,n)}else if(l){if(null==a)throw new t("texture:missing-depth","Missing depth dimension for 3D texture upload");p.compressedTexImage3D(e,i,r,s,o,a,0,n)}else p.compressedTexImage2D(e,i,r,s,o,0,n)}async _compressOnWorker(t){const{width:i,height:r,context:a,flipped:n,preMultiplyAlpha:p,hasMipmap:l}=this._descriptor,m=this._descriptor.compress?.compressionTracker,h=this._descriptor.compress?.compressionCallback,{compressedTextureETC:d,compressedTextureS3TC:c}=a.capabilities;if(!e.compressionWorkerHandle?.isCompressible(t,this._descriptor)||!d&&!c)return;this.abortCompression();const _=new AbortController;let u;this._compressionAbortController=_,m?.increment();try{t instanceof Uint8Array?u=t.buffer:(u=await createImageBitmap(t,{imageOrientation:n?"flipY":"none"}),s(_));const o={data:u,width:i,height:r,needsFlip:t instanceof Uint8Array&&this.descriptor.flipped,components:6408===this._descriptor.pixelFormat?4:3,preMultiplyAlpha:p,hasMipmap:l,hasETC:!!d,hasS3TC:!!c},a=await e.compressionWorkerHandle.invoke(o,_.signal,"low");if(s(_),a.compressedTexture&&this.hasWebGLTextureObject){const t=this.usedMemory;this._descriptor.internalFormat=a.internalFormat,this._setData(a.compressedTexture),h?.(t-this.usedMemory)}}catch(g){o(g)||E().error("Texture compression failed!")}finally{m?.decrement(),this._compressionAbortController?.signal.aborted&&(this._compressionAbortController=null),u instanceof ImageBitmap&&u.close()}}_forEachMipmapLevel(e,i=1/0){let{width:r,height:s,depth:o,hasMipmap:a,target:n}=this._descriptor;const p=32879===n;if(null==r||null==s||p&&null==o)throw new t("texture:missing-size","Missing texture dimensions for mipmap calculation");for(let t=0;e(t,r,s,o),a&&(1!==r||1!==s||p&&1!==o)&&!(t>=i);++t)r=Math.max(1,r>>1),s=Math.max(1,s>>1),p&&(o=Math.max(1,o>>1))}_applySamplingMode(){const t=this._descriptor,e=t.context?.gl;let i=t.samplingMode,r=t.samplingMode;9985===i||9987===i?(i=9729,t.hasMipmap||(r=9729)):9984!==i&&9986!==i||(i=9728,t.hasMipmap||(r=9728)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,i),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,r)}_applyWrapMode(){const t=this._descriptor,e=t.context?.gl;"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}_applyShadowMode(){const t=this._descriptor,e=t.context?.gl,i=t.compareEnabled?e.COMPARE_REF_TO_TEXTURE:e.NONE;e.texParameteri(t.target,e.TEXTURE_COMPARE_MODE,i),t.compareEnabled&&e.texParameteri(t.target,e.TEXTURE_COMPARE_FUNC,e.GREATER),a(e)}_applyAnisotropicFilteringParameters(){const t=this._descriptor,e=t.context.capabilities.textureFilterAnisotropic;if(!e)return;t.context.gl.texParameterf(t.target,e.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}};export{A as Texture,w as tracer};
