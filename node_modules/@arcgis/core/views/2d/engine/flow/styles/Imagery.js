/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{throwIfAborted as t}from"../../../../../core/promiseUtils.js";import{timeExtentsEqual as r,setUniforms as a}from"../utils.js";import{PrimitiveType as e,DataType as s}from"../../../../webgl/enums.js";import{Texture as o}from"../../../../webgl/Texture.js";import{TextureDescriptor as i}from"../../../../webgl/TextureDescriptor.js";import{VertexArrayObject as n}from"../../../../webgl/VertexArrayObject.js";import{fromLayout as m}from"../../../../webgl/VertexAttributeLocations.js";import{VertexBuffer as l}from"../../../../webgl/VertexBuffer.js";import{VertexElementDescriptor as p}from"../../../../webgl/VertexElementDescriptor.js";class c{constructor(t){this._params=t,this.animated=!1}isCompatible(t){if(!(t instanceof c))return!1;if(!r(this._params.timeExtent,t._params.timeExtent))return!1;let a=!0;return a=a&&this._params.loadImagery===t._params.loadImagery,a=a&&this._params.color.kind===t._params.color.kind,a=a&&this._params.opacity.kind===t._params.opacity.kind,a}async load(r,a){const{extent:e,size:s}=r;t(a);const o=await this._params.loadImagery(e,s[0],s[1],this._params.timeExtent,a);return new _(o,{color:this._params.color,opacity:this._params.opacity})}render(t,r,s){const{context:o}=t,{program:i}=s;o.setFaceCullingEnabled(!1),o.setBlendingEnabled(!0),o.setBlendFunction(1,771),o.useProgram(i),i.setUniformMatrix3fv("u_dvsMat3",r.dvsMat3),o.bindTexture(s.texture,0),i.setUniform1i("u_texture",0),i.setUniform1f("u_Min",s.min),i.setUniform1f("u_Max",s.max),a(i,"color","vec4",this._params.color),a(i,"opacity","float",this._params.opacity),o.bindVAO(s.vertexArray),o.drawArrays(e.TRIANGLE_STRIP,0,4)}}const h=[new p("a_position",2,s.UNSIGNED_SHORT,0,8),new p("a_texcoord",2,s.UNSIGNED_SHORT,4,8)],f={vsPath:"raster/flow/imagery",fsPath:"raster/flow/imagery",locations:m(h)};class _{constructor(t,r){this._flowData=t,this._values=r}attach(t){const{context:r}=t,{width:a,height:e}=this._flowData,s=new l(r,h,new Uint16Array([0,0,0,1,a,0,1,1,0,e,0,0,a,e,1,0])),m=new n(r,s),p=[];"ramp"===this._values.color.kind&&p.push("vvColor"),"ramp"===this._values.opacity.kind&&p.push("vvOpacity");const c=t.getProgram(f,p);let _=1e6,d=-1e6;for(let o=0;o<e;o++)for(let t=0;t<a;t++)if(0!==this._flowData.mask[o*a+t]){const r=this._flowData.data[2*(o*a+t)],e=this._flowData.data[2*(o*a+t)+1],s=Math.sqrt(r*r+e*e);_=Math.min(_,s),d=Math.max(d,s)}const u=new Uint8Array(4*a*e);for(let o=0;o<e;o++)for(let t=0;t<a;t++)if(0!==this._flowData.mask[o*a+t]){const r=this._flowData.data[2*(o*a+t)],e=this._flowData.data[2*(o*a+t)+1],s=(Math.sqrt(r*r+e*e)-_)/(d-_);u[4*(o*a+t)]=255*s,u[4*(o*a+t)+1]=0,u[4*(o*a+t)+2]=0,u[4*(o*a+t)+3]=255}else u[4*(o*a+t)]=0,u[4*(o*a+t)+1]=0,u[4*(o*a+t)+2]=0,u[4*(o*a+t)+3]=0;const w=new i(a,e);w.internalFormat=6408,w.wrapMode=33071,w.flipped=!0;const x=new o(r,w,u);this.vertexArray=m,this.program=c,this.texture=x,this.min=_,this.max=d,this._flowData=null}detach(){this.vertexArray.dispose(),this.texture.dispose()}get ready(){return this.program.compiled}}export{c as Imagery,_ as ImageryResources};
