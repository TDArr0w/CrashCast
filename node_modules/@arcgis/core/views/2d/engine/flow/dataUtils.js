/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import t from"../../../../core/Logger.js";import{moduloPositive as e,deg2rad as n}from"../../../../core/mathUtils.js";import{throwIfAborted as r}from"../../../../core/promiseUtils.js";import o from"../../../../core/RandomLCG.js";import i from"../../../../geometry/Extent.js";import{getInfo as l}from"../../../../geometry/support/spatialReferenceUtils.js";const s=()=>t.getLogger("esri.views.2d.engine.flow.dataUtils"),a=10;async function c(t,e,n,o){const i=performance.now(),l=f(e,n),c=performance.now(),h=d(e,l,n.width,n.height),u=performance.now(),m=w(h,!0),y=performance.now(),x="Streamlines"===t?p(m,a):g(m),M=performance.now();return has("esri-2d-profiler")&&(s().info("I.1","_createFlowFieldFromData (ms)",Math.round(c-i)),s().info("I.2","_getStreamlines (ms)",Math.round(u-c)),s().info("I.3","createAnimatedLinesData (ms)",Math.round(y-u)),s().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(M-y)),s().info("I.5","createFlowMesh (ms)",Math.round(M-i)),s().info("I.6","Mesh size (bytes)",x.vertexData.buffer.byteLength+x.indexData.buffer.byteLength)),await Promise.resolve(),r(o),x}function f(t,e){const n=m(e.data,e.width,e.height,t.smoothing);if(t.interpolate){return(t,r)=>{const o=Math.floor(t),i=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(i<0||i>=e.height)return[0,0];const l=t-o,s=r-i,a=o,c=i,f=o<e.width-1?o+1:o,h=i<e.height-1?i+1:i,u=n[2*(c*e.width+a)],d=n[2*(c*e.width+f)],m=n[2*(h*e.width+a)],w=n[2*(h*e.width+f)],p=n[2*(c*e.width+a)+1],g=n[2*(c*e.width+f)+1];return[(u*(1-s)+m*s)*(1-l)+(d*(1-s)+w*s)*l,(p*(1-s)+n[2*(h*e.width+a)+1]*s)*(1-l)+(g*(1-s)+n[2*(h*e.width+f)+1]*s)*l]}}return(t,r)=>{const o=Math.round(t),i=Math.round(r);return o<0||o>=e.width||i<0||i>=e.height?[0,0]:[n[2*(i*e.width+o)],n[2*(i*e.width+o)+1]]}}function h(t,n,r,o,i,l,s,a){const c=[],{raster:f,width:h,height:u,resolutionFactor:d}=a;let m=o,w=i,p=0,[g,y]=r(m,w);g*=n.velocityScale,y*=n.velocityScale;const x=Math.sqrt(g*g+y*y);let M,A;c.push({x:m,y:w,t:p,speed:x});for(let v=0;v<n.verticesPerLine;v++){let[o,i]=r(m,w);o*=n.velocityScale,i*=n.velocityScale;const a=Math.sqrt(o*o+i*i);if(a<n.minSpeedThreshold)return c;const g=t*o/a,y=t*i/a;m+=g*n.segmentLength,w+=y*n.segmentLength,n.wrapAround&&(m=e(m,l[0]));if(p+=t*n.segmentLength/a,Math.acos(g*M+y*A)>n.maxTurnAngle)return c;if(n.collisions){let t=Math.round(m*d);const r=Math.round(w*d);if(n.wrapAround&&(t=e(t,h)),t<0||t>h-1||r<0||r>u-1)return c;const o=f[r*h+t];if(-1!==o&&o!==s)return c;f[r*h+t]=s}c.push({x:m,y:w,t:p,speed:a}),M=g,A=y}return c}function u(t,e,n,r,o,i,l,s){const a=Math.round((.2+.6*l.getFloat())*t.verticesPerLine),c=t.verticesPerLine-a,f=h(-1,{...t,verticesPerLine:c},e,n,r,o,i,s),u=h(1,{...t,verticesPerLine:a},e,n,r,o,i,s),d=f.reverse();d.splice(-1,1);return d.concat(u)}function d(t,e,n,r,i={positions:[]}){if(t.density<=0)return[];const{positions:l}=i,s=[],a=new o,c=1/Math.max(t.lineCollisionWidth,1),f=Math.round(n*c),d=Math.round(r*c),m=new Int32Array(f*d);for(let o=0;o<m.length;o++)m[o]=-1;const w={raster:m,width:f,height:d,resolutionFactor:c},p={},g=t.lineSpacing/Math.sqrt(t.density),y=Math.floor(r/g),x=Math.floor(n/g);for(let o=0;o<y;o++){const t=o*g;for(let e=0;e<x;e++){const n=e*g;p[`${e}-${o}`]={x:n,y:t,positions:[]}}}for(const{x:o,y:h}of l){const t=p[`${Math.floor(o/g)}-${Math.floor(h/g)}`];t&&t.positions.push([o,h])}const M=[];for(const o in p){const t=p[o];if(0===t.positions.length)M.push({x:t.x+g/2,y:t.y+g/2,sort:.66+.33*a.getFloat(),stage:0});else{const[e]=t.positions.splice(0,1);M.push({x:e[0],y:e[1],sort:.33*a.getFloat(),stage:1});for(const[n,r]of t.positions)M.push({x:n,y:r,sort:.33+.33*a.getFloat(),stage:2})}}M.sort((t,e)=>t.sort-e.sort);for(const{x:o,y:A,stage:v}of M){const i=t.onlyForwardTracing?h(1,t,e,o,A,[n,r],s.length,w):u(t,e,o,A,[n,r],s.length,a,w);i.length<2||s.push({stage:v,vertices:i})}return s}function m(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),i=new Array(2*o+1);let l=0;for(let c=-o;c<=o;c++){const t=Math.exp(-c*c/(r*r));i[c+o]=t,l+=t}for(let c=-o;c<=o;c++)i[c+o]/=l;const s=new Float32Array(t.length);for(let c=0;c<n;c++)for(let n=0;n<e;n++){let r=0,l=0;for(let s=-o;s<=o;s++){if(n+s<0||n+s>=e)continue;const a=i[s+o];r+=a*t[2*(c*e+(n+s))],l+=a*t[2*(c*e+(n+s))+1]}s[2*(c*e+n)]=r,s[2*(c*e+n)+1]=l}const a=new Float32Array(t.length);for(let c=0;c<e;c++)for(let t=0;t<n;t++){let r=0,l=0;for(let a=-o;a<=o;a++){if(t+a<0||t+a>=n)continue;const f=i[a+o];r+=f*s[2*((t+a)*e+c)],l+=f*s[2*((t+a)*e+c)+1]}a[2*(t*e+c)]=r,a[2*(t*e+c)+1]=l}return a}function w(t,e){const n=new o,r=t.reduce((t,e)=>t+e.vertices.length,0),i=new Float32Array(4*r),l=new Array(t.length);let s=0,a=0;for(const{vertices:o}of t){const t=s;for(const e of o)i[4*s]=e.x,i[4*s+1]=e.y,i[4*s+2]=e.t,i[4*s+3]=e.speed,s++;l[a++]={startVertex:t,numberOfVertices:o.length,totalTime:o[o.length-1].t,timeSeed:e?n.getFloat():0}}return{lineVertices:i,lineDescriptors:l}}function p(t,e){const n=9,{lineVertices:r,lineDescriptors:o}=t;let i=0,l=0;for(const d of o){i+=2*d.numberOfVertices;l+=6*(d.numberOfVertices-1)}const s=new Float32Array(i*n),a=new Uint32Array(l);let c=0,f=0;function h(){a[f++]=c-2,a[f++]=c,a[f++]=c-1,a[f++]=c,a[f++]=c+1,a[f++]=c-1}function u(t,e,r,o,i,l,a,f){const h=c*n;let u=0;s[h+u++]=t,s[h+u++]=e,s[h+u++]=1,s[h+u++]=r,s[h+u++]=l,s[h+u++]=a,s[h+u++]=o/2,s[h+u++]=i/2,s[h+u++]=f,c++,s[h+u++]=t,s[h+u++]=e,s[h+u++]=-1,s[h+u++]=r,s[h+u++]=l,s[h+u++]=a,s[h+u++]=-o/2,s[h+u++]=-i/2,s[h+u++]=f,c++}for(const d of o){const{totalTime:t,timeSeed:n}=d;let o=null,i=null,l=null,s=null,a=null,c=null;for(let f=0;f<d.numberOfVertices;f++){const m=r[4*(d.startVertex+f)],w=r[4*(d.startVertex+f)+1],p=r[4*(d.startVertex+f)+2],g=r[4*(d.startVertex+f)+3];let y=null,x=null,M=null,A=null;if(f>0){y=m-o,x=w-i;const r=Math.sqrt(y*y+x*x);if(y/=r,x/=r,f>1){let t=y+a,n=x+c;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*y+n*x),e);t*=o,n*=o,M=-n,A=t}else M=-x,A=y;null!==M&&null!==A&&(u(o,i,l,M,A,t,n,g),h())}o=m,i=w,l=p,a=y,c=x,s=g}u(o,i,l,-c,a,t,n,s)}return{vertexData:s,indexData:a}}function g(t){const e=16,n=1,r=2,{lineVertices:o,lineDescriptors:i}=t;let l=0,s=0;for(const S of i){const t=S.numberOfVertices-1;l+=4*t*2,s+=6*t*2}const a=new Float32Array(l*e),c=new Uint32Array(s);let f,h,u,d,m,w,p,g,y,x,M,A,v,F,I=0,V=0;function L(){c[V++]=I-8,c[V++]=I-7,c[V++]=I-6,c[V++]=I-7,c[V++]=I-5,c[V++]=I-6,c[V++]=I-4,c[V++]=I-3,c[V++]=I-2,c[V++]=I-3,c[V++]=I-1,c[V++]=I-2}function b(t,o,i,l,s,c,f,h,u,d,m,w,p,g){const y=I*e;let x=0;for(const e of[n,r])for(const n of[1,2,3,4])a[y+x++]=t,a[y+x++]=o,a[y+x++]=i,a[y+x++]=l,a[y+x++]=f,a[y+x++]=h,a[y+x++]=u,a[y+x++]=d,a[y+x++]=e,a[y+x++]=n,a[y+x++]=p,a[y+x++]=g,a[y+x++]=s/2,a[y+x++]=c/2,a[y+x++]=m/2,a[y+x++]=w/2,I++}function k(t,e){let n=y+M,r=x+A;const o=Math.sqrt(n*n+r*r);n/=o,r/=o;const i=y*n+x*r;n/=i,r/=i;let l=M+v,s=A+F;const a=Math.sqrt(l*l+s*s);l/=a,s/=a;const c=M*l+A*s;l/=c,s/=c,b(f,h,u,d,-r,n,m,w,p,g,-s,l,t,e),L()}function D(t,e,n,r,o,i){if(y=M,x=A,M=v,A=F,null==y&&null==x&&(y=M,x=A),null!=m&&null!=w){v=t-m,F=e-w;const n=Math.sqrt(v*v+F*F);v/=n,F/=n}null!=y&&null!=x&&k(o,i),f=m,h=w,u=p,d=g,m=t,w=e,p=n,g=r}function P(t,e){y=M,x=A,M=v,A=F,null==y&&null==x&&(y=M,x=A),null!=y&&null!=x&&k(t,e)}for(const S of i){f=null,h=null,u=null,d=null,m=null,w=null,p=null,g=null,y=null,x=null,M=null,A=null,v=null,F=null;const{totalTime:t,timeSeed:e}=S;for(let n=0;n<S.numberOfVertices;n++){D(o[4*(S.startVertex+n)],o[4*(S.startVertex+n)+1],o[4*(S.startVertex+n)+2],o[4*(S.startVertex+n)+3],t,e)}P(t,e)}return{vertexData:a,indexData:c}}function y(t,e,r=e.width,o=e.height,i=0,l=0){const s=e.pixels,a=r*o,c=2,f=new Float32Array(a*c),h=e.width,u=(t,e)=>t+i+(e+l)*h,d=(t,e)=>t+e*r;let m;if(null!=e.mask)if(r!==e.width||o!==e.height||0!==i||0!==l){m=new Uint8Array(a*c);const t=e.mask;for(let e=0;e<o;++e)for(let n=0;n<r;++n){const r=u(n,e),o=d(n,e);m[c*o]=t[c*r],m[c*o+1]=t[c*r+1]}}else m=e.mask;else m=new Uint8Array(a*c),m.fill(255);if("vector-uv"===t)for(let n=0;n<o;++n)for(let t=0;t<r;++t){const e=u(t,n),r=d(t,n);f[c*r]=s[0][e],f[c*r+1]=-s[1][e]}else if("vector-magdir"===t){const{cos:t,sin:e}=Math;for(let i=0;i<o;++i)for(let o=0;o<r;++o){const r=u(o,i),l=d(o,i),a=s[0][r],h=n(s[1][r]),m=t(h-Math.PI/2),w=e(h-Math.PI/2);f[c*l]=m*a,f[c*l+1]=w*a}}return{data:f,mask:m,width:r,height:o}}async function x(t,e,n,r,o,a){const c=performance.now(),f=l(e.spatialReference);if(!f){const i=await M(t,e,n,r,o,a);return has("esri-2d-profiler")&&s().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-c)),has("esri-2d-profiler")&&s().info("I.9","Number of parts",1),i}const[h,u]=f.valid,d=u-h,m=Math.ceil(e.width/d),w=e.width/m,p=Math.round(n/m);let g=e.xmin;const y=[],x=performance.now();for(let l=0;l<m;l++){const n=new i({xmin:g,xmax:g+w,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});y.push(M(t,n,p,r,o,a)),g+=w}const A=await Promise.all(y);if(has("esri-2d-profiler")&&s().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-x)),has("esri-2d-profiler")&&s().info("I.9","Number of parts",A.length),1===A.length)return has("esri-2d-profiler")&&s().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-c)),A[0];const v={data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r};let F=0;for(const i of A){for(let t=0;t<i.height;t++)for(let e=0;e<i.width;e++)F+e>=n||(v.data[2*(t*n+F+e)]=i.data[2*(t*i.width+e)],v.data[2*(t*n+F+e)+1]=i.data[2*(t*i.width+e)+1],v.mask[t*n+F+e]=i.mask[t*i.width+e]);F+=i.width}return has("esri-2d-profiler")&&s().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-c)),v}async function M(t,e,n,r,o,i){const l={requestProjectedLocalDirections:!0,signal:i};if(null!=o&&(l.timeExtent=o),"imagery"===t.type){await t.load({signal:i});const o=await t.internalFetchImage(e,n,r,l);if(null==o?.pixelData?.pixelBlock)return{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r};return y(t.rasterInfo.dataType,o.pixelData.pixelBlock)}await t.load({signal:i});const s=await t.fetchPixels(e,n,r,l);if(null==s?.pixelBlock)return{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r};return y(t.serviceRasterInfo.dataType,s.pixelBlock)}export{w as createAnimatedLinesData,f as createFlowFieldFromData,c as createFlowMesh,g as createParticlesMesh,p as createStreamlinesMesh,x as loadImagery,y as toFlowData,d as traceFlowPaths};
