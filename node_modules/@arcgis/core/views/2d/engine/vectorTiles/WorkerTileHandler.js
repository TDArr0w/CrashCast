/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isAbortError as e}from"../../../../core/promiseUtils.js";import t from"./WorkerTile.js";import s from"./style/StyleRepository.js";const r=25;class o{constructor(){this._spriteInfo={},this._glyphInfo={},this._sourceDataMaxLOD=r}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){return this._styleRepository?.layers??[]}async createTileAndParse(s,r){const{key:o}=s,i={};for(const e of Object.keys(s.sourceName2DataAndRefKey)){const t=s.sourceName2DataAndRefKey[e];i[e]=t.refKey}const a=new t(o,i,this,this._styleRepository);try{return await a.parse({...s,sourceDataMaxLOD:this._sourceDataMaxLOD},r)}catch(n){if(a.setObsolete(),a.release(),!e(n))throw n;return null}}updateStyle(e){if(!e||0===e.length||!this._styleRepository)return;const t=this._styleRepository;for(const s of e){const e=s.type,r=s.data;switch(e){case 0:t.setPaintProperties(r.layer,r.paint);break;case 1:t.setLayoutProperties(r.layer,r.layout);break;case 3:t.deleteStyleLayer(r.layer);break;case 2:t.setStyleLayer(r.layer,r.index);break;case 4:this._spriteInfo={}}}}setStyle(e){const{style:t,sourceDataMaxLOD:r}=e;this._styleRepository=new s(t),this._sourceDataMaxLOD=r,this._spriteInfo={},this._glyphInfo={}}fetchSprites(e,t,s){const r=[],o=this._spriteInfo;for(const i of e){void 0===o[i.name]&&r.push(i)}return 0===r.length?Promise.resolve():t.invoke("getSprites",r,{signal:s?.signal}).then(e=>{for(const t in e){const s=e[t];o[t]=s}})}getSpriteItems(){return this._spriteInfo}fetchGlyphs(e,t,s,r,o){const i=[];let a=this._glyphInfo[t];return a?s.forEach(e=>{a[e]||i.push(e)}):(a=this._glyphInfo[t]=[],s.forEach(e=>i.push(e))),0===i.length?Promise.resolve():r.invoke("getGlyphs",{tileID:e,font:t,codePoints:i},o).then(e=>{for(let t=0;t<e.length;t++)e[t]&&(a[t]=e[t])})}getGlyphItems(e){return this._glyphInfo[e]}}export{o as default};
