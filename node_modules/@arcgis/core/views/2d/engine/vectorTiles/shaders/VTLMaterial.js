/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../MemoryBuffer.js";import{DataType as e}from"../../../../webgl/enums.js";import{fromLayouts as o,fromLayout as n}from"../../../../webgl/VertexAttributeLocations.js";import{VertexElementDescriptor as r}from"../../../../webgl/VertexElementDescriptor.js";class s{constructor(t){this._key=t}get key(){return this._key}get type(){return 7&this._key}defines(){return[]}getStride(){return this._geometryLayout||this._buildAttributesInfo(),this._stride}getAttributeLocations(){return this._geometryLayout||this._buildAttributesInfo(),this._locations}get geometryLayout(){return this._geometryLayout||this._buildAttributesInfo(),this._geometryLayout}getEncodingInfos(){return this._propertyEncodingInfo||this._buildAttributesInfo(),this._propertyEncodingInfo}getUniforms(){return this._uniforms||this._buildAttributesInfo(),this._uniforms}getShaderHeader(){return this._shaderHeader||this._buildAttributesInfo(),this._shaderHeader}getShaderMain(){return this._shaderMain||this._buildAttributesInfo(),this._shaderMain}setDataUniforms(t,e,o,n,r){const s=this.getUniforms();for(const a of s){const{name:s,type:i,getValue:c}=a,u=c(o,e,n,r);if(null!==u)switch(i){case"float":t.setUniform1f(s,u);break;case"vec2":t.setUniform2fv(s,u);break;case"vec4":t.setUniform4fv(s,u)}}}encodeAttributes(t,e,o,n){const r=this.attributesInfo,s=this.getEncodingInfos(),a=[];let i=0,c=0;for(const u of Object.keys(s)){const h=s[u],{type:d,precisionFactor:f,isLayout:l}=r[u],y=l?o.getLayoutProperty(u):o.getPaintProperty(u),_=y.interpolator?.getInterpolationRange(e);let m=0;for(const o of h){const{offset:r,bufferElementsToAdd:s}=o;if(s>0){for(let t=0;t<s;t++)a.push(0);i+=c,c=o.bufferElementsToAdd}const u=n??y.getValue(_?_[m]:e,t);switch(d){case 0:case 1:a[i]|=this._encodeByte(u*(f||1),8*r);break;case 2:case 3:a[i]|=this._encodeShort(u*(f||1),8*r);break;case 4:case 5:a[i]|=this._encodeByte(u*(f||1),8*r),a[i]|=this._encodeByte(u*(f||1),8*r+8);break;case 6:case 7:a[i]|=this._encodeShort(u*(f||1),8*r),a[i]|=this._encodeShort(u*(f||1),8*r+16);break;case 8:case 9:a[i]|=this._encodeByte(u*(f||1),8*r),a[i]|=this._encodeByte(u*(f||1),8*r+8),a[i]|=this._encodeByte(u*(f||1),8*r+16),a[i]|=this._encodeByte(u*(f||1),8*r+24);break;case 10:a[i]=this._encodeColor(u);break;case 11:case 12:this._encodePattern(i,a,u);break;default:throw new Error("Unsupported encoding type")}m++}}return a}getAtributeState(t){let e=0;const o=3+2*t;return e|=this._bit(o),e|=this._bit(o+1)<<1,e}static{this._encodingInfo={0:{dataType:e.BYTE,bytesPerElement:1,count:1,normalized:!1},1:{dataType:e.UNSIGNED_BYTE,bytesPerElement:1,count:1,normalized:!1},2:{dataType:e.SHORT,bytesPerElement:2,count:1,normalized:!1},3:{dataType:e.UNSIGNED_SHORT,bytesPerElement:2,count:1,normalized:!1},4:{dataType:e.BYTE,bytesPerElement:1,count:2,normalized:!1},5:{dataType:e.UNSIGNED_BYTE,bytesPerElement:1,count:2,normalized:!1},6:{dataType:e.SHORT,bytesPerElement:2,count:2,normalized:!1},7:{dataType:e.UNSIGNED_SHORT,bytesPerElement:2,count:2,normalized:!1},8:{dataType:e.BYTE,bytesPerElement:1,count:4,normalized:!1},9:{dataType:e.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!1},10:{dataType:e.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!0},11:{dataType:e.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1},12:{dataType:e.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1}}}_buildAttributesInfo(){const t=[],o={},{attributesInfo:n,attributes:r}=this,a={};let i=-1,c=-1;for(const e of r){c++;const r=this.getAtributeState(c);if(0===r||3===r)continue;const u=n[e],h=[];o[e]=h;const d=u.type;for(let e=0;e<r;e++){const{dataType:e,bytesPerElement:o,count:n,normalized:r}=s._encodingInfo[d],c=o*n,u=`${e}-${!0===r}`;let f=a[u],l=0;if(!f||f.count+n>4)i++,f={dataIndex:i,count:0,offset:0},4!==n&&(a[u]=f),t.push({location:-1,name:"a_data_"+i,count:n,type:e,normalized:r}),l=Math.ceil(Math.max(c/4,1));else{const e=t[f.dataIndex];e.count+=n;l=Math.ceil(Math.max(e.count*o/4,1))-Math.ceil(Math.max(f.offset/4,1))}h.push({dataIndex:f.dataIndex,offset:f.offset,bufferElementsToAdd:l}),f.offset+=c,f.count+=n}}for(const s of t)switch(s.type){case e.BYTE:case e.UNSIGNED_BYTE:s.count=4;break;case e.SHORT:case e.UNSIGNED_SHORT:s.count+=s.count%2}this._buildVertexBufferLayout(t),this._buildShaderInfo(t,o),this._propertyEncodingInfo=o}_buildVertexBufferLayout(t){const e=this.baseGeometryLayout;let s=e[0].stride;if(0===t.length)this._geometryLayout=e;else{const o=[];let n=s;for(const e of t)s+=a(e.type)*e.count;for(const t of e)o.push(new r(t.name,t.count,t.type,t.offset,s,t.normalized));for(const e of t)o.push(new r(e.name,e.count,e.type,n,s,e.normalized)),n+=a(e.type)*e.count;this._geometryLayout=o}this.opacityLayout?this._locations=o([this._geometryLayout,this.opacityLayout]):this._locations=n(this._geometryLayout),this._stride=s}_buildShaderInfo(t,e){let o="\n",n="\n";const r=[];for(const s of t)o+=`attribute ${this._getType(s.count)} ${s.name};\n`;const{attributesInfo:a,attributes:c}=this;let u=-1;for(const h of c){u++;const{name:t,type:c,precisionFactor:d,isLayout:f}=a[h],l=d&&1!==d?" * "+1/d:"",{bytesPerElement:y,count:_}=s._encodingInfo[c],m=t=>`a_data_${t.dataIndex}${i(_,t.offset,y)}`;switch(this.getAtributeState(u)){case 0:{const e=this._getType(_),s=`u_${t}`;r.push({name:s,type:e,getValue:(t,e,o,n)=>{const r=f?t.getLayoutValue(h,e):t.getPaintValue(h,e);if(11===c){const o=t.getDashKey(r,t.getLayoutValue("line-cap",e)),s=n.getMosaicItemPosition(o,!1);if(null==s)return null;const{tl:a,br:i}=s;return[a[0],i[1],i[0],a[1]]}if(12===c){const t=n.getMosaicItemPosition(r,!h.includes("line-"));if(null==t)return null;const{tl:e,br:o}=t;return[e[0],o[1],o[0],e[1]]}if(10===c){const t=r[3];return[t*r[0],t*r[1],t*r[2],t]}return r}}),o+=`uniform ${e} ${s};\n`,n+=`${e} ${t} = ${s};\n`}break;case 1:{const o=m(e[h][0]);n+=`${this._getType(_)} ${t} = ${o}${l};\n`}break;case 2:{const s=`u_t_${t}`;r.push({name:s,type:"float",getValue:(t,e,o,n)=>(f?t.getLayoutProperty(h):t.getPaintProperty(h)).interpolator.interpolationUniformValue(o,e)}),o+=`uniform float ${s};\n`;const a=m(e[h][0]),i=m(e[h][1]);n+=`${this._getType(_)} ${t} = mix(${a}${l}, ${i}${l}, ${s});\n`}}}this._shaderHeader=o,this._shaderMain=n,this._uniforms=r}_bit(t){return(this._key&1<<t)>>t}_getType(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4"}throw new Error("Invalid count")}_encodeColor(e){const o=255*e[3];return t.i8888to32(e[0]*o,e[1]*o,e[2]*o,o)}_encodePattern(t,e,o){if(!o?.rect)return;const n=2,r=o.rect,s=o.width,a=o.height;e[t]=this._encodeShort(r.x+n,0),e[t]|=this._encodeShort(r.y+n+a,16),e[t+1]=this._encodeShort(r.x+n+s,0),e[t+1]|=this._encodeShort(r.y+n,16)}_encodeByte(t,e){return(255&t)<<e}_encodeShort(t,e){return(65535&t)<<e}}const a=t=>{switch(t){case e.FLOAT:case e.INT:case e.UNSIGNED_INT:return 4;case e.SHORT:case e.UNSIGNED_SHORT:case e.HALF_FLOAT:return 2;case e.BYTE:case e.UNSIGNED_BYTE:return 1}},i=(t,e,o)=>{const n=e/o;if(1===t)switch(n){case 0:return".x";case 1:return".y";case 2:return".z";case 3:return".w"}else if(2===t)switch(n){case 0:return".xy";case 1:return".yz";case 2:return".zw"}else if(3===t)switch(n){case 0:return".xyz";case 1:return".yzw"}return""};export{s as VTLMaterial};
