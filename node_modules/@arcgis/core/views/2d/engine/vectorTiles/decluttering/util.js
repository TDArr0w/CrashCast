/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isCircleOverlapingRect as t}from"../GeometryUtils.js";import{VTLSymbol as e}from"./core.js";function o(t,e,o,l){return s(t,e,o.level,o.col,l.key.level,l.key.col)}function l(t,e,o,l){return s(t,e,o.level,o.row,l.level,l.row)}function s(t,e,o,l,s,r){const i=o-s;if(i>=0)return(e>>i)+(l-(r<<i))*(t>>i);const n=-i;return e-(r-(l<<n))*(t>>n)<<n}class r{constructor(t,e,o){this._rows=Math.ceil(e/o),this._columns=Math.ceil(t/o),this._cellSize=o,this.cells=new Array(this._rows);for(let l=0;l<this._rows;l++){this.cells[l]=new Array(this._columns);for(let t=0;t<this._columns;t++)this.cells[l][t]=[]}}getCell(t,e){const o=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._rows-1),l=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[o]&&this.cells[o][l]||null}getCellSpan(t,e,o,l){return[Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(o/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(l/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function i(t,o,l,s,r,i,n){const c=o[s++];for(let a=0;a<c;a++){const c=new e(i,n);c.xTile=o[s++],c.yTile=o[s++],c.hash=o[s++],c.priority=o[s++],c.featureIndex=o[s++];const a=o[s++],h=c.colliders();for(let t=0;t<a;t++){const t=o[s++],e=o[s++],r=o[s++],i=o[s++],n=!!o[s++],c=o[s++],a=l[s++],u=l[s++],f=o[s++],m=o[s++];h.push({xTile:t,yTile:e,dxPixels:r,dyPixels:i,hard:n,partIndex:c,width:f,height:m,minLod:a,maxLod:u})}const u=t[s++];for(let e=0;e<u;e++)c.textVertexRanges.push([t[s++],t[s++]]);const f=t[s++];for(let e=0;e<f;e++)c.iconVertexRanges.push([t[s++],t[s++]]);r.push(c)}return s}function n(t,e,o){for(const[l,s]of t.symbols)c(t,e,o,s,l)}function c(t,e,o,l,s){const r=t.layerData.get(s);if(3===r.type){for(const e of l){const l=e.uniqueSymbol;let s;if(e.selectedForRendering){const e=l.parts[0],r=e.startOpacity,i=e.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===i;const n=o?Math.floor(127*r)|i<<7:i?255:0;s=n<<24|n<<16|n<<8|n}else s=0;for(const[t,o]of e.iconVertexRanges)for(let e=t;e<t+o;e+=4)r.iconOpacity[e/4]=s;if(e.selectedForRendering){const e=l.parts[1],r=e.startOpacity,i=e.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===i;const n=o?Math.floor(127*r)|i<<7:i?255:0;s=n<<24|n<<16|n<<8|n}else s=0;for(const[t,o]of e.textVertexRanges)for(let e=t;e<t+o;e+=4)r.textOpacity[e/4]=s}r.lastOpacityUpdate=e,r.opacityChanged=!0}}function a(e,o,l,s){const r=e.colliders();let i,n,c,a;for(const h of r){if(e.uniqueSymbol?.show&&e.uniqueSymbol.parts[h.partIndex].show&&(i=h.xScreen-s[0]+h.dxScreen,n=h.yScreen-s[1]+h.dyScreen,c=i+h.width,a=n+h.height,t(l,o.x,o.y,i,n,c,a)))return!0}return!1}export{r as GridIndex,i as deserializeSymbols,a as isSearchCircleOverlapingSymbol,o as tileCoordChangeX,l as tileCoordChangeY,n as writeOpacityToBuffers};
