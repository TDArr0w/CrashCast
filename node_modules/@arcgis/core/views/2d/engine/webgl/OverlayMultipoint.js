/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{on as t}from"../../../../core/events.js";import e from"../../../../core/Handles.js";import{disposeMaybe as r}from"../../../../core/maybe.js";import{when as i,initial as s}from"../../../../core/reactiveUtils.js";import{createScreenPoint as o}from"../../../../core/screenUtils.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import a from"../../../../geometry/Point.js";import l from"../../../../geometry/Polygon.js";import{project as h}from"../../../../geometry/projectionUtils.js";import u from"../../../../layers/support/ControlPoint.js";import{DisplayObject as m}from"../DisplayObject.js";import p from"../../../layers/support/Geometry.js";import{Texture as d}from"../../../webgl/Texture.js";import{TextureDescriptor as c}from"../../../webgl/TextureDescriptor.js";const f=2;class x extends m{constructor(r){super(),this.element=r,this._handles=new e,this.isWrapAround=!1,this.perspectiveTransform=n(),this.wrapAroundShift=0,this.clipGeometry=null,this._handles.add(i(()=>this.element,()=>{const e=this.element;this.ready(),e&&this._handles.add(t(e,"play",()=>this.requestRender()))},s))}getMesh(t){throw new Error("Method not implemented.")}destroy(){super.destroy(),this._handles.destroy(),this.texture=r(this.texture)}get textureSize(){if(!this.texture)return[1,1];const t=this.texture.descriptor;return[t.width,t.height]}get dvsMat3(){return this.parent.dvsMat3}beforeRender(t){const e=this.element;if(null==e)return;const{context:r}=t,{videoWidth:i,videoHeight:s}=e;if(0!==i&&0!==s){if(this.texture)e.paused||t.animationsEnabled&&this.texture.setData(e);else{const t=new c(i,s);t.wrapMode=33071,t.preMultiplyAlpha=!0,this.texture=new d(r,t,e)}e.paused||this.texture.generateMipmap(),super.beforeRender(t)}}_createTransforms(){return null}updateDrawCoords(t,e,r,i){const s=this.element,o=this._getFrameInfo();if(!s||!o)return;const{spatialReference:n}=r;this._initializeData(t,o,n);const{controlPoints:a,horizon:u}=o,m=Math.sqrt(a.length),d=m,{x:c,y:x}=t,y=this._vertices,g=a[0],w=a[m-1],P=a[(d-1)*m],_=a[(d-1)*m+m-1],v=h(u?u[0].mapPoint:g.mapPoint,n),j=h(u?u[1].mapPoint:w.mapPoint,n),M=h(P.mapPoint,n),A=h(_.mapPoint,n);this.clipGeometry=u?new p({geometry:l.fromJSON({rings:[[[M.x,M.y],[A.x,A.y],[j.x,j.y],[v.x,v.y],[M.x,M.y]]],spatialReference:n})}):null;for(let l=0;l<a.length;l++){const t=a[l],{sourcePoint:e,mapPoint:r}=t;if(null==e||null==r)continue;const i=h(r,n);y[l*f+0]=i.x-c,y[l*f+1]=i.y-x}let b=e;if(i){const t=Math.min(v.x,j.x,M.x,A.x),e=Math.max(v.x,j.x,M.x,A.x),{worldWidth:r,xBounds:s}=i,[o,n]=s;t<o&&e>o?b=r:e>n&&t<n&&(b=-r)}this.wrapAroundShift=b,this.isWrapAround=0!==b}draw(t,e){if(!this.visible)return;if(!(this.isReady&&this._vertices&&this._indices&&this._texCoords))return void this.requestRender();this.stage||console.warn("OverlayMultipoint: stage is null"),e.render(t,{transform:{dvs:this.dvsMat3},config:{perspective:this.perspectiveTransform,texSize:this.textureSize,wrapAroundShift:this.wrapAroundShift,isWrapAround:this.isWrapAround,opacity:this.opacity,texture:{texture:this.texture,unit:0}},position:this._vertices,tex:this._texCoords,index:this._indices})}_initializeData(t,e,r){if(null!=this._vertices&&null!=this._indices)return;const{controlPoints:i}=e,s=Math.sqrt(i.length),o=s,n=new Float32Array(f*i.length),a=new Uint16Array(2*i.length);for(let m=0;m<i.length;m++){const e=i[m],{sourcePoint:s,mapPoint:o}=e;if(null==s||null==o)continue;const l=h(o,r);n[m*f+0]=l.x-t.x,n[m*f+1]=l.y-t.y,a[2*m+0]=s.x,a[2*m+1]=s.y}const l=new Uint16Array(o*s+(o-2)*(s+2));let u=0;for(let h=0;h<o;h++){for(let t=0;t<s;t++)l[u++]=h*s+t,l[u++]=(h+1)*s+t;h<o-2&&(l[u++]=(h+1)*s+(s-1),l[u++]=(h+1)*s)}this._vertices=n,this._texCoords=a,this._indices=l}_getFrameInfo(){if(!this.groundControlPoints)return null;const t=this._getFrameControlPoints(),e=this.frameHorizonPoints;let r=null;if(e){const t=e.startX,i=e.startY,s=e.endX,n=e.endY;r=[new u({sourcePoint:o(t,i),mapPoint:new a(e.startLongitude,e.startLatitude)}),new u({sourcePoint:o(s,n),mapPoint:new a(e.endLongitude,e.endLatitude)})]}return{controlPoints:t,horizon:r}}_getFrameControlPoints(){const t=this.groundControlPoints,e=t?.length;if(!e)return[];const r=new Array(e),i=Math.max(...t.map(({x:t})=>t)),s=this.element.videoWidth/i;for(let n=0;n<e;n++){const{x:e,y:i,lat:l,lon:h}=t[n];r[n]=new u({sourcePoint:o(e*s,-i*s),mapPoint:new a(h,l)})}return r}}export{x as default};
