/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{triangulate as t}from"../../../../../../geometry/libtess.js";import{TileClipper as e}from"../../../../../../geometry/support/TileClipper.js";import n from"../../../../../../layers/graphics/OptimizedGeometry.js";import{tileSize as o}from"../../definitions.js";import{bufcut as r}from"../bufcut.js";const s=1e-5,l=new e(0,0,0,1,0),i=new e(0,0,0,1,0);function f(t,e,n){let o=0;for(let r=1;r<n;r++){const n=t[2*(e+r-1)],s=t[2*(e+r-1)+1];o+=(t[2*(e+r)]-n)*(t[2*(e+r)+1]+s)}return o}function u(t,e,n,o,r){let s=0;const l=2;for(let i=n;i<o;i+=3){const n=(t[i]-r)*l,o=(t[i+1]-r)*l,f=(t[i+2]-r)*l;s+=Math.abs((e[n]-e[f])*(e[o+1]-e[n+1])-(e[n]-e[o])*(e[f+1]-e[n+1]))}return s}function h(t,e){const{coords:n,lengths:o}=e,l=0,i=t;let h=0;for(let c=0;c<o.length;){let t=c,e=o[c],a=f(n,h,e);const g=[];for(;++t<o.length;){const r=o[t],s=f(n,h+e,r);if(!(s>0))break;a+=s,g.push(h+e),e+=r}const p=i.length;r(i,n,h,h+e,g,2,l);const m=u(i,n,p,i.length,l),x=Math.abs(a);if(Math.abs((m-x)/Math.max(1e-7,x))>s)return i.length=0,!1;c=t,h+=e}return!0}function c(e){const{coords:n,lengths:o}=e,{buffer:r}=t(n,o);return r}function a(t,e,n){let o=0;for(let r=0;r<t.lengths.length;r++){const s=t.lengths[r];for(let r=0;r<s;r++){const s=t.coords[2*(r+o)],l=t.coords[2*(r+o)+1];if(s<e||s>n||l<e||l>n)return!0}o+=s}return!1}function g(t,e){if(null==t)return null;if(!a(t,-128,o+128))return t;l.setPixelMargin(e),l.reset(3);let r=0;for(let n=0;n<t.lengths.length;n++){const e=t.lengths[n];let o=t.coords[2*(0+r)],s=t.coords[2*(0+r)+1];l.moveTo(o,s);for(let n=1;n<e;n++)o=t.coords[2*(n+r)],s=t.coords[2*(n+r)+1],l.lineTo(o,s);l.close(),r+=e}const s=l.result(!1);if(!s)return null;const i=[],f=[];for(const n of s){let t=0;for(const e of n)f.push(e.x),f.push(e.y),t++;i.push(t)}return new n(i,f)}function p(t,e){i.setPixelMargin(e);const n=i,r=-e,s=o+e;let l=[],f=!1;if(!t.nextPath())return null;let u=t.pathLength(),h=!0;for(;h;){t.seekPathStart();const e=[];if(!t.pathSize)return null;n.reset(2),t.nextPoint();let o=t.x,i=t.y;if(f)n.moveTo(o,i);else{if(o<r||o>s||i<r||i>s){f=!0;continue}e.push({x:o,y:i})}let c=!1;for(;t.nextPoint();)if(o=t.x,i=t.y,f)n.lineTo(o,i);else{if(o<r||o>s||i<r||i>s){c=!0;break}e.push({x:o,y:i})}if(c)f=!0;else{if(f){const t=n.resultWithStarts();if(t)for(const e of t)l.push({...e,pathLength:u})}else l.push({line:e,start:0,pathLength:u});h=t.nextPath(),u=h?t.pathLength():0,f=!1}}return l=l.filter(t=>t.line.length>1),0===l.length?null:l}l.setExtent(o),i.setExtent(o);export{f as area,p as clipLinesMarshall,g as clipMarshall,u as triangleAreaArray,h as triangulate,c as triangulateLibtess};
