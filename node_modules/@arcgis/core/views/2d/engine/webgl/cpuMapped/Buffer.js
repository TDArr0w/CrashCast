/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import"../../../../../core/has.js";import{assertIsSome as t}from"../../../../../core/maybe.js";import{asArrayBuffer as i}from"../../../../../core/typedArrayUtil.js";import{toUint32 as r,toFloat32 as e}from"../number.js";import{PooledUint32Array as s}from"../PooledUint32Array.js";import{FreeList as n}from"./FreeList.js";import{BufferObject as h}from"../../../../webgl/BufferObject.js";import{VertexBuffer as a}from"../../../../webgl/VertexBuffer.js";const d=1.25,u=32767,f=u<<16|u;class o{constructor(t,i,r,e){this.bufferType=t,this.size=i,this.strideInt=r,this._pool=e,this._cpu=s.create(i*r*Uint32Array.BYTES_PER_ELEMENT,this._pool),this.dirty={start:1/0,end:0},this.memoryStats={bytesUsed:0,bytesReserved:i*r*Uint32Array.BYTES_PER_ELEMENT},this.clear()}get elementSize(){return this._cpu.length/this.strideInt}get intSize(){return this.fillPointer*this.strideInt}get byteSize(){return this.intSize*Uint32Array.BYTES_PER_ELEMENT}get invalidated(){return this.bufferSize>0&&!this._gpu}get invalidatedComputeBuffer(){return this.bufferSize>0&&!this._gpuComputeTriangles}get usedMemory(){return this._cpu.array.byteLength}invalidate(){this._invalidateTriangleBuffer(),this._gpu?.dispose(),this._gpu=null}_invalidateTriangleBuffer(){this._gpuComputeTriangles?.dispose(),this._gpuComputeTriangles=null}destroy(){this._gpu?.dispose(),this._gpuComputeTriangles?.dispose(),this._cpu?.destroy()}clear(){this.dirty.start=1/0,this.dirty.end=0,this.freeList=new n({start:0,end:this._cpu.length/this.strideInt}),this.fillPointer=0}ensure(t){if(this.maxAvailableSpace()>=t)return;if(t*this.strideInt>this._cpu.length-this.fillPointer){this.invalidate();const i=this._cpu.length/this.strideInt,r=Math.round((i+t)*d),e=r*this.strideInt;this._cpu.expand(e*Uint32Array.BYTES_PER_ELEMENT),this.freeList.free(i,r-i),this.memoryStats.bytesReserved+=(r-i)*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}}setU32(t,i){this._cpu.array[t]!==i&&(this._cpu.array[t]=i,this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(t+1,this.dirty.end))}setF32(t,i){this.setU32(t,r(i))}setF32Range(t,i,e){const s=r(e);this._cpu.array.fill(s,t,i),this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(i,this.dirty.end)}getF32(t){return e(this._cpu.array[t])}getVertexBuffer(t,i){return"vertex"===this.bufferType?this._getGPUBuffer(t,i):null}getIndexBuffer(t,i){return"index"===this.bufferType?this._getGPUBuffer(t,null,i):null}_getGPUBuffer(t,i,r=!1){if(this.bufferSize){if(r){if("index"!==this.bufferType)throw new Error("Tried to get triangle buffer, but target is not an index buffer");return null==this._gpuComputeTriangles&&(this._gpuComputeTriangles=this._createComputeBuffer(t)),this._gpuComputeTriangles}return this._gpu??="index"===this.bufferType?h.createIndex(t,35048,this._cpu.array):i&&new a(t,i,this._cpu.array,35048),this._gpu}}getView(t,i){return this._cpu.getUint32View(t,i/Uint32Array.BYTES_PER_ELEMENT)}get bufferSize(){return this._cpu.length/this.strideInt}maxAvailableSpace(){return this.freeList.maxAvailableSpace()}insert(r,e,s,n){const h=s*this.strideInt;if(!h)return 0;const a=e*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d=new Uint32Array(i(r),a,h),u=this.freeList.firstFit(s);t(u,"First fit region must be defined");const f=u*this.strideInt,o=h;if(this._cpu.array.set(d,f),0!==n)for(let t=0;t<d.length;t++)this._cpu.array[t+f]+=n;return this.dirty.start=Math.min(this.dirty.start,f),this.dirty.end=Math.max(this.dirty.end,f+o),this.fillPointer=Math.max(this.fillPointer,f+o),this.memoryStats.bytesUsed+=s*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,u}copyFrom(i,r,e,s,n){const h=e*this.strideInt;if(!h)return 0;const a=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d=i._cpu.getUint32View(a,h),u=this.freeList.firstFit(e);t(u,"First fit region must be defined");const f=u*this.strideInt,o=h;if(this._cpu.array.set(d,f),0!==s)for(let t=0;t<h;t++)this._cpu.array[f+t*this.strideInt+n]+=s;return this.dirty.start=Math.min(this.dirty.start,f),this.dirty.end=Math.max(this.dirty.end,f+o),this.fillPointer=Math.max(this.fillPointer,f+o),this.memoryStats.bytesUsed+=e*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,u}free(t,i,r){const e=t*this.strideInt,s=(t+i)*this.strideInt;if(!0===r)for(let n=t;n!==t+i;n++)this._cpu.array[n*this.strideInt]=f;this.dirty.start=Math.min(this.dirty.start,e),this.dirty.end=Math.max(this.dirty.end,s),this.freeList.free(t,i),this.memoryStats.bytesUsed-=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}upload(){if(this.dirty.end){if(this._invalidateTriangleBuffer(),null==this._gpu)return this.dirty.start=1/0,void(this.dirty.end=0);this._gpu.setSubData(this._cpu.array,this.dirty.start,this.dirty.start,this.dirty.end),this.dirty.start=1/0,this.dirty.end=0}}reshuffle(t,i){if(0===i.length)return;const r=this.byteSize,e=t*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,n=r>e,h=this._cpu,a=s.create(e,this._pool);n||a.array.set(this._cpu.getUint32View(0,this.intSize));for(const s of i)if(n||s.srcFrom!==s.dstFrom||0!==s.mutate){this.dirty.start=Math.min(this.dirty.start,s.dstFrom*this.strideInt),this.dirty.end=Math.max(this.dirty.end,(s.dstFrom+s.count)*this.strideInt);for(let t=0;t<s.count;t++){const i=(s.dstFrom+t)*this.strideInt,r=(s.srcFrom+t)*this.strideInt;for(let t=0;t<this.strideInt;t++)a.array[i+t]=h.array[r+t]+s.mutate}}this._cpu.destroy(),this._cpu=a,n&&this.invalidate(),this.freeList.clear(),this.memoryStats.bytesUsed=this.memoryStats.bytesReserved=e}_createComputeBuffer(t){const i=35048,r=new Uint32Array(this.fillPointer/3);for(let e=0;e<this.fillPointer;e+=3)r[e/3]=this._cpu.array[e];return h.createIndex(t,i,r)}}export{o as MappedBuffer};
