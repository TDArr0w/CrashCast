/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{PixelType as t}from"../../../../../webgl/enums.js";import{Texture as e}from"../../../../../webgl/Texture.js";import{TextureDescriptor as s}from"../../../../../webgl/TextureDescriptor.js";import{ValidatedTextureDescriptor as r}from"../../../../../webgl/ValidatedTextureDescriptor.js";class o{constructor(){this._entries=new n,this._nodes=new Map,this._book=new h}add(t){let e=this._entries.get(t);if(!e){const s=this._book.add(t),r=new Object;e={location:s,references:0,handle:r};const o=this._entries.set(t,e);this._nodes.set(r,o)}return e.references++,e}remove(t){const e=this._nodes.get(t.handle);e&&e.payload&&(e.payload.references--,0===e.payload.references&&(this._book.remove(e.payload.location),this._entries.delete(e),this._nodes.delete(t.handle)))}getTexture(t,e){return this._book.getTexture(t,e)}destroy(){this._book.destroy()}}class i{constructor(t,e){this.parent=t,this.key=e,this.payload=null,this._children=new Map}get(t){return this._children.get(t)}ensure(t){let e=this._children.get(t);return e||(e=new i(this,t),this._children.set(t,e)),e}delete(t){this._children.delete(t)}}class n{constructor(){this._root=new i(null,NaN)}set(t,e){let s=this._root;for(const r of t)for(const t of r)s=s.ensure(t);return s.payload=e,s}delete(t){t.parent?.delete(t.key)}get(t){let e=this._root;for(const s of t)for(const t of s){const s=e.get(t);if(!s)return;e=s}return e.payload||void 0}}class h{constructor(){this._pages=[]}add(t){0===this._pages.length&&this._pages.push(new u);let e=this._pages.length-1,s=this._pages[e].add(t);if(s||(this._pages.push(new u),e=this._pages.length-1,s=this._pages[e].add(t)),!s)throw new Error("Data allocation failed.");return{...s,page:e}}remove(t){this._pages[t.page].remove(t)}getTexture(t,e){return this._pages[e].getTexture(t)}destroy(){}}class u{constructor(){this._cursor={row:0,column:0},this._columns=1024,this._rows=1024,this._data=new Float32Array(this._columns*this._rows*4),this._texture=null,this._textureCursor={row:0,column:0}}add(t){if(t.length>this._columns)throw new Error(`The maximum allocation size is ${this._columns} texels.`);const e={...this._cursor};if(e.column+=t.length,e.column>=this._columns&&(e.column=t.length,e.row++),e.row>=this._rows)return null;this._cursor=e;const s={...this._cursor};s.column-=t.length;let r=4*(s.row*this._columns+s.column);for(let o=0;o<t.length;o++)this._data[r++]=t[o][0],this._data[r++]=t[o][1],this._data[r++]=t[o][2],this._data[r++]=t[o][3];return s}remove(t){}getTexture(o){if(!this._texture){const i=new s(this._columns,this._rows);i.pixelFormat=6408,i.dataType=t.FLOAT,i.wrapMode=33071,i.samplingMode=9728,i.hasMipmap=!1;const n=new r(o,i);this._texture=new e(o,n)}if(this._cursor.row===this._textureCursor.row&&this._cursor.column===this._textureCursor.column)return this._texture;const i=this._textureCursor.row,n=this._cursor.row-i+1;return this._texture.updateData(0,0,i,this._columns,n,this._data,i),this._textureCursor.row=this._cursor.row,this._textureCursor.column=this._cursor.column,this._texture}destroy(){this._texture?.dispose()}}export{o as AnimationStore,n as PrefixMap};
