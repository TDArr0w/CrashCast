/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{pt2px as e}from"../../../../../../../core/screenUtils.js";import{GeometryCursor as t}from"../../../../../../../geometry/GeometryCursor.js";import{maxTileCoordValue as i}from"../../../../../../../symbols/cim/constants.js";import{CIMMarkerPlacementHelper as r}from"../../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";import{spritePadding as s}from"../../../definitions.js";import{AAnimatedMeshWriter as n}from"./AnimatedMeshWriter.js";import{angle as o,sizing as a,animationPointerAndBaseSizeAndReferenceSize as c,uv as l,offset as m,pos as d,bitset as p,id as h,lineLength as u,value1Position2Value2 as f,zoomRange as x}from"./attributes.js";import{createComputedAnimatedMeshParams as y}from"./ComputedAnimatedParams.js";import{c256ToRad as P}from"../shaders/constants.js";const M=64,g=64,v=2;class w extends n{get vertexSpec(){return{createComputedParams:y,optionalAttributes:{zoomRange:x,value1Position2Value2:f,lineLength:u},attributes:{id:h,bitset:p,pos:d,offset:m.marker,uv:l.marker,animationPointerAndBaseSizeAndReferenceSize:c,sizing:a,angle:o}}}_write(e,i,r){const s=this.evaluatedMeshParams.sprite,{textureBinding:n}=s;e.recordStart(this.instanceId,this.attributeLayout,n);const o=i.getDisplayId();if(this.shift&&"esriGeometryPolyline"===i.geometryType){if(!r){const r=t.fromFeatureSetReaderCIM(i);r&&this._writeParticles(e,i,r)}}else if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(e,i);else if("esriGeometryPolygon"===i.geometryType){const t=i.readCentroidForDisplay();if(!t)return;const[r,s]=t.coords;this._writeQuad(e,o,r,s)}else if("esriGeometryPoint"===i.geometryType){const t=i.readXForDisplay(),r=i.readYForDisplay();this._writeQuad(e,o,t,r)}else{const t=i.readGeometryForDisplay();t&&t.forEachVertex((t,i)=>{this._writeQuad(e,o,t,i)})}e.recordEnd()}_writePlacedMarkers(s,n){const o=t.fromFeatureSetReaderCIM(n)?.clone();if(!o)return;const a=-1,c=r.getPlacement(o,a,this.evaluatedMeshParams.placement,e(1),s.id);if(!c)return;const l=n.getDisplayId();let m=c.next(),d=null;for(;null!=m;){const e=m.tx,t=-m.ty;if(Math.abs(e)>i||Math.abs(t)>i){m=c.next();continue}const r=-m.getAngle();s.recordBounds(e,t,M,g),this.shift?d&&this._writeQuad(s,l,d[0],d[1],void 0,r):this._writeQuad(s,l,e,t,void 0,r),d=[e,t],m=c.next()}}_writeParticles(e,t,i){const r=t.getDisplayId();for(;i.nextPath();){const t=[];for(;i.nextPoint();)t.push([i.x,i.y]);const s=_(t);let n=0;for(let e=1;e<t.length;e++){const i=t[e][0]-t[e-1][0],r=t[e][1]-t[e-1][1],s=Math.sqrt(i*i+r*r);n+=s}const o=t=>{for(const i of s){const{a:s,b:o}=i;this._writeQuad(e,r,s.position[0],s.position[1],[s.distance-t,o.position[0],o.position[1],o.distance-t],this.evaluatedMeshParams.angleToLine?Math.atan2(s.direction[1],s.direction[0]):0,n,!0)}},{placement:a}=this.evaluatedMeshParams;if(!a||"placementTemplate"in a||"CIMMarkerPlacementOnVertices"===a.type){let e;if(a&&"CIMMarkerPlacementOnVertices"!==a.type)e=a.placementTemplate;else{e=[0];for(const t of s){const{a:i,b:r}=t,s=i.position[0]-r.position[0],n=i.position[1]-r.position[1],o=Math.sqrt(s*s+n*n);e.push(o)}}let t=-1*n;for(;t<(1+v/2)*n;)for(const i of e)t+=i,o(t)}else"CIMMarkerPlacementAtExtremities"===a.type?"JustBegin"===a.extremityPlacement?o(1):"JustEnd"===a.extremityPlacement?(o(n-1),o(-1)):"Both"===a.extremityPlacement&&(o(1),o(n-1)):"CIMMarkerPlacementOnLine"===a.type&&("LineBeginning"===a.relativeTo?o(1):"LineEnd"===a.relativeTo?(o(n-1),o(-1)):"LineMiddle"===a.relativeTo&&o(n/2))}}_writeQuad(e,t,i,r,n,o=0,a=0,c=!1){const l=this.evaluatedMeshParams.sprite,{rect:m}=l,d=m.x+s,p=m.y+s,h=m.x+m.width-s,u=m.y+m.height-s,f=e.vertexCount();c||e.recordBounds(i,r,M,M);const x={texXmin:d,texYmin:p,texXmax:h,texYmax:u,value1Position2Value2:n,angle:o/P,lineLength:a};for(let s=0;s<4;s++)this._writeVertex(e,t,i,r,x);e.indexEnsureSize(6),e.indexWrite(f),e.indexWrite(f+1),e.indexWrite(f+2),e.indexWrite(f+1),e.indexWrite(f+3),e.indexWrite(f+2)}}function _(e){const t=[];let i=0;for(let r=1;r<e.length;r++){const s=e[r-1],n=e[r],o=n[0]-s[0],a=n[1]-s[1],c=Math.sqrt(o*o+a*a),l=o/c,m=a/c;t.push({a:{position:s,distance:i,direction:[l,m]},b:{position:n,distance:i+c,direction:[l,m]}}),i+=c}return t}class b extends w{constructor(){super(...arguments),this.shift=!1}}class C extends w{constructor(){super(...arguments),this.shift=!0}}export{b as AnimatedMarkerMeshWriter,C as AnimatedMarkerShiftMeshWriter};
