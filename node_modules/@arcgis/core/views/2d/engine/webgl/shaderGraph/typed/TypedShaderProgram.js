/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import r from"../../../../../../core/Error.js";import e from"../../../../../../core/Logger.js";import{disposeMaybe as t}from"../../../../../../core/maybe.js";import{getDeepValue as o}from"../../../../../../core/object.js";import"../../../../../webgl/BufferObject.js";import"../../../../../webgl/FramebufferObject.js";import{Program as i}from"../../../../../webgl/Program.js";import"../../../../../../core/has.js";import"../../../../../webgl/Renderbuffer.js";import"../../../../../webgl/Texture.js";import"../../../../../webgl/enums.js";import"../../../../../webgl/checkWebGLError.js";import{createTexture as s}from"../../textureUtils.js";const n=()=>e.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function a(e,t,o){const i=t.length;if(i!==o){const s=new r("Invalid Uniform",`Invalid length, expected ${o} but got ${i}`,{uniformName:e,values:t});n().errorOnce(s)}}class f{constructor(r,e,t,o,i){this.vertexShader=r,this.fragmentShader=e,this._locations=t,this._uniformBindings=o,this._transformFeedbackBindings=i,this._vao=null,this._temporaryTextures=[]}destroy(){this._program=t(this._program),this.cleanupTemporaryTextures()}setUniforms(r){this._uniforms=r}cleanupTemporaryTextures(){for(const r of this._temporaryTextures)r.dispose();this._temporaryTextures=[]}bind(r){const e=this._uniforms;if(!this._program){const e=[];for(const r of this._transformFeedbackBindings??[]){const{index:t,propertyKey:o}=r;e[t]=`v_${o}`}this._program=new i(r,this.vertexShader,this.fragmentShader,this._locations,new Map,e)}const t=this._program;r.useProgram(t);for(const i of this._uniformBindings){const{shaderModulePath:n,uniformName:f,uniformType:m,uniformArrayLength:c}=i,u=o(n,e);if(null==u){if("sampler2D"===m)continue;throw new Error(`Failed to find uniform value for ${n}`)}switch("array"===m||"array-2d"===m?i.uniformArrayElementType:m){case"sampler2D":{const{unit:e,texture:o}=u;if(t.setUniform1i(f,e),"type"in o)r.bindTexture(o,e);else{const t=s(r,o.descriptor,o.data);r.bindTexture(t,e)}break}case"int":if(!c){t.setUniform1i(f,u);break}a(i.uniformName,u,c),t.setUniform1iv(f,u);break;case"float":if(!c){t.setUniform1f(f,u);break}a(i.uniformName,u,c),t.setUniform1fv(f,u);break;case"vec2":if(!c){t.setUniform2f(f,u[0],u[1]);break}a(i.uniformName,u,c),t.setUniform2fv(f,u.flat());break;case"vec3":if(!c){t.setUniform3f(f,u[0],u[1],u[2]);break}a(i.uniformName,u,c),t.setUniform3fv(f,u.flat());break;case"vec4":if(!c){t.setUniform4f(f,u[0],u[1],u[2],u[3]);break}a(i.uniformName,u,c),t.setUniform4fv(f,u.flat());break;case"mat3":t.setUniformMatrix3fv(f,u);break;case"mat4":t.setUniformMatrix4fv(f,u);break;default:throw new Error(`Unable to set uniform for type ${m}`)}}}}export{f as TypedShaderProgram};
