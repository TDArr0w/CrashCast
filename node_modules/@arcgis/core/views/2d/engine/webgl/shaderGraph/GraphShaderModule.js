/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import"../../../../../core/has.js";import e from"../../../../../core/Logger.js";import{Float as r,Int as o,Vec4 as n,Vec2 as s}from"./graph/glsl.js";import{GlslShaderWriter as i}from"./graph/GlslGraphWriter.js";import{ShaderGraphContext as p}from"./graph/ShaderGraphContext.js";import{setReachableUids as a}from"./graph/ShaderGraphNode.js";import{TypedShaderProgram as u}from"./typed/TypedShaderProgram.js";import{ShaderBuilder as c}from"../../../../webgl/ShaderBuilder.js";function y(t){return new t}function d(t,e,r){const o=t.constructor[e]??[];t.constructor.hasOwnProperty(e)||Object.defineProperty(t.constructor,e,{value:o.slice()}),t.constructor[e].push(r)}function f(t,e){return(r,o)=>{d(r,"locations",{typeCtor:e,propertyKey:o,parameterIndex:null,index:t})}}const h=t=>(e,r)=>{d(e,"builtins",{builtin:t,propertyKey:r})},l=t=>(e,r,o)=>{d(e,"inputs",{inputCtor:t,propertyKey:r,parameterIndex:o})},m=t=>(e,r)=>{d(e,"uniforms",{typeCtor:t,propertyKey:r})},g=t=>(e,r)=>{d(e,"options",{typeCtor:t,propertyKey:r})},_=(t,e)=>{d(t,"defines",{propertyKey:e})};function K(t){return(e,r)=>{d(e,"transformFeedbackBindings",{propertyKey:r,parameterIndex:null,index:t})}}const b=(t,e)=>(r,o)=>{r.constructor.builtins.push({builtin:t,propertyKey:o,typeCtor:e})};class C{static{this.builtins=[]}}t([b("gl_VertexID",o)],C.prototype,"glVertexID",void 0);class x{}class I{static{this.builtins=[]}}t([b("gl_FragCoord",n)],I.prototype,"glFragCoord",void 0),t([b("gl_PointCoord",s)],I.prototype,"glPointCoord",void 0);class v{}t([h("gl_FragDepth")],v.prototype,"glFragDepth",void 0);class w{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class P{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(t=>"vertex"===t.propertyKey&&0===t.parameterIndex);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>"vertex"===t.propertyKey&&1===t.parameterIndex)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(t=>"fragment"===t.propertyKey);if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,r=new Set;for(const o of this.locations)r.has(o.index)?e.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${o.propertyKey} to ${o.index}. Index already in use`,{locationsMap:t}):(t.set(o.propertyKey,o.index),r.add(o.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([t,e])=>`${t}.${e}`).join("."),r=this.computeAttributes;this._locationInfo={stringHash:e,locations:t,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,o){try{const{vertex:n,fragment:s,uniformBindings:i}=this._generateShaders(t,e,r,o);return new u(n,s,this.renamedLocationsMap,i,this.transformFeedbackBindings)}catch(n){return new u("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(e=>e.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find(e=>e.propertyKey===t);if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,o){const n=Object.keys(t).map(e=>`${e}.${t[e]}`).join("."),s=Object.keys(r).map(t=>`${t}.${r[t]}`).join("."),i=Object.keys(o).map(t=>`${t}.${o[t]}`).join("."),p=Object.keys(e).filter(t=>this.optionPropertyKeys.has(t)&&e[t]).join(".");return`${this.type}.${n}.${s}.${i}.${p}`}_generateShaders(t,e,r,o){const n=[];this._setDefines(r),this._setOptionalUniforms(n,e),this._setRequiredUniforms(n);const s=this._hydrateVertexInput(o),u=this._injectPackPrecisionFactor(s,t),c=this._hydrateComputeInput(),y=c&&this._injectComputePackPrecisionFactor(c,t),d=this.vertex(u,y),f=this._hydrateFragmentInput(d),h=this.fragment(f),l=new Set;for(const i in h){const t=h[i];a(l,t)}const m=this._getVertexInputBuiltins(),g={};for(const[i,p]of Object.entries(s))g[i]=p;if(null!=c)for(const[i,p]of Object.entries(c))g[i]=p;const _=p.createVertex(g,d,m,n,this.transformFeedbackBindings,l);(new i).write(_);const K=this._getFragmentInputBuiltins(h);K.set("glPointCoord","gl_PointCoord"),K.set("glFragCoord","gl_FragCoord");const b=p.createFragment(f,h,K,n,_,this.transformFeedbackBindings);(new i).write(b);const C=this._createShaderBuilder(_,b),x=C.generate("vertex"),I=C.generate("fragment");return this.logShader&&(console.log(x),console.log(I)),{vertex:x,fragment:I,uniformBindings:n}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options){e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new(0,e.typeCtor);for(const o of r._uniforms??[]){const n=y(o.typeCtor),s=`u_${e.propertyKey}_${o.propertyKey}`,i=n.type,p=[e.propertyKey,o.propertyKey].join(".");if("type"in o.typeCtor&&"array"===o.typeCtor.type){const e=n;t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformArrayLength:e.size,uniformArrayElementType:e.elementType.type,uniformHydrated:n})}else if("type"in o.typeCtor&&"array-2d"===o.typeCtor.type){const e=n;t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformArrayLength:e.size,uniformArrayElementType:e.elementType.type,uniformHydrated:n})}else t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformHydrated:n});r[o.propertyKey]=n}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce((e,r)=>!1===t[r.propertyKey]?e:{...e,[r.propertyKey]:y(r.typeCtor)},{});for(const{propertyKey:o,typeCtor:n}of e.builtins){const t=y(n);r[o]=t}return r}_hydrateComputeInput(){if(null==this.computeInput)return null;return this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:y(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const o={};for(const n in t){const s=t[n],i=e[n];if(i){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);o[n]=s.divide(new r(i))}else o[n]=s}return o}_injectComputePackPrecisionFactor(t,e){const o={},n=new Map;for(const r in this.computeAttributes)for(const t of this.computeAttributes[r]??[])n.set(t,r);for(const s in t){const i=t[s],p=n.get(s);if(!p)continue;const a=e[p];if(a){if("float"!==i.type&&"vec2"!==i.type&&"vec3"!==i.type&&"vec4"!==i.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);o[s]=i.divide(new r(a))}else o[s]=i}return o}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:o}of I.builtins){const t=y(o);e[r]=t}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:o}of t.builtins)e.set(o,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const o of e.builtins??[])r.set(o.propertyKey,o.builtin);return r}_createShaderBuilder(t,e){const r=new c;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}}export{x as ComputeVertexInput,I as FragmentInput,v as FragmentOutput,P as GraphShaderModule,w as UniformGroup,C as VertexInput,h as builtin,_ as define,l as input,f as location,g as option,K as transformFeedback,m as uniform};
