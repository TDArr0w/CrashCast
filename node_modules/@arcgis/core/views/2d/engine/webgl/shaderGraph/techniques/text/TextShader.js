/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t,__param as e}from"tslib";import{minMaxZoomPrecisionFactor as i,labelPlacementOffsetPadding as o}from"../../../definitions.js";import{location as s,option as l,uniform as a,define as r,input as n,ComputeVertexInput as d}from"../../GraphShaderModule.js";import{abs as p,min as u,Float as y,floor as m,step as c,Vec3 as f,Mat3 as h,Vec2 as v,ifElse as w,equal as x,greaterThan as b,Bool as V,Vec4 as S,texture2D as g,smoothstep as z,Int as R,bitRShift as j,bitAnd as A}from"../../graph/glsl.js";import{AFeatureShader as C,FeatureVertexInput as M,FeatureFragmentInput as O}from"../shaders/AFeatureShader.js";import{sdfFontSize as P,maxSdfDistance as L,bitsetTextIsBackground as N,bitsetTextIsMapAligned as U}from"../shaders/constants.js";import{distPointTriangle as T,failHittest as H}from"../shaders/hittestUtils.js";import{MosaicInfo as _}from"../shaders/MosaicInfo.js";import{getBit as k}from"../shaders/utils.js";import{VisualVariableColor as I}from"../shaders/VisualVariableColor.js";import{VisualVariableOpacity as D}from"../shaders/VisualVariableOpacity.js";import{VisualVariableRotation as B}from"../shaders/VisualVariableRotation.js";import{VisualVariableSizeMinMaxValue as q}from"../shaders/VisualVariableSizeMinMaxValue.js";import{VisualVariableSizeScaleStops as E}from"../shaders/VisualVariableSizeScaleStops.js";import{VisualVariableSizeStops as F}from"../shaders/VisualVariableSizeStops.js";import{VisualVariableSizeUnitValue as W}from"../shaders/VisualVariableSizeUnitValue.js";import{getVisualVariableSize as G,getVisualVariableRotation as Z}from"../shaders/vvUtils.js";const J=360/254;class K extends M{}t([s(3,S)],K.prototype,"color",void 0),t([s(4,v)],K.prototype,"offset",void 0),t([s(5,v)],K.prototype,"textureUV",void 0),t([s(6,v)],K.prototype,"fontAndReferenceSize",void 0),t([s(7,S)],K.prototype,"outlineColor",void 0),t([s(8,S)],K.prototype,"haloColor",void 0),t([s(9,v)],K.prototype,"outlineAndHaloSize",void 0),t([s(10,v)],K.prototype,"zoomRange",void 0),t([s(11,y)],K.prototype,"clipAngle",void 0),t([s(12,S)],K.prototype,"referenceSymbol",void 0),t([s(15,y)],K.prototype,"visibility",void 0);class Q extends d{}t([s(13,v)],Q.prototype,"offsetNextVertex1",void 0),t([s(14,v)],Q.prototype,"offsetNextVertex2",void 0);class X extends O{}class Y extends C{constructor(){super(...arguments),this.type="TextShader",this.computeAttributes={offset:["offsetNextVertex1","offsetNextVertex2"]},this.textRenderPassType=0,this.isBackgroundPass=!1,this.isLabel=!1}clipLabel(t,e){const{clipAngle:o,zoomRange:s,visibility:l}=t,a=o.multiply(J),r=p(this.view.rotation.subtract(a)),n=u(new y(360).subtract(r),r);let d=new y(0);const f=m(this.view.currentZoom.multiply(i)).divide(i),h=s.x,v=s.y,w=new y(1).subtract(c(h,f)).multiply(2),x=c(new y(90),n).multiply(2),b=new y(2).multiply(new y(1).subtract(c(f,v)));return d=d.add(e.multiply(w)),d=d.add(e.multiply(x)),d=d.add(b),l&&(d=d.add(l)),d}vertex(t,e){const i=k(t.bitset,N),s=new y(1).subtract(i);let l=t.fontAndReferenceSize[0];const a=t.fontAndReferenceSize[1];let r=l.divide(P);const n=1===this.textRenderPassType?t.outlineColor:2===this.textRenderPassType?t.haloColor:this._getVertexColor(t),d=this.view.displayViewScreenMat3.multiply(new f(t.pos,1));let p=t.offset,u=new y(1),m=h.identity(),c=new v(0);if(this.isLabel){if(!t.referenceSymbol)throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");const e=t.referenceSymbol,i=e.xy,s=e.z,l=this._unpackDirection(e.w),a=G(this,t.id,s).divide(2),r=l.multiply(a.add(o));c=i.add(r),p=p.add(c)}else{u=G(this,t.id,a).divide(a),l=l.multiply(u),r=r.multiply(u),p=p.multiply(u),m=Z(this,t.id),p=m.multiply(new f(p,0)).xy}const g=k(t.bitset,U),z=this._getViewRotationMatrix(g).multiply(new f(p,0));let R=this.isLabel?this.clipLabel(t,g):this.clip(t.id,t.zoomRange);R=this.isBackgroundPass?R.add(s.multiply(2)):R.add(i.multiply(2));let j=new y(0);if(1===this.textRenderPassType){R=R.add(w(x(t.outlineAndHaloSize.x,new y(0)),new y(2),new y(0)));j=new y(t.outlineAndHaloSize.x).divide(r).divide(L)}if(2===this.textRenderPassType){const e=t.outlineAndHaloSize.x,i=new y(t.outlineAndHaloSize.y);R=R.add(w(x(i,new y(0)),new y(2),new y(0)));j=i.add(e).divide(r).divide(L)}const A=this.isLabel?b(R,new y(1)):new V(!1);return{glPosition:new S(d.xy.add(z.xy),R,1),color:n,size:r,textureUV:t.textureUV.divide(this.mosaicInfo.size),antialiasingWidth:new y(.105*P).divide(l).divide(this.view.pixelRatio),outlineDistanceOffset:j,...this.maybeRunHittest(t,e,{vvSizeAdjustment:u,vvRotation:m,labelOffset:c,labelClipped:A})}}_getViewRotationMatrix(t){const e=this.view.displayViewMat3,i=this.view.displayMat3,o=new y(1).subtract(t);return e.multiply(t).add(i.multiply(o))}fragment(t){const e=new y(2/8),i=new y(1).subtract(e),o=g(this.mosaicInfo.texture,t.textureUV).a;let s=i.subtract(t.outlineDistanceOffset);this.highlight&&(s=s.divide(2));const l=t.antialiasingWidth,a=z(s.subtract(l),s.add(l),o);return this.getFragmentOutput(t.color.multiply(a),t)}hittest(t,e,{vvSizeAdjustment:i,vvRotation:o,labelOffset:s,labelClipped:l}){let a,r,n;this.isLabel?(a=new f(t.offset.add(s),0),r=new f(e.offsetNextVertex1.add(s),0),n=new f(e.offsetNextVertex2.add(s),0)):(a=o.multiply(new f(t.offset.multiply(i),0)),r=o.multiply(new f(e.offsetNextVertex1.multiply(i),0)),n=o.multiply(new f(e.offsetNextVertex2.multiply(i),0)));const{viewMat3:d,tileMat3:p}=this.view,u=d.multiply(p).multiply(new f(t.pos,1)),y=u.add(p.multiply(a)).xy,m=u.add(p.multiply(r)).xy,c=u.add(p.multiply(n)).xy,h=T(this.hittestRequest.position,y.xy,m.xy,c.xy);return this.isLabel?w(l,H(this.hittestRequest),h):h}_unpackDirection(t){const e=new R(t),i=j(e,new R(2)),o=A(e,new R(3));return new v(new y(i).subtract(1),new y(o).subtract(1))}_getVertexColor(t){let e=t.color;if(this.visualVariableColor){const i=this.storage.getColorValue(t.id);e=this.visualVariableColor.getColor(i,t.color,new V(!1))}if(this.visualVariableOpacity){const i=this.storage.getOpacityValue(t.id),o=this.visualVariableOpacity.getOpacity(i);e=e.multiply(o)}return e}}t([l(I)],Y.prototype,"visualVariableColor",void 0),t([l(D)],Y.prototype,"visualVariableOpacity",void 0),t([l(B)],Y.prototype,"visualVariableRotation",void 0),t([l(q)],Y.prototype,"visualVariableSizeMinMaxValue",void 0),t([l(E)],Y.prototype,"visualVariableSizeScaleStops",void 0),t([l(F)],Y.prototype,"visualVariableSizeStops",void 0),t([l(W)],Y.prototype,"visualVariableSizeUnitValue",void 0),t([a(_)],Y.prototype,"mosaicInfo",void 0),t([r],Y.prototype,"textRenderPassType",void 0),t([r],Y.prototype,"isBackgroundPass",void 0),t([r],Y.prototype,"isLabel",void 0),t([e(0,n(K)),e(1,n(Q))],Y.prototype,"vertex",null),t([e(0,n(X))],Y.prototype,"fragment",null);export{X as TextFragmentInput,Y as TextShader,K as TextVertexInput};
