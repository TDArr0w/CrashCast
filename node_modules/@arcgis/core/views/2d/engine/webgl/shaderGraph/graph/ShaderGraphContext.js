/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{cloneShaderNode as e}from"./ShaderGraphNode.js";class t{constructor(e,t,a,n=[]){this.variableName=e,this.variableInputType=t,this.node=a,this.qualifiers=n,this.type="shader-input",this.isUsed=!1}clone(){return new t(this.variableName,this.variableInputType,e(this.node),[...this.qualifiers])}}class a{constructor(e,t,a,n=[]){this.outVariableName=e,this.outVariableType=t,this.node=a,this.qualifiers=n,this.type="shader-output"}clone(){const t=new a(this.outVariableName,this.outVariableType,e(this.node),[...this.qualifiers]);return t.variableName=this.variableName,t}}class n{static createVertex(e,d,s,i,r,u){const p=[];for(const a in e){const n=e[a],o=s.get(a);o?p.push(new t(o,"builtin",n)):p.push(new t("a_"+a,"in",n))}for(const a of i){const e=a.uniformHydrated;p.push(new t(a.uniformName,"uniform",e))}const c=[];for(const t in d){const e=d[t];if("glPosition"===t)c.push(new a("gl_Position","builtin",e));else if("glPointSize"===t)c.push(new a("gl_PointSize","builtin",e));else{const n=o(e),d=[];n&&d.push(n),c.push(new a("v_"+t,"out",e,d))}}return new n(p,c,r,u)}static createFragment(e,o,d,s,i,r){const u=[],p=Array.from(i.rootOutputNodes());for(const a in e){const n=e[a],o=d.get(a);if(o){u.push(new t(o,"builtin",n));continue}const s=p.find(e=>e.node===n);s&&u.push(new t(s.outVariableName,"in",n))}for(const a of s){const e=a.uniformHydrated;u.push(new t(a.uniformName,"uniform",e))}const c=[];for(const t in o){const e=o[t],n=d.get(t);switch(t){case"discard":c.push(new a(null,"discard",e));break;case"fragData0":c.push(new a("fragData0","fragData0",e));break;case"fragData1":c.push(new a("fragData1","fragData1",e));break;case"fragData2":c.push(new a("fragData2","fragData2",e));break;case"fragData3":c.push(new a("fragData3","fragData3",e));break;default:n?c.push(new a(n,"builtin",e)):c.push(new a(t,"out",e))}}return new n(u,c,r)}constructor(e,t,a,n){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const o of e)this._inputShaderTypesByNodeUid.set(o.node.uid,o);this._outputShaderTypes=t,this._transformFeedbackBindings=a,this._transformFeedbackNames=new Set(a.map(e=>"v_"+e.propertyKey)),this._usedInFragmentShader=n}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&("builtin"!==e.outVariableType&&(!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)))}setEmit(e,t){this._nodeEmitMap.set(e.uid,t)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const t of this._outputShaderTypes.values())e.push(t.node);for(;e.length;){const t=e.pop();"number"!=typeof t&&"boolean"!=typeof t&&e.push(...t.children.filter(Boolean)),yield t}}*nodesOfTypeOrFunction(){for(const e of this.nodes())"number"!=typeof e&&"boolean"!=typeof e&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new n([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this.rootOutputNodes()){const a="builtin"===t.outVariableType;if(!this.shouldPruneOutputNode(t))if(a)e.vertex.code.add(`// ${t.outVariableType.padEnd(7)} ${t.node.type.padEnd(9)} ${t.outVariableName};`);else{const a=[...t.qualifiers,t.outVariableType].join(" ");e.vertex.code.add(`${a.padEnd(10)} ${t.node.type.padEnd(9)} ${t.outVariableName};`)}}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())this.shouldPruneOutputNode(t)||e.vertex.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("// OUTPUTS: "),e.fragment.code.add("// --------------------------------------------------------- ");let t=0;for(const a of this.rootOutputNodes()){"builtin"===a.outVariableType?e.fragment.code.add(`// ${a.outVariableType.padEnd(7)} ${a.node.type.padEnd(9)} ${a.outVariableName};`):e.outputs.add(a.outVariableName,a.node.type,t++)}e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const a of this.rootOutputNodes())"discard"===a.outVariableType?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${a.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${a.outVariableName} = ${a.variableName};`);e.fragment.code.add("}")}_insertInputs(e,t){e[t].code.add("// INPUTS: "),e[t].code.add("// --------------------------------------------------------- ");for(const a of this.inputs())if(a.isUsed&&"builtin"!==a.variableInputType)if("array"===a.node.type)e[t].code.add(`${a.variableInputType.padEnd(10)} ${a.node.elementType.type.padEnd(9)} ${a.variableName}[${a.node.size}];`);else if("array-2d"===a.node.type)e[t].code.add(`${a.variableInputType.padEnd(10)} ${a.node.elementType.type.padEnd(9)} ${a.variableName}[${a.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const n=[...a.qualifiers,a.variableInputType].join(" ");e[t].code.add(` ${n.padEnd(10)} ${a.node.type.padEnd(9)} ${a.variableName};`)}}}function o(e){switch(e.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${e.type} is not a valid output type`)}}export{n as ShaderGraphContext,t as ShaderInput,a as ShaderOutput};
