/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{pt2px as e}from"../../../../../../../core/screenUtils.js";import{identity as t,translate as r,rotate as o}from"../../../../../../../core/libs/gl-matrix-2/math/mat2d.js";import{create as s}from"../../../../../../../core/libs/gl-matrix-2/factories/mat2df32.js";import{transformMat2d as a}from"../../../../../../../core/libs/gl-matrix-2/math/vec2.js";import{GeometryCursor as i}from"../../../../../../../geometry/GeometryCursor.js";import{clipCursorToTileExtent as n}from"../../../../../../../symbols/cim/CIMEffects.js";import{maxTileCoordValue as c}from"../../../../../../../symbols/cim/constants.js";import{CIMMarkerPlacementHelper as l}from"../../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";import{minMaxZoomPrecisionFactor as m}from"../../../definitions.js";import{processColorInput as u,getMinMaxZoom as d,packByteSqrt as p,getBitMask as h}from"../fill/meshWriterUtils.js";import{ComputedMarkerParams as f}from"./ComputedMarkerParams.js";import{MarkerConstants as y}from"./markerConstants.js";import{MeshWriter as M}from"../mesh/MeshWriter.js";import{DataType as x}from"../../../../../../webgl/enums.js";const P=3.14159265359/180,g=128/Math.PI;function k(e,t){return e%=t,Math.abs(e>=0?e:e+t)}function b(e){return k(e*g,256)}function v(e,a,i,n,c=!1){const l=s(),m=c?1:-1;return t(l),(a||i)&&r(l,l,[a,-i]),n&&o(l,l,m*P*-n),l}const S={createComputedParams:e=>f.from(e),optionalAttributes:{zoomRange:{type:x.SHORT,count:2,packPrecisionFactor:m,pack:({scaleInfo:e},{tileInfo:t})=>d(e,t)}},attributes:{pos:{type:x.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:x.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:x.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:t,scaleSymbolsProportionally:r,overrideOutlineColor:o,colorLocked:s})=>{let a=0;return e.sdf&&(a|=h(y.bitset.isSDF)),1===t&&(a|=h(y.bitset.isMapAligned)),r&&(a|=h(y.bitset.scaleSymbolsProportionally)),o&&(a|=h(y.bitset.overrideOutlineColor)),s&&(a|=h(y.bitset.colorLocked)),a}},offset:{type:x.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:e,computedWidth:t,computedHeight:r,anchorX:o,anchorY:s,offsetX:i,offsetY:n,rotateClockwise:c})=>{const l=v(0,i,n,-e,c),m=-(.5+o)*t,u=-(.5-s)*r,d=[m,u],p=[m+t,u],h=[m,u+r],f=[m+t,u+r];return a(d,d,l),a(p,p,l),a(h,h,l),a(f,f,l),[d,p,h,f]}}},textureUV:{type:x.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:e,texXmin:t,texYmax:r,texYmin:o})=>[[t,o],[e,o],[t,r],[e,r]]}},color:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>u(e)},outlineColor:{type:x.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>u(e)},sizing:{type:x.UNSIGNED_BYTE,count:4,pack:({rawWidth:e,rawHeight:t,outlineSize:r,referenceSize:o})=>{const s=Math.max(e,t);return[p(s,128),p(r,128),p(o,128),0]}},placementAngle:{type:x.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:e})=>b(e)},sdfDecodeCoeff:{type:x.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:e})=>e}}};class I extends M{constructor(){super(...arguments),this.vertexSpec=S}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,t,r){const o=this.evaluatedMeshParams.sprite?.textureBinding,s=t.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,o);const a=this.evaluatedMeshParams.minPixelBuffer,i=Math.max(this.evaluatedMeshParams.computedWidth,a),l=Math.max(this.evaluatedMeshParams.computedHeight,a),m=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,d=this.evaluatedMeshParams.offsetX+m,p=-this.evaluatedMeshParams.offsetY+u;if(null!=this.evaluatedMeshParams.placement){let o=null;if(null!=r){const e=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(o=n(r,2*e,!1),null===o)return}this._writePlacedMarkers(e,t,o,i,l)}else if(r?.nextPath()){r.nextPoint();const t=r.x,o=r.y;e.recordBounds(t+d,o+p,i,l),this._writeQuad(e,s,t,o)}else if("esriGeometryPolygon"===t.geometryType){const r=t.readCentroidForDisplay();if(!r)return;const[o,a]=r.coords;e.recordBounds(o+d,a+p,i,l),this._writeQuad(e,s,o,a)}else if("esriGeometryPoint"===t.geometryType){const r=t.readXForDisplay(),o=t.readYForDisplay();e.recordBounds(r+d,o+p,i,l),this._writeQuad(e,s,r,o)}else{const r=t.readGeometryForDisplay();r?.forEachVertex((t,r)=>{e.recordBounds(t+d,r+p,i,l),Math.abs(t)>c||Math.abs(r)>c||this._writeQuad(e,s,t,r)})}e.recordEnd()}_writePlacedMarkers(t,r,o,s,a){const n=o??i.fromFeatureSetReaderCIM(r);if(!n)return;const m=-1,u=l.getPlacement(n,m,this.evaluatedMeshParams.placement,e(1),t.id);if(!u)return;const d=r.getDisplayId();let p=u.next();const h=this.evaluatedMeshParams.offsetX,f=-this.evaluatedMeshParams.offsetY;for(;null!=p;){const e=p.tx,r=-p.ty;if(Math.abs(e)>c||Math.abs(r)>c){p=u.next();continue}const o=-p.getAngle();t.recordBounds(e+h,r+f,s,a),this._writeQuad(t,d,e,r,o),p=u.next()}}_writeQuad(e,t,r,o,s){const a=e.vertexCount(),i=null==s?null:{placementAngle:s};this._writeVertex(e,t,r,o,i),e.indexWrite(a+0),e.indexWrite(a+1),e.indexWrite(a+2),e.indexWrite(a+1),e.indexWrite(a+3),e.indexWrite(a+2)}}export{I as MarkerMeshWriter,S as MarkerVertexSpec};
