/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{pt2px as t}from"../../../../../../../core/screenUtils.js";import{GeometryCursor as e}from"../../../../../../../geometry/GeometryCursor.js";import{triangulate as s}from"../../../../../../../geometry/libtess.js";import{LineTessellation as i}from"../../../TurboLine.js";import{clipLinesMarshall as r,triangulate as n,clipMarshall as o}from"../../../mesh/templates/templateUtils.js";import{AAnimatedMeshWriter as a}from"./AnimatedMeshWriter.js";import{lineLength as h,noTiming as l,zoomRange as m,segmentDirection as u,normal as c,accumulatedDistance as d,sizing as f,animationPointerAndBaseSizeAndReferenceSize as p,tlbr as x,offset as _,pos as g,bitset as P,id as b,noLineLength as v}from"./attributes.js";import{createComputedAnimatedMeshParams as L}from"./ComputedAnimatedParams.js";import{processLineCapInput as y,processLineJoinInput as W}from"../fill/meshWriterUtils.js";import{LineTessellationParams as w}from"../line/LineMeshWriter.js";class C extends a{_write(t,s,i){const r=i??e.fromFeatureSetReaderCIM(s);if(!r)return;const n=this.evaluatedMeshParams.sprite,{textureBinding:o}=n;t.recordStart(this.instanceId,this.attributeLayout,o);const a=s.getDisplayId();this._writePoly(t,a,r.asOptimized()),t.recordEnd()}}class z extends C{constructor(){super(...arguments),this.vertexSpec={createComputedParams:L,attributes:{id:b,bitset:P,pos:g,offset:_.fill,tlbr:x,animationPointerAndBaseSizeAndReferenceSize:p,sizing:f},optionalAttributes:{zoomRange:m,value1Position2Value2:l,lineLength:v}}}_writePoly(t,e,i){const r=this._clip(i);if(!r)return;i=r;const o=[],a=t.vertexCount();let h;if(n(o,i)){if(0===o.length)return;h=0;for(const s of o){const r=i.coords[2*s],n=i.coords[2*s+1];this._writeVertex(t,e,r,n),h++}}else{const{coords:r,lengths:n}=i,o=s(r,n);h=o.vertexCount;for(let s=0;s<o.buffer.length/2;s++){const i=o.buffer[2*s],r=o.buffer[2*s+1];this._writeVertex(t,e,i,r)}}if(h>0){t.indexEnsureSize(h);for(let e=0;e<h;e++)t.indexWrite(e+a)}}_clip(t){const e=this.hasEffects;return o(t,e?256:8)}}class j{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}}const S=65535;class T extends C{constructor(){super(...arguments),this.vertexSpec={createComputedParams:L,attributes:{id:b,bitset:P,pos:g,offset:_.line,tlbr:x,animationPointerAndBaseSizeAndReferenceSize:p,sizing:f,accumulatedDistance:d,normal:c,segmentDirection:u},optionalAttributes:{zoomRange:m,value1Position2Value2:l,lineLength:h}},this._tessParams=new w,this._currentWrite=new j,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:S,textured:!1},this._lineLength=0,this._lineTessellator=new i((t,e,s,i,r,n,o,a,h,l,m)=>this._writeTesselatedVertex(t,e,s,i,r,n,o,a,h,l,m,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(s,i,n){const o=64,a=!1,h=r(e.fromOptimized(n,"esriGeometryPolyline"),o);if(null==h)return;const{_currentWrite:l,_tessellationOptions:m}=this,{baseSize:u,capType:c,joinType:d,miterLimit:f}=this.evaluatedMeshParams,p=t(.5*u);m.halfWidth=p,m.capType=y(c||"Round"),m.joinType=W(d||"Round"),m.miterLimit=f||2,l.out=s,l.id=i,l.vertexCount=0,l.indexCount=0,l.vertexFrom=s.vertexCount(),l.vertexBounds=1;for(const{line:t,start:e,pathLength:r}of h){m.initialDistance=e%S,l.pathLength=r,this._lineLength=0;for(let e=1;e<t.length;e++){const s=t[e].x-t[e-1].x,i=t[e].y-t[e-1].y;this._lineLength+=Math.sqrt(s*s+i*i)}this._lineTessellator.tessellate(t,m,a)}}_writeTesselatedVertex(t,e,s,i,r,n,o,a,h,l,m,u){const{out:c,id:d,vertexBounds:f,pathLength:p}=this._currentWrite;return this.hasEffects&&c.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=h,this._tessParams.normalY=l,this._tessParams.directionX=r,this._tessParams.directionY=n,this._tessParams.distance=m,this._tessParams.pathLength=p,this._tessParams.lineLength=u,this._writeVertex(c,d,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(t),i.indexWrite(e),i.indexWrite(s),this._currentWrite.indexCount+=3}}export{C as AAnimatedPolyMeshWriter,z as AnimatedFillMeshWriter,T as AnimatedLineMeshWriter};
