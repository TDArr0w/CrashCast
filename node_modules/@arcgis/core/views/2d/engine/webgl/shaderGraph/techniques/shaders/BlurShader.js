/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t,__param as e}from"tslib";import{FragmentOutput as i,uniform as r,define as o,input as l,UniformGroup as s}from"../../GraphShaderModule.js";import{Float as u,texture2D as n,sqrt as a,clamp as d,mix as p,exp as y,Sampler2D as m,Vec2 as g}from"../../graph/glsl.js";import{PostProcessingShader as f,PostProcessingFragmentInput as c}from"./PostProcessingShader.js";class v extends s{}t([r(m)],v.prototype,"texture",void 0),t([r(g)],v.prototype,"texSize",void 0),t([r(g)],v.prototype,"direction",void 0),t([r(u)],v.prototype,"sigma",void 0);class h extends f{constructor(){super(...arguments),this.type="GaussianBlurShader"}fragment(t){const e=new i,r=new u(1).divide(this.gaussianBlurConfig.texSize),o=this.gaussianBlurConfig.sigma;let l=x(new u(0),o),s=n(this.gaussianBlurConfig.texture,t.uv).multiply(l);for(let i=1;i<this.kernelRadius;i++){const e=new u(i),a=x(e,o),d=this.gaussianBlurConfig.direction.multiply(r).multiply(e),p=n(this.gaussianBlurConfig.texture,t.uv.add(d)),y=n(this.gaussianBlurConfig.texture,t.uv.subtract(d));s=s.add(p.multiply(a)).add(y.multiply(a)),l=l.add(new u(2).multiply(a))}return e.fragColor=s.divide(l),e}}function x(t,e){return new u(.39894).multiply(y(new u(-.5).multiply(t).multiply(t).divide(e.multiply(e))).divide(e))}t([o],h.prototype,"kernelRadius",void 0),t([r(v)],h.prototype,"gaussianBlurConfig",void 0),t([e(0,l(c))],h.prototype,"fragment",null);class w extends s{}t([r(m)],w.prototype,"texture",void 0);const B=1,C=2.2,S=[-.08,-.05,-.03,-.02,-.01,.01,.02,.03,.05,.08];class R extends f{constructor(){super(...arguments),this.type="RadialBlurShader"}fragment(t){const e=new i;let r=new u(.5).subtract(t.uv);const o=a(r.x.multiply(r.y).add(r.y.multiply(r.y)));r=r.divide(o);const l=n(this.radialBlurConfig.texture,t.uv);let s=l;for(let i=0;i<10;i++){const e=n(this.radialBlurConfig.texture,t.uv.add(r).multiply(new u(S[i]).multiply(B)));s=s.add(e)}const y=new u(1).divide(new u(11));s=s.multiply(y);let m=o.multiply(C);return m=d(m,new u(0),new u(1)),e.fragColor=p(l,s,m),e}}t([o],R.prototype,"kernelRadius",void 0),t([r(w)],R.prototype,"radialBlurConfig",void 0),t([e(0,l(c))],R.prototype,"fragment",null);export{h as GaussianBlurShader,R as RadialBlurShader};
