/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t,__param as e}from"tslib";import has from"../../../../../../../core/has.js";import{location as i,uniform as o,input as r,UniformGroup as s}from"../../GraphShaderModule.js";import{ifElse as n,greaterThan as a,Float as l,dot as d,min as p,length as m,mix as c,Vec2 as u,clamp as h,texture2D as y,step as g,Vec4 as v}from"../../graph/glsl.js";import{bitset as f}from"../line/gradientStrokeConstants.js";import{BaseHittestVertexInput as w}from"./AFeatureShader.js";import{LineShader as b,getLineVertexData as x,getLineAntialiasing as S,LineVertexInput as L,LineFragmentInput as j}from"./LineShader.js";import{MosaicInfo as A}from"./MosaicInfo.js";import{getBit as D,getBitBool as z,oneMinus as C}from"./utils.js";function F(t){return g(new l(0),t).multiply(2).subtract(1)}class G extends L{}t([i(9,l)],G.prototype,"accumulatedDistance",void 0),t([i(10,l)],G.prototype,"totalLength",void 0),t([i(11,l)],G.prototype,"gradientSize",void 0),t([i(12,u)],G.prototype,"segmentDirection",void 0),t([i(13,v)],G.prototype,"tlbr",void 0);class I extends j{}class P extends s{}t([o(l)],P.prototype,"isColorPass",void 0);class k extends b{constructor(){super(...arguments),this.type="GradientStrokeShader"}vertex(t,e){const{totalLength:i,gradientSize:o,segmentDirection:r,tlbr:s}=t,p=x(this,t),m=D(t.bitset,f.isAlongLine),c=i.divide(this.view.displayZoomFactor),u=n(z(t.bitset,f.isAbsoluteSize),()=>{const t=n(a(m,new l(.5)),c,p.halfWidth);return o.divide(t)},o),h=t.accumulatedDistance.add(d(r,p.scaledOffset).divide(c)),y=s.divide(this.mosaicInfo.size.xyxy);return{...p,tlbr:y,relativePositionAlongLine:h,relativeGradientSize:u,isAlongLine:D(t.bitset,f.isAlongLine),isDiscrete:D(t.bitset,f.isDiscrete),...this.maybeRunHittest(t,e,p.halfWidth)}}fragment(t){const{isAlongLine:e,isDiscrete:i,relativePositionAlongLine:o,relativeGradientSize:r,normal:s,tlbr:d}=t,v=S(t,this.antialiasingControls.blur),f=F(s.y).multiply(p(m(s),new l(1))),w=new l(.5).multiply(f).add(new l(.5)),b=n(a(e,new l(.5)),o,w),x=n(a(i,new l(.5)),r.subtract(1),new l(0));let L=b.add(x).divide(r);L=n(a(e,new l(.5)),L,C(L));const j=c(d.xy,d.zw,new u(h(L,new l(0),new l(1)),.5)),A=y(this.mosaicInfo.texture,j),D=t.opacity.multiply(v),z=this.getFragmentOutput(A.multiply(D),t),G=g(new l(.5),this.technique.isColorPass).multiply(has("gradient-depth-epsilon")),I=g(new l(0),s.y).multiply(new l(has("gradient-depth-bias")).subtract(G));return z.glFragDepth=h(m(s).add(I),new l(0),new l(1)),z}}t([o(A)],k.prototype,"mosaicInfo",void 0),t([o(P)],k.prototype,"technique",void 0),t([e(0,r(G)),e(1,r(w))],k.prototype,"vertex",null);export{I as GradientStrokeFragmentInput,k as GradientStrokeShader,G as GradientStrokeVertexInput};
