/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t,__param as e}from"tslib";import{pt2px as i}from"../../../../../../../core/screenUtils.js";import{dashSdfRasterizationScale as o,dashSdfDistanceNormalization as s}from"../../../../../../../symbols/cim/constants.js";import{location as r,uniform as a,input as l}from"../../GraphShaderModule.js";import{max as n,Float as p,fract as c,mix as m,Vec2 as u,texture2D as d,cond as y,equal as h,sqrt as f,pow as w,clamp as b,Vec4 as g,ifElse as x,greaterThan as v,dot as D}from"../../graph/glsl.js";import{BaseHittestVertexInput as S}from"./AFeatureShader.js";import{bitsetLineScaleDash as j,bitsetLineIsSdf as A,bitsetGenericConsiderAlphaOnly as z}from"./constants.js";import{LineShader as F,getLineVertexData as T,getLineAntialiasing as L,LineVertexInput as _,LineFragmentInput as I}from"./LineShader.js";import{MosaicInfo as C}from"./MosaicInfo.js";import{getBit as O,rgba2float as P}from"./utils.js";class W extends _{}t([r(9,p)],W.prototype,"accumulatedDistance",void 0),t([r(10,u)],W.prototype,"segmentDirection",void 0),t([r(11,p)],W.prototype,"offsetAlongLine",void 0),t([r(12,p)],W.prototype,"capType",void 0),t([r(13,g)],W.prototype,"tlbr",void 0);class R extends I{}class H extends F{constructor(){super(...arguments),this.type="TexturedLineShader"}_getDistanceRatio(t,e){const o=O(t.bitset,j);return o.multiply(n(e,new p(.25)).multiply(new p(2))).add(new p(1).subtract(o).multiply(i(1)))}_getSDFAlpha(t){const{halfWidth:e,normal:i,tlbr:r,patternSize:a,accumulatedDistance:l,offsetAlongLine:x,dashToPx:v,capType:D}=t,S=a.x.divide(o).multiply(v),j=c(l.add(x).divide(S)),A=m(r.xy,r.zw,new u(j,.5)),z=P(d(this.mosaicInfo.texture,A)).multiply(2).subtract(1).multiply(s).multiply(v),F=i.y.multiply(e),T=y([h(D,new p(1)),z.subtract(e)],[h(D,new p(2)),f(w(n(z,new p(0)),new p(2)).add(F.multiply(F))).subtract(e)],[!0,z]),L=b(new p(.25).subtract(T),new p(0),new p(1));return new g(L)}_getPatternColor(t){const{halfWidth:e,normal:i,color:o,accumulatedDistance:s,patternSize:r,sampleAlphaOnly:a,tlbr:l}=t,n=r.y.multiply(new p(2).multiply(e).divide(r.x)),y=c(s.divide(n)),h=new p(.5).multiply(i.y).add(new p(.5)),f=m(l.xy,l.zw,new u(h,y));let w=d(this.mosaicInfo.texture,f);return null!=this.visualVariableColor&&(w=x(v(a,new p(.5)),new g(o.a),o)),w}vertex(t,e){const{segmentDirection:i,tlbr:o,bitset:s}=t,r=T(this,t),a=t.accumulatedDistance.divide(this.view.displayZoomFactor).add(D(i,r.scaledOffset)),l=new u(o.z.subtract(o.x),o.w.subtract(o.y)),n=o.divide(this.mosaicInfo.size.xyxy),c=O(s,A),m=O(s,z),d=x(v(c,new p(.5)),this._getDistanceRatio(t,r.scaledHalfWidth),new p(1));return{...r,tlbr:n,patternSize:l,accumulatedDistance:a,isSDF:c,sampleAlphaOnly:m,dashToPx:d,offsetAlongLine:t.offsetAlongLine,capType:t.capType,...this.maybeRunHittest(t,e,r.halfWidth)}}fragment(t){const{color:e,opacity:i,isSDF:o}=t,s=L(t,this.antialiasingControls.blur),r=x(v(o,new p(.5)),this._getSDFAlpha(t),this._getPatternColor(t)),a=e.multiply(i).multiply(s).multiply(r);return this.getFragmentOutput(a,t)}}t([a(C)],H.prototype,"mosaicInfo",void 0),t([e(0,l(W)),e(1,l(S))],H.prototype,"vertex",null);export{R as TexturedLineFragmentInput,H as TexturedLineShader,W as TexturedLineVertexInput};
