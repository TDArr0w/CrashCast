/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t,__param as e}from"tslib";import{GraphShaderModule as o,FragmentOutput as r,location as i,uniform as s,define as n,input as a,VertexInput as p,UniformGroup as l,FragmentInput as u}from"../../GraphShaderModule.js";import{Vec4 as d,texture2D as m,Float as c,Vec2 as y,Sampler2D as v}from"../../graph/glsl.js";import{getHeatmapCompressionFactor as x}from"./heatmapUtils.js";class g extends p{}t([i(0,y)],g.prototype,"position",void 0);class f extends u{}class h extends l{}t([s(v)],h.prototype,"texture",void 0),t([s(y)],h.prototype,"minAndInvRange",void 0),t([s(c)],h.prototype,"normalization",void 0);class w extends l{}t([s(v)],w.prototype,"texture",void 0);class b extends o{constructor(){super(...arguments),this.type="HeatmapResolveShader",this.usesHalfFloatPrecision=!1}vertex(t){return{glPosition:new d(t.position.multiply(2).subtract(1),1,1),uv:t.position}}fragment(t){const{accumulatedDensity:e,gradient:o}=this;let i=m(e.texture,t.uv).r.divide(new c(x(this.usesHalfFloatPrecision)));i=i.multiply(e.normalization),i=i.subtract(e.minAndInvRange.x).multiply(e.minAndInvRange.y);const s=m(o.texture,new y(i,.5)),n=new r;return n.fragColor=new d(s.rgb.multiply(s.a),s.a),n}}t([n],b.prototype,"usesHalfFloatPrecision",void 0),t([s(h)],b.prototype,"accumulatedDensity",void 0),t([s(w)],b.prototype,"gradient",void 0),t([e(0,a(g))],b.prototype,"vertex",null),t([e(0,a(f))],b.prototype,"fragment",null);export{h as AccumulatedDensity,w as Gradient,f as HeatmapResolveFragmentInput,b as HeatmapResolveShader,g as HeatmapResolveVertexInput};
