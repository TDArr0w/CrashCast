/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{destroyMaybe as t}from"../../../../core/maybe.js";import{notDeepEqual as e}from"../../../../core/object.js";import{throwIfNotAbortError as s,throwIfAborted as r,after as i}from"../../../../core/promiseUtils.js";import{diff as a}from"../../../../core/accessorSupport/diffUtils.js";import{ignoreConnectionErrors as o}from"../../../../core/workers/utils.js";import{MultiTileMeshData as n}from"../../engine/webgl/mesh/MultiTileMeshData.js";import{FeatureMeshFactory as c}from"../../engine/webgl/mesh/factories/FeatureMeshFactory.js";import{ResourceProxy as h}from"../../engine/webgl/mesh/factories/ResourceProxy.js";import{MeshWriterRegistry as u}from"../../engine/webgl/shaderGraph/techniques/mesh/MeshWriterRegistry.js";import{MatcherContext as g}from"../../engine/webgl/util/MatcherContext.js";import{ProcessorTileMessageQueue as p}from"./ProcessorTileMessageQueue.js";import{BinningStrategy as y}from"./processor/BinningStrategy.js";import{ClusterStrategy as d}from"./processor/ClusterStrategy.js";import{FeatureUpdateStrategy as _}from"./processor/FeatureUpdateStrategy.js";import{TrackStrategy as l}from"./processor/TrackStrategy.js";import{AttributeStore as m}from"./support/AttributeStore.js";import{ComputedAttributeStorage as f}from"./support/ComputedAttributeStorage.js";class b{constructor(t,e){this._connection=t,this._source=e,this._version=1,this._registry=new u,this._proxy=new h({fetch:(t,e)=>this._connection.layerView.fetch(t,e),fetchDictionary:(t,e)=>this._connection.layerView.fetchDictionary(t,e)}),this._attributeStore=new m({isLocal:!1,update:t=>o(this._connection.container.updateAttributeView(t))})}destroy(){this._proxy.destroy(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}get usedMemory(){let t=0;return t+=this._attributeStore.usedMemory,this._strategy&&(t+=this._strategy.usedMemory),t}get version(){return this._version}getDisplayFeatures(t){return this._strategy?this._strategy.getDisplayFeatures(t):{features:[],aggregates:[],tracks:[]}}getDisplayIds(t){const e={};return this._strategy?(this._strategy.displayMap(t,t=>t,(t,s,r)=>{e[r]=t}),e):e}getFeatureObjectIdsForAggregate(t){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(t):[]}onSubscribe(t){this._strategy?.onSubscribe(t)}onUnsubscribe(t){this._strategy?.onUnsubscribe(t)}requiresInvalidation(){return this._strategy?.requiresInvalidation()??!1}async update(t,s,r,i,o){const n=t.processor,h=e(this._schema?.storage,n.storage),u=e(this._schema?.mesh.properties,n.mesh.properties),p=e(this._schema?.mesh.factory,n.mesh.factory),y=e(this._schema?.mesh.strategy,n.mesh.strategy),d=w(this._schema?.expressionProperties,n.expressionProperties),_=d.some(t=>this._attributeStore.hasArcadeDependency(t)),l=d.some(t=>this._factory?.hasArcadeDependency(t)??!1),m=d.some(t=>this._strategy?.hasArcadeDependency(t))||this._strategy?.isAggregate&&_,b=l||m,I=u||p||y;if(!(h||I||(l||_||m))&&!i)return!1;has("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:a(this._schema,n),schema:n}),this._schema=n;const j=new f({fields:this._source.metadata.fieldsIndex,spatialReference:this._source.metadata.outSpatialReference}),x={currentUser:n.mesh.properties.currentUser};if((h||I||_)&&(await this._attributeStore.update(n.storage,j,this._source.metadata,s),this._strategy?.invalidateAttributeData(S(n))),!i&&!I&&!b)return!1;(y||u||b)&&await this._updateStrategy(n.mesh.strategy,o,S(n),x),this._updateSortKey(j,"sortKey"in n.mesh.properties?n.mesh.properties.sortKey:null);const v="dictionary"===n.mesh.factory.symbology.type?n.mesh.factory.symbology.fieldMap:null,M=new g(j,this._proxy,r,this._registry,v);return(p||"dictionary"===n.mesh.factory.symbology.type)&&(this._factory=await c.create(M,n.mesh.factory)),this._version=s,!0}async applyOverrideUpdate(t){if(!this._strategy)return;const e=this._strategy.applyOverrideUpdate(t);for await(const r of e)try{await this._process(r)}catch(s){}}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(t){this._strategy?.removeChunks(t),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:t}){if(!this._strategy||!this._strategy.hasSubscribers)return void this._attributeStore.setHighlight(t.map(({objectId:t,highlightFlags:e})=>({objectId:t,highlightFlags:e,displayId:-1})),t);const e=this._strategy.displayMap(t,({objectId:t})=>t,(t,{highlightFlags:e},s)=>({objectId:s,displayId:t,highlightFlags:e}));this._attributeStore.setHighlight(e,t)}invalidate(){this._strategy&&this._strategy.invalidate()}async _doUpdateChunks(){if(!this._strategy)return;const t=this._strategy.updateChunks(),e=[],r=new Map;for await(const a of t){let t=r.get(a.id);null==t&&(t=new p({concurrency:16,process:t=>this._process(t)}),r.set(a.id,t));const i=t.push(a).catch(t=>s(t));e.push(i)}try{await Promise.all(e)}catch(i){}has("esri-2d-update-debug")&&console.log("SendUpdates"),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(t,e,s,r){switch(this._strategy?.destroy(),t.type){case"feature":this._strategy=new _(this._source,this._attributeStore,s,r);break;case"binning":this._strategy=await y.create(t,this._source,this._attributeStore,s,r);break;case"cluster":this._strategy=await d.create(this._connection,t,this._source,this._attributeStore,s,r);break;case"track":this._strategy=await l.create(t,this._source,this._attributeStore,s,r)}for(const i of e)this._strategy.onSubscribe(i)}async _updateSortKey(e,s){if(this._sortInfo=t(this._sortInfo?.computed),null!=s){const t=s.byRenderer?null:await e.createComputedField(s);this._sortInfo={...s,computed:t}}}async _process(t){const e=t.subscription;if(has("esri-2d-update-debug")){const s=e.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${t.end}] Processor._process`)}const s={currentUser:this._schema?.mesh.properties.currentUser};await this._fetchResources(t,s),r(e.signal);const i=await this._write(t,e.tile.createArcadeEvaluationOptions(S(this._schema)),s),a=e.tile.tileInfoView.getLODInfoAt(e.tile.key);r(e.signal);const{message:o,transferList:n}=i.serialize(a),c={objectIdMap:null,inner:t.createMessage(o,this._version,this._attributeStore.epoch)};if(this._schema?.mesh.properties.returnMeshObjectId){c.objectIdMap={};const e=t.reader?.getCursor();if(e)for(;e.next();)c.objectIdMap[e.getDisplayId()]=e.getObjectId()}if(r(e.signal),await this._connection.container.onMessage(c,{signal:e.signal,transferList:n}),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")){const s=e.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${t.end}] Processor._process.await`)}}async _fetchResources(t,e){await this._fetchMatcherResources(t),await this._fetchWriterResources(t,e)}async _fetchMatcherResources(t){if(t.reader)return this._factory.enqueueMatcherRequests(this._proxy,t.reader)}async _fetchWriterResources(t,e){if(!t.reader)return;const s=t.reader.getCursor(),r=t.subscription.tile.createArcadeEvaluationOptions(S(this._schema));for(;s.next();)this._factory.enqueueWriterRequests(this._proxy,s,r,e);await this._proxy.fetchEnqueuedResources()}async _write(t,e,s){const a=t.subscription.tile,o=t.reader?.getCursor(),c=o?.getSize()??0,h=a.tileInfoView.tileInfo.isWrappable,u=a.tileInfoView.tileInfo.spatialReference.isWGS84,g=new n(a.key,this._strategy.enablePixelBuffering,h,u,c);if(!o)return g;const p=a.createArcadeEvaluationOptions(S(this._schema));let y=0;for(;o.next();){++y%1e3||(await i(0),r(t.subscription));const n=this._getSortKeyValue(o,e);g.entityStart(o.getDisplayId(),n),this._factory.write(g,this._proxy,o,p,s,a.level),g.entityEnd()}return g}_getSortKeyValue(t,e){if(!this._sortInfo)return 0;const{computed:s,order:r,byRenderer:i}=this._sortInfo,a=i?this._factory.getSortKey(t,e):s?.read(t,e);return null==a||isNaN(a)?0:a*("asc"===r?-1:1)}}function w(t,e){const s=[];return t?.timeExtent?.start===e.timeExtent?.start&&t?.timeExtent?.end===e.timeExtent?.end||s.push("timeProperties"),s}function S(t){const{timeZone:e}=t?.mesh.properties??{},{timeExtent:s}=t?.expressionProperties??{};return{timeZone:e,timeExtent:s}}export{b as default};
