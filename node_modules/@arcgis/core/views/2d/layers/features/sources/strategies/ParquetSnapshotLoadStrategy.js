/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../../../core/Error.js";import{notDeepEqual as s}from"../../../../../../core/object.js";import{throwIfAborted as t}from"../../../../../../core/promiseUtils.js";import{difference as i}from"../../../../../../core/SetUtils.js";import r from"../../../../../../layers/support/FieldsIndex.js";import{createParquetFile as a}from"../../../../../../libs/parquet/parquet.js";import{ALoadStrategy as o}from"./ALoadStrategy.js";import{FeatureSnapshotSourceChunk as l}from"./chunks/FeatureSnapshotSourceChunk.js";import{FeatureSetReaderJSON as n}from"../../support/FeatureSetReaderJSON.js";import{FeatureSetReaderParquet as m}from"../../support/FeatureSetReaderParquet.js";class u extends o{constructor(e,s,t){super(e.metadata,s,t),this._service=e,this._chunkId=0,this._files=new Map}destroy(){super.destroy();for(const e of this._files.values())e.free();this._files.clear()}get about(){return{willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}get availableFields(){return this._schema.partial.availableFields}get definitionExpression(){return this._schema.full.definitionExpression}async tryUpdate(t,i){if(s(this.availableFields,i.availableFields)&&await this._updateFields(i.availableFields),s(this._schema.partial.urls,i.urls)){for(const e of i.urls)this._files.has(e)||await this._insert(e);for(const s of this._files.keys())if(!i.urls.includes(s))throw new e("unsupported","Removing parquet files is not supported",{previous:this._schema.partial.urls,next:i.urls})}return this._schema.partial=i,!0}async load(e){return null==this._promise&&(this._promise=this._download()),this._promise}unload(e){}_onOverride(){}async _updateFields(e){await this._promise;const s=new Set(e),t=i(s,new Set(this.availableFields)),r=this._fieldsIndex;if(null==r)return;const a=Array.from(t).map(e=>r.get(e)?.column);if(t.size)for(const i of this._files.values())await i.ensureFields(new Uint32Array(a))}async _insert(e){const s=await a(e,{geometryInfo:this._service.geometryInfo,outSpatialReference:this._service.outSpatialReference,getCustomParameters:()=>this._schema.full.customParameters}),i=this._files.size;this._files.set(e,s),t(this._options);const o=s.fields().map(e=>({name:e.name,alias:e.name,type:e.type,column:s.columnForFieldName(e.name)})),{timeZoneByFieldName:n}=this._service.metadata.fieldsIndex,u=r.fromJSON({fields:o,timeZoneByFieldName:n});this._fieldsIndex=u;const h=new Uint32Array(Array.from(this.availableFields.values()).map(e=>u.get(e)?.column).filter(e=>null!=e));await s.readAllChunks(h,this._signal,e=>{if(this._signal.aborted)return;const s=this._chunkId++,t=new m(this.metadata,u,e,s,i),r=new l(t,null,s,!1);this.store.insert(r)})}async _download(){try{await Promise.all(this._schema.partial.urls.map(e=>this._insert(e)));const e=new l(n.empty(this.metadata),null,-1,!0);this.store.insert(e)}catch(e){throw console.error(e),e}}}export{u as ParquetSnapshotLoadStrategy};
