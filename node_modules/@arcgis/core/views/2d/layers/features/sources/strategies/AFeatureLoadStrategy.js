/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../../../request.js";import t from"../../../../../../core/Error.js";import r from"../../../../../../core/Logger.js";import{notDeepEqual as s}from"../../../../../../core/object.js";import{QueueProcessor as i}from"../../../../../../core/QueueProcessor.js";import a from"../../../../../../rest/support/Query.js";import{FeatureSourceQueryInfo as n}from"../FeatureSourceQueryInfo.js";import{ALoadStrategy as o}from"./ALoadStrategy.js";import{fetchQueueConcurrency as u}from"./constants.js";import{createQueryAdapter as d}from"./support/queryAdapters.js";import{FeatureSetReaderJSON as c}from"../../support/FeatureSetReaderJSON.js";class l extends o{constructor(e,t,r){super(e.metadata,t,r),this._service=e,this._didApplyOverride=!1,this._queue=new i({concurrency:u,process:async e=>{const t={signal:e.options?.signal,query:e.query.customParameters,useRequestQueue:!0};return this._adapter.executeQuery(e.query.inner,t)}}),this._queryInfo=n.create(e,{...t.full,...t.partial},this.metadata),this._adapter=d(e,this.metadata,r.connection),this._lastEditDate=e.queryMetadata.lastEditDate}destroy(){super.destroy(),this._adapter.destroy()}unsafeSetQueryHistoricMoment(e){this._queryInfo.updateHistoricMoment(e)}async tryUpdate(e,t){if(s(this.availableFields,t.availableFields)){if(this._didApplyOverride||await this._queryLastEditDateChanged())return!1;await this._updateFields(t.availableFields)}return this._schema.partial=t,!0}async queryByObjectId(e,t){if(0===e.length)return c.empty(this.metadata);const r=this._queryInfo.createQuery({objectIds:e});return r.inner.outFields=t,this._fetch(r,null,null)}get availableFields(){return this._schema.partial.availableFields}get definitionExpression(){return this._schema.full.definitionExpression}_onOverride(){this._didApplyOverride=!0}async _updateFields(e){this._queryInfo.updateFields(e);const r=Array.from(this.store.chunks()).map(async e=>{const t=a.fromJSON(e.queryInfo.queryJSON);if(t)try{return await this._tryUpdateFields(e.reader,t,{chunkId:e.chunkId}),null}catch(r){return r}}),s=(await Promise.all(r)).filter(e=>e);if(s.length)throw new t("featurelayer-query","Encountered errors when downloading fields",{errors:s})}async _fetch(e,t,r){const s=await this._enqueue(e,t);return await this._tryUpdateFields(s,e.inner,r),s}async _queryLastEditDateChanged(){if(null==this._lastEditDate)return!1;if(!("source"in this._service))return!1;const t=this._service.source,r={...t.query,f:"json"},s=(await e(t.path,{query:r,responseType:"json"})).data.editingInfo.lastEditDate;return s!==this._lastEditDate&&(this._lastEditDate=s,!0)}async _tryUpdateFields(e,s,i){const a=this._queryInfo.createPatchFieldsQuery(s,e,i);if(!a)return;const n=await this._enqueue(a,this._options);n.getSize()===e.getSize()?e.joinAttributes(n):r.getLogger("esri.views.2d.layers.features.sources.strategies.AFetchLoadStrategy").error(new t("featurelayer-query",`Failed to join features. Expected a count of ${e.getSize()} features, but got ${n.getSize()}`,{query:a.inner.toJSON(),debugInfo:i}))}async _enqueue(e,t){return this._connection.onEvent({type:"fetchStart"}),this._queue.push({query:e,options:t}).finally(()=>{this._connection.onEvent({type:"fetchEnd",done:0===this._queue.length})})}}export{l as AFeatureLoadStrategy};
