/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import has from"../../../../../../../core/has.js";import t from"../../../../../../../core/workers/Connection.js";import{toQuantizationTransform as e}from"../../../../../../../geometry/support/quantizationUtils.js";import{convertFromFeatureSet as a,quantizeOptimizedFeatureSet as r}from"../../../../../../../layers/graphics/featureConversionUtils.js";import{queryOptimizedFeatureSet as s}from"../../../../../../../layers/ogc/ogcFeatureUtils.js";import{executeQueryPBFBuffer as i,executeQuery as o}from"../../../../../../../rest/query/operations/query.js";import{FeatureSetReaderJSON as n}from"../../../support/FeatureSetReaderJSON.js";import{FeatureSetReaderPBF as u}from"../../../support/FeatureSetReaderPBF.js";class c{constructor(t,e){this.service=t,this._metadata=e}destroy(){}}function m(t,e,a){switch(t.type){case"memory":return new p(t,e,a);case"ogc":return new h(t,e);case"feature-service":return t.queryMetadata.supportsFormatPBF&&has("featurelayer-pbf")?new d(t,e):new f(t,e)}}async function l(e){const a=new t;return await a.open(e,{}),a}class p extends c{constructor(t,e,a){super(t,e),this._ports=[],this._loaded=this._load(a)}destroy(){this._loaded.finally(()=>{this._client.close(),this._client=null;for(const t of this._ports)t.close()}).catch(()=>{})}async _load(t){this._ports=await t.layerView.openMemoryPorts(),this._client=await l(this._ports)}async executeQuery(t,e){await this._loaded;const a=await this._client.invoke("queryFeatures",t.toJSON(),e);return n.fromFeatureSet(a,this._metadata)}}class d extends c{async executeQuery(t,e){const{data:a}=await i(this.service.source,t,e),r=!t.quantizationParameters;return u.fromBuffer(a,this._metadata,r)}}class f extends c{async executeQuery(t,s){const{source:i,queryMetadata:u}=this.service;if(null!=t.quantizationParameters&&!u.supportsQuantization){const u=t.clone(),c=e(u.quantizationParameters);u.quantizationParameters=null;const{data:m}=await o(i,u,this._metadata.spatialReference,s),l=a(m,this._metadata.featureIdInfo);return r(c,l),n.fromOptimizedFeatureSet(l,this._metadata)}const{data:c}=await o(i,t,this._metadata.spatialReference,s);return"esriGeometryPoint"===this._metadata.geometryType&&(c.features=c.features?.filter(t=>{if(null!=t.geometry){const e=t.geometry;return Number.isFinite(e.x)&&Number.isFinite(e.y)}return!0})),n.fromFeatureSet(c,this._metadata)}}class h extends c{async executeQuery(t,a){if(t.quantizationParameters&&!this.service.queryMetadata.supportsQuantization){const i=t.clone(),o=e(i.quantizationParameters);i.quantizationParameters=null;const u=await s(this.service.source,t,a);return r(o,u),n.fromOptimizedFeatureSet(u,this._metadata)}const i=await s(this.service.source,t,a);return n.fromOptimizedFeatureSet(i,this._metadata)}}export{c as SourceAdapter,m as createQueryAdapter};
