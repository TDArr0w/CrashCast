/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../../../core/arrayUtils.js";import e from"../../../../../core/Logger.js";import{assertIsSome as s}from"../../../../../core/maybe.js";import{isLoaded as r,load as i,execute as a}from"../../../../../geometry/operators/gx/operatorGeodeticDensify.js";import{geodeticCurveType as o}from"../../../../../geometry/operators/support/geodeticCurveType.js";import{intersectsWithMargin as n,fromValues as l,intersects as c,empty as d,expandPointInPlace as u}from"../../../../../geometry/support/aaBoundingRect.js";import{getClosestDenormalizedXToReference as h}from"../../../../../geometry/support/normalizeUtils.js";import{normalizeCentralMeridianForDisplay as p}from"../../../../../geometry/support/normalizeUtilsSync.js";import{quantizeOptimizedGeometry as m,convertToGeometry as f,convertFromNestedArray as _}from"../../../../../layers/graphics/featureConversionUtils.js";import{OptimizedFeature as b}from"../../../../../layers/graphics/OptimizedFeature.js";import g from"../../../../../layers/graphics/OptimizedGeometry.js";import{internalTrackPartField as y,externalTrackLineOidPrefix as I,internalTimeReceivedField as v}from"../../../../../layers/support/streamLayerUtils.js";import{tileSize as k}from"../../../engine/webgl/definitions.js";import{AccumulatedStatistics as F}from"../aggregation/AccumulatedStatistics.js";import{ComputedAggregateField as O}from"../aggregation/ComputedAggregateField.js";import{AAggregateStrategy as j}from"./AAggregateStrategy.js";import{ASendState as x}from"./AProcessorStrategy.js";import{FeatureTileAppendMessage as S}from"../sources/FeatureSourceMessage.js";import{createArcadeEvaluationOptions as T}from"../support/arcadeUtils.js";import{ComputedAttributeStorage as R}from"../support/ComputedAttributeStorage.js";import D from"../support/FeatureFilterEvaluator.js";import{FeatureMetadata as w}from"../support/FeatureMetadata.js";import{FeatureSetReaderIndirect as L}from"../support/FeatureSetReaderIndirect.js";import{FeatureSetReaderJSON as A}from"../support/FeatureSetReaderJSON.js";let C;const G=()=>e.getLogger("esri.views.2d.layers.features.processor.TrackStrategy"),P=32;class W{constructor(t,e,s,r,i){this.chunkIndex=t,this.featureIndex=e,this.objectId=s,this.displayId=r,this.time=i}}class z{static getOid(t){return I+t}constructor(t,e,s,r,i,a,o,n){this._schema=t,this.trackId=e,this.objectId=s,this.displayId=r,this._fields=i,this._spatialReference=a,this._metadata=o,this._isStream=n,this._maxDisplayDuration=this._schema.maxDisplayDuration>0?this._schema.maxDisplayDuration:1/0,this._maxDisplayObservationsPerTrack=this._schema.maxDisplayObservationsPerTrack>=1?this._schema.maxDisplayObservationsPerTrack:1/0,this._observationRecords=[],this._nextObservationRecords=[],this._trackLinePath=[],this._bounds=[],this._trackLineGeometry=new g}get _trackLineAttributes(){const t={...this._latestObservationFeature?.attributes,aggregateId:this.objectId,[y]:0};if(null!=this._statistics)for(const e of this._statistics.values())t[e.field.name]=e.value;return t}get _startTimeField(){return this._metadata.timeInfo?.startTimeField}get length(){return this._observationRecords.length}*observations(){yield*this._observationRecords}*previousObservations(){for(let t=0;t<this._observationRecords.length-1;t++)yield this._observationRecords[t]}get latestObservationFeature(){return this._latestObservationFeature}get latestObservationRecord(){return this._latestObservationRecord}stageObservation(t,e){this._nextObservationRecords.push(new W(t,e.getIndex(),e.getObjectId(),e.getDisplayId(),null!=this._startTimeField?e.readAttributeAsTimestamp(this._startTimeField):null))}commitObservations(t,e,r){const i=new Set(this._nextObservationRecords.map(t=>t.objectId)),a=this._observationRecords.filter(t=>!i.has(t.objectId)).map(t=>t.objectId);let o,n;switch(this._observationRecords=[],this._trackLinePath=[],this._isStream||null==this._startTimeField||this._nextObservationRecords.sort((t,e)=>{const s=t.time,r=e.time;return null!=s&&null!=r?s-r:0}),this._schema.timeField){case"startTimeField":o=this._metadata.timeInfo?.startTimeField;break;case"endTimeField":o=this._metadata.timeInfo?.endTimeField;break;case"timeReceived":o=this._isStream?v:null}n=this._isStream?r?.end??Date.now():r?.end??-1/0;const l=e.map(t=>t.reader.getCursor());let c;for(let d=this._nextObservationRecords.length-1;d>=0&&!(this._observationRecords.length>=this._maxDisplayObservationsPerTrack);d--){const t=this._nextObservationRecords[d],e=l[t.chunkIndex];s(e),e.setIndex(t.featureIndex);const r=null!=o?e.readAttributeAsTimestamp(o):null;(null!=r?n-r:0)>=this._maxDisplayDuration||(this._commitObservation(t,e),c??=t)}if(null!=c){const{chunkIndex:e,featureIndex:r}=c,i=`${c.objectId}.latest`,o=t.createDisplayIdForObjectId(i),n=l[e];s(n),n.setIndex(r);const d=new b(n.readGeometryWorldSpace(),{...n.readAttributes(),[y]:1},null,i,o);this._latestObservationFeature&&a.push(this._latestObservationFeature.objectId),this._latestObservationFeature=d,this._latestObservationRecord=c}else this._latestObservationFeature=null;return this._trackLineGeometry=q(this._trackLineGeometry,this._trackLinePath,this._spatialReference),this._bounds=N(this._trackLineGeometry),this._nextObservationRecords=[],a}updateStatistics(t,e){this._statistics=F.create(this._fields);const r=t.map(t=>t.reader.getCursor());for(const{chunkIndex:i,featureIndex:a}of this._observationRecords){const t=r[i];s(t),t.setIndex(a),this._statistics.insert(t,e)}}overlapsTile(t){for(const e of this._bounds)if(n(e,t.bounds,P))return!0;return!1}getLatestObservationFeatureForTile(t){if(null==this._latestObservationFeature)return null;const{objectId:e,displayId:s,geometry:r,attributes:i}=this._latestObservationFeature,a=new g;m(a,r,!1,!1,this._metadata.geometryType,t.subscription.tile.transform);const o=l(1/0,1/0,-1/0,-1/0);E(a,(t,e)=>u(o,[t,e]));if(!c(o,l(0,0,k,k)))return null;return new b(a,i,null,e,s)}getTrackLineFeatureForTile(t){const e=new g;m(e,this._trackLineGeometry,!1,!1,"esriGeometryPolyline",t.subscription.tile.transform);return new b(e,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineOptimizedFeature(){return new b(this._trackLineGeometry,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineDisplayFeature(){const{_trackLineGeometry:t,_trackLineAttributes:e,displayId:s}=this;return{geometry:f(t,"esriGeometryPolyline",!1,!1),attributes:e,displayId:s}}_commitObservation(t,e){const s=e.readCentroidWorldSpace();let r=s?.coords[0],i=s?.coords[1];null==s&&(r=e.readXWorldSpace(),i=e.readYWorldSpace()),null!=r&&null!=i&&(this._observationRecords.unshift(t),this._trackLinePath.unshift([r,i]))}}class M extends x{constructor(t){super(t),this.done=!1}}class U extends j{static async create(t,e,s,a,o){const n=e.metadata.outSpatialReference,l=new R({spatialReference:n}),c=await Promise.all(t.fields.map(async t=>O.create(l,t))),d=t.featureFilter?await D.create({geometryType:e.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:e.metadata.timeInfo,fieldsIndex:e.metadata.fieldsIndex,spatialReference:n,filterJSON:t.featureFilter}):null;return n.isWrappable||r()||await Promise.all([import("../../../../../geometry/operators/support/apiConverter.js"),import("../../../../../geometry/operators/support/jsonConverter.js"),i()]).then(([t,e,s])=>{C={fromGeometryToGXGeometry:e.fromGeometryToGXGeometry,toGeometry:e.toGeometry,fromSpatialReference:t.fromSpatialReference}}),new U(t,e,s,n,c,d,a,o)}constructor(t,e,s,r,i,a,o,n){super(e,s,r,i,n),this._schema=t,this._featureFilter=a,this._arcadeContextInfo=o,this._tracks=new Map,this._handledChunks=new Set,this._metadata=e.metadata.weakCloneWithAdditionalFields([{name:y,alias:"trackPart",type:"esriFieldTypeSmallInteger"}]),this._trackLineMetadata=w.createFeature({geometryType:"esriGeometryPolyline",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:{fields:[...this._source.metadata.fieldsIndex.fields,...this.aggregateFields,{name:y,alias:"trackPart",type:"esriFieldTypeSmallInteger"},{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],timeZoneByFieldName:null},globalIdField:null,spatialReference:e.metadata.spatialReference,outSpatialReference:e.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:e.metadata.timeInfo,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}destroy(){super.destroy(),this._clear()}get _isStream(){return this._source.isStream}get enablePixelBuffering(){return!0}get isAggregate(){return!1}requiresInvalidation(){return!0}invalidate(){super.invalidate(),this._clear()}createState(t){return new M(t)}async*applyOverrideUpdate(t){G().error("Applying override to tracks is not supported")}displayMap(t,e,s){const r=new Map(t.map(t=>[e(t),t])),i=[];for(const a of this._tracks.values()){const t=r.get(a.objectId);if(null!=t){const e=s(a.displayId,t,a.objectId);i.push(e),r.delete(a.objectId);continue}const e=a.latestObservationFeature;if(e?.objectId){const t=r.get(e.objectId);if(null!=t){const a=s(e.displayId,t,e.objectId);i.push(a),r.delete(e.objectId);continue}}for(const o of a.observations()){const t=r.get(o.objectId);if(null!=t){const e=s(o.displayId,t,o.objectId);i.push(e),r.delete(o.objectId)}}}return i}getDisplayFeatures(t){const e=new Set(t),s=[],r=[],i=this._source.chunks().map(t=>t.reader.getCursor());for(const a of this._tracks.values()){if(e.has(a.displayId)&&r.push(a.getTrackLineDisplayFeature()),null!=a.latestObservationFeature&&e.has(a.latestObservationFeature.displayId)){const{displayId:t,chunkIndex:e,featureIndex:r}=a.latestObservationRecord,o=i[e];o.setIndex(r),s.push({displayId:t,...o.readLegacyFeatureWorldSpace()})}for(const{displayId:t,chunkIndex:r,featureIndex:o}of a.observations())if(e.has(t)){const e=i[r];e.setIndex(o),s.push({displayId:t,...e.readLegacyFeatureWorldSpace()})}}return{features:s,aggregates:[],tracks:r}}getFeatureObjectIdsForAggregate(t){for(const e of this._tracks.values())if(e.objectId===t)return Array.from(e.observations(),t=>t.objectId);return[]}async*updateChunks(){0===this._handledChunks.size&&this._rebuildTracks();for(const t of this._sendStates.values())yield*this._update(t)}forEachAggregateWorldSpace(t){for(const e of this._tracks.values())t(e.getTrackLineOptimizedFeature())}_clear(){for(const t of this._source.chunks())if(this._handledChunks.has(t.chunkId)){const e=t.reader.getCursor();for(;e.next();){const t=e.getObjectId();this._attributeStore.releaseDisplayIdForObjectId(t)}}this._handledChunks.clear();for(const t of this._tracks.values())this._removeTrack(t);this._tracks.clear()}_rebuildTracks(){const t=this._source.chunks();if(!t.length)return;const e=this._metadata.timeInfo?.trackIdField;if(null==e)return;const s=new Set;for(let r=0;r<t.length;r++){const i=t[r];if(this._handledChunks.has(i.chunkId))continue;this._handledChunks.add(i.chunkId);const a=i.reader.getCursor();for(;a.next();){const t=a.getObjectId();a.setDisplayId(this._attributeStore.createDisplayIdForObjectId(t));const i=a.readAttribute(e);if(null!=i&&null!=t&&(null===this._featureFilter||this._featureFilter.check(a,this._sqlOptions))){if(!this._tracks.has(i)){const t=z.getOid(i),e=this._attributeStore.createDisplayIdForObjectId(t),s=new z(this._schema,i,t,e,this.aggregateFields,this.spatialReference,this._source.metadata,this._isStream);this._tracks.set(i,s)}this._tracks.get(i).stageObservation(r,a),s.add(i)}}}for(const r of this._tracks.values())if(s.has(r.trackId)){const e=r.commitObservations(this._attributeStore,t,this._featureFilter?.timeExtent);for(const t of e)this._attributeStore.releaseDisplayIdForObjectId(t);r.updateStatistics(t,T(1,this._arcadeContextInfo))}else this._removeTrack(r)}_removeTrack(t){this._tracks.delete(t.trackId),this._attributeStore.releaseDisplayIdForObjectId(t.objectId),null!=t.latestObservationFeature&&this._attributeStore.releaseDisplayIdForObjectId(t.latestObservationFeature.objectId)}*_update(e){if(e.done)return;e.done=!this._source.updateTracking.updating;const s=[],r=[];for(const t of this._tracks.values())if(t.length>0){if(this._schema.showLatestObservation){const r=t.getLatestObservationFeatureForTile(e);null!=r&&s.push(r)}this._schema.showTrackLine&&t.overlapsTile(e.subscription.tile)&&r.push(t.getTrackLineFeatureForTile(e))}const i=A.fromOptimizedFeatures(s,this._metadata,e.subscription.tile.transform),a=A.fromOptimizedFeatures(r,this._trackLineMetadata,e.subscription.tile.transform);let o=[];if(this._schema.showPreviousObservations){const s=this._source.chunks().map(()=>[]);for(const t of this._tracks.values())for(const{chunkIndex:e,featureIndex:r}of t.previousObservations())s[e].push(r);o=this._source.chunks().map((t,r)=>{const i=t.getTileReader(e.subscription.tile);if(null==i)return null;const a=L.from(i,s[r]);return a.setProcessorAttributes({[y]:2}),"esriGeometryPoint"!==a.geometryType&&null!=a.getInTransform()||a.setTransformForDisplay(e.subscription.tile.transform),a}).filter(t)}this.events.emit("changed");const n=e.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo),l=a.getCursor();for(;l.next();)this._attributeStore.setAttributeData(l.getDisplayId(),l,n,this._sqlOptions);for(const t of o){const e=t.getCursor();for(;e.next();)this._attributeStore.setAttributeData(e.getDisplayId(),e,n,this._sqlOptions)}const c=i.getCursor();for(;c.next();)this._attributeStore.setAttributeData(c.getDisplayId(),c,n,this._sqlOptions);yield new S(e.subscription,a,!1,!1,{});for(const t of o)yield new S(e.subscription,t,!1,!1,{});yield new S(e.subscription,i,!1,e.done,{})}}function q(t,e,s){if(e.length<2)return _(t,[e],!1,!1);if(s.isWrappable){let r=!1;for(let t=1;t<e.length;t++){const i=e[t][0],a=h(i,e[t-1][0],s);i!==a&&(e[t][0]=a,r=!0)}if(r){const r=p({paths:[e],spatialReference:s});if(null!=r)return _(t,r.paths,!1,!1)}return _(t,[e],!1,!1)}const r=C.fromGeometryToGXGeometry({hasM:!1,hasZ:!1,paths:[e]}),i=C.fromSpatialReference(s);if(null!=i){const e=a(r,1e6,i,o.geodesic);if(null!=e){const s=C.toGeometry(e,i);if(null!=s&&"paths"in s)return _(t,s.paths,!1,!1)}}return _(t,[e],!1,!1)}function E(t,e){const s=2,{coords:r,lengths:i}=t;if(!i.length)return void e(r[0],r[1]);let a=0;for(let o=0;o<i.length;o++){const t=i[o];let n=0,l=0;for(let i=0;i<t;i++)n+=r[s*(i+a)],l+=r[s*(i+a)+1],e(n,l);a+=t}}function N(t){const{lengths:e,coords:s}=t,r=2;if(!e.length)return[d()];const i=[];let a=0;for(let o=0;o<e.length;o++){const t=e[o],n=d();i.push(n);for(let e=0;e<t;e++){const t=s[r*(e+a)],i=s[r*(e+a)+1];u(n,[t,i])}a+=t}return i}export{U as TrackStrategy};
