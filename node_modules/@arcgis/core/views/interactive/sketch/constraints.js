/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isSome as t,equals as e}from"../../../core/arrayUtils.js";import{asinClamped as s}from"../../../core/mathUtils.js";import{dot as n,subtract as r,squaredDistance as i,exactEquals as o,set as c}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as u}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{q as a,d as h,j as f,e as l,G as d,c as p,s as m,a as g,m as _,f as k,i as L,n as x}from"../../../chunks/vec32.js";import{create as y,UNIT_Z as z,fromValues as M,clone as P}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{s as T,g as q}from"../../../chunks/vec42.js";import{create as w}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{toRadians as j}from"../../../geometry/support/geodesicConstants.js";import{directGeodeticSolver as v,inverseGeodeticSolver as D,InverseGeodeticSolverResult as b}from"../../../geometry/support/geodesicUtils.js";import{create as R,fromPoints as A,fromPositionAndNormal as Z,intersectLine as U,signedDistance as G,projectPoint as I,getNormal as S,distance as C}from"../../../geometry/support/plane.js";import{h as O,j as E,k as V,p as B}from"../../../chunks/sphere.js";import{tangentFrame as F}from"../../3d/support/mathUtils.js";import{clone as H,asVec2 as J,createWritable as K,create as N,fromValues as Q,fromVec3 as W}from"./normalizedPoint.js";import{projectPointToVerticalPlane as X,isClose as Y,projectPointToVerticalCylinder as $,projectPointToLineLike as tt,intersectLineLikes as et,intersectVerticalPlaneAndLineLike as st,intersectLineLikeAndVerticalCylinder as nt,intersectLineLikeAndCircle as rt,intersectVerticalPlanes as it,intersectVerticalPlaneAndVerticalCylinder as ot,intersectVerticalCylinders as ct,intersectVerticalPlaneAndPoint as ut,vectorsHaveCloseZ as at,isPointInsidePlane as ht,pointsInsidePlane as ft}from"../../support/geometry3dUtils.js";class lt{intersect(t){return Et(this,t)}closestPoints(t){return[this.closestTo(t)]}}class dt extends lt{constructor(t){super(),this.point=t}equals(t){return this===t||me(t)&&a(this.point,t.point)}closestTo(){return H(this.point)}}class pt extends lt{constructor(t,e,s){super(),this.start=t,this.end=e,this.lineLike={start:t,end:e,type:s}}equals(t){return this===t||ge(t)&&this.lineLike.type===t.lineLike.type&&a(this.start,t.start)&&a(this.end,t.end)}closestTo(t){const e=K();return tt(t,this.lineLike,e),e}}class mt extends pt{constructor(t,e){super(t,e,1)}}class gt extends pt{constructor(t,e){super(t,e,0)}}class _t extends lt{constructor(t){super(),this.constraints=t}equals(t){return this===t||pe(t)&&e(this.constraints,t.constraints,(t,e)=>t.equals(e))}closestTo(t){let e,s=1/0;for(const n of this.constraints){const r=n.closestTo(t),i=m(t,r);i<s&&(s=i,e=r)}return H(e??t)}closestPoints(t){return this.constraints.flatMap(e=>e===this?[]:e.closestPoints(t))}}class kt extends lt{constructor(t,e){super(),this.center=t,this.radius=e}equals(t){return this===t||Le(t)&&this.center[0]===t.center[0]&&this.center[1]===t.center[1]&&this.radius===t.radius}closestTo(t){const e=K();return $(t,this.center,this.radius,e),e}}class Lt extends lt{constructor(t,e){super(),this.center=t,this.radius=e}equals(t){return this===t||xe(t)&&a(this.center,t.center)&&this.radius===t.radius}closestTo(t){const e=K();return $(t,this.center,this.radius,e),e[2]=this.center[2],e}asCircle(){return new xt(H(this.center),this.radius,Q(0,0,1))}}class xt extends lt{constructor(t,e,s,n=void 0){super(),this.center=t,this.radius=e,this.normal=s,this.slicePlane=n}equals(t){return this===t||ye(t)&&a(this.center,t.center)&&a(this.normal,t.normal)&&this.radius===t.radius}closestTo(t){const{center:e,radius:s}=this;I(this.getPlane(zt),t,yt);const n=g(yt,yt,e),r=_(n);if(Y(r,0))return H(t);const i=s/Math.sqrt(r),o=K();p(o,e,n,i);const{slicePlane:c}=this;if(c&&!ht(c,o)){const e=Ht(c,this);return e?.closestTo(t)??H(t)}return o}getPlane(t=R()){return Z(this.center,this.normal,t)}}const yt=y(),zt=R();class Mt extends lt{constructor(t){super(),this.z=t}equals(t){return this===t||_e(t)&&this.z===t.z}closestTo(t){return Q(t[0],t[1],this.z)}getPlane(t=R()){return f(Pt,0,0,this.z),Z(Pt,z,t)}}const Pt=y();class Tt extends lt{constructor(t,e,s){super(),this.start=t,this.end=e,this.planeLike={start:J(t),end:J(e),type:s}}equals(t){return this===t||ke(t)&&this.planeLike.type===t.planeLike.type&&a(this.start,t.start)&&a(this.end,t.end)}closestTo(t){const e=K();return X(t,this.planeLike,e),e}closestEndTo(t){const{start:e,end:s}=this.planeLike;return Math.sign(n(r(qt,s,e),r(wt,J(t),e)))>0?this.end:this.start}getPlane(t=R()){const e=h(jt,this.end);return e[2]+=1,A(this.start,this.end,e,t)}getSlicePlane(t=R()){const{start:e,end:s,type:n}=this.planeLike;if(0===n)return;const r=f(jt,e[0],e[1],0),i=f(vt,s[0],s[1],0),o=l(vt,i,r);return Z(r,o,t),t}}const qt=u(),wt=u(),jt=y(),vt=y();class Dt extends Tt{constructor(t,e){super(t,e,1)}}class bt extends Tt{constructor(t,e){super(t,e,0)}}class Rt extends lt{constructor(t,e){super(),this.sphere=E(t,e),this._center=P(t)}equals(t){return this===t||ze(t)&&V(this.sphere,t.sphere)}closestTo(t){const e=K();return B(this.sphere,t,e),e}get center(){return this._center}get radius(){return this.sphere[3]}}class At extends lt{constructor(t,e,s){super(),this.start=t,this.end=e,this.getZ=s,this.planeLike={start:J(t),end:J(e),type:0}}equals(t){return this===t||Me(t)&&a(this.start,t.start)&&a(this.end,t.end)&&this.getZ===t.getZ}closestTo(t){return Ot(this,t)}addIfOnTheGround(t,e){for(const s of e){const e=this.getZ(s[0],s[1])??0;Y(s[2],e)&&(s[2]=e,t.push(s))}}}class Zt extends lt{constructor(t,e,s){super(),this._x=t,this._y=e,this._z=s}equals(t){return this===t||Te(t)&&this._x===t._x&&this._y===t._y&&this._z===t._z}closestTo([t,e,s]){return N(this._x??t,this._y??e,this._z??s)}}class Ut extends lt{constructor(t,e,s,n,r){super(),this._origin=t,this._spatialReference=e,this._distanceMeters=s,this._z=n,this._directionDegrees=r}equals(t){return this===t||Pe(t)&&o(this._origin,t._origin)&&this._spatialReference===t._spatialReference&&this._distanceMeters===t._distanceMeters&&this._z===t._z&&this._directionDegrees===t._directionDegrees}closestTo([t,e,s]){return c(Gt,t,e),o(Gt,this._origin)||this._applyDirectionAndDistance(Gt),N(Gt[0],Gt[1],this._z??s)}_applyDirectionAndDistance(t){if(null!=this._directionDegrees&&null!=this._distanceMeters)v(t,this._origin,this._directionDegrees,this._distanceMeters,this._spatialReference);else if(null!=this._directionDegrees)St(t,this._origin,this._directionDegrees,t,this._spatialReference);else if(null!=this._distanceMeters){const{azimuth:e}=D(It,this._origin,t,this._spatialReference);v(t,this._origin,e??0,this._distanceMeters,this._spatialReference)}}}const Gt=[0,0],It=new b;function St(t,e,s,n,r){let{azimuth:i,distance:o}=D(Ct,e,n,r);i??=0;let c=o*Math.cos((i-s)*j);c=Math.max(0,c),v(t,e,s,c,r)}const Ct=new b;function Ot(t,e){const s=K();return X(e,t.planeLike,s),s[2]=t.getZ(s[0],s[1])??qe,s}function Et(t,e){if(pe(t)){const s=[];for(const n of t.constraints){const t=n.intersect(e);t&&s.push(t)}return de(s)}if(pe(e))return Et(e,t);if(Me(t))return ae(t,e);if(Me(e))return ae(e,t);if(me(t)){const{point:s}=t;if(me(e))return a(s,e.point)?t:void 0;const n=e.closestTo(s);return d(n,s)?t:void 0}if(ge(t)){if(me(e))return Et(e,t);if(ge(e))return fe(et(t.lineLike,e.lineLike));if(_e(e))return Vt(t,e);if(ke(e))return fe(st(e.planeLike,t.lineLike));if(Le(e))return fe(nt(t.lineLike,e.center,e.radius));if(ye(e))return fe(rt(t.lineLike,e));if(xe(e))return Bt(t,e);if(ze(e))return Ft(t,e)}else if(_e(t)){if(me(e)||ge(e))return Et(e,t);if(_e(e))return Jt(t,e);if(ke(e))return Kt(t,e);if(Le(e))return Nt(t,e);if(ye(e))return Wt(t,e);if(xe(e))return Qt(t,e);if(ze(e))return Xt(t,e)}else if(ke(t)){if(me(e)||ge(e)||_e(e))return Et(e,t);if(ke(e))return he(it(t.planeLike,e.planeLike));if(Le(e))return he(ot(t.planeLike,e.center,e.radius));if(ye(e))return $t(t,e);if(xe(e))return Yt(t,e);if(ze(e))return te(t,e)}else if(Le(t)){if(me(e)||ge(e)||_e(e)||ke(e))return Et(e,t);if(Le(e))return he(ct(J(t.center),t.radius,J(e.center),e.radius));if(ye(e))return ee();if(xe(e))return se(t,e);if(ze(e))return ne()}else if(ye(t)){if(me(e)||ge(e)||_e(e)||ke(e)||Le(e))return Et(e,t);if(ye(e))return re();if(xe(e))return re(e.asCircle());if(ze(e))return ie()}else if(xe(t)){if(me(e)||ge(e)||_e(e)||ke(e)||Le(e)||ye(e))return Et(e,t);if(xe(e))return oe(e,t);if(ze(e))return ce()}else if(ze(t)){if(me(e)||ge(e)||_e(e)||ke(e)||Le(e)||xe(e))return Et(e,t);if(ze(e))return ue()}}const Vt=(()=>{const t=R();return(e,s)=>{const{start:n,end:r}=e;if(at(n,r)&&Y(n[2],s.z))return e;const i=K();return U(s.getPlane(t),n,r,i)?new dt(i):void 0}})();function Bt({lineLike:t},{center:e,radius:s}){const n=e[2];return fe(nt(t,e,s).filter(t=>Y(t[2],n)))}function Ft({lineLike:t},{sphere:e}){return fe(O(e,t.start,t.end))}const Ht=(()=>{const t=w(),e=y(),n=y();return(r,i,o)=>{const{normal:c,center:u,radius:a}=i;F(c,e,n);const h=S(r),f=a*k(h,e),l=a*k(h,n);T(t,u[0],u[1],u[2],1);const d=q(r,t),m=Math.hypot(f,l),g=Y(m,0);if(Y(C(r,u),0)){if(g)return i;if(Y(a,0))return!o||ht(o,u)?new dt(H(u)):void 0;L(e,h,c),x(e,e);const t=new Array,s=P(u);p(s,s,e,a),o&&!ht(o,s)||t.push(s);const n=P(u);return p(n,n,e,-a),o&&!ht(o,n)||t.push(n),fe(t)}if(g)return;const _=-d/m;if(Math.abs(_)>1||Y(_,1))return;const z=Math.atan(f/l),M=s(_)-z,w=Math.PI-M,j=new Array,v=y();p(v,u,e,a*Math.cos(M)),p(v,v,n,a*Math.sin(M)),j.push(v);const D=y();return p(D,u,e,a*Math.cos(w)),p(D,D,n,a*Math.sin(w)),j.push(D),fe(o?ft(o,j):j)}})();function Jt(t,e){return Y(t.z,e.z)?t:void 0}function Kt({z:t},{planeLike:e}){const[s,n]=e.start,[r,i]=e.end,o=Q(s,n,t),c=Q(r,i,t);return 0===e.type?new mt(o,c):new gt(o,c)}function Nt(t,e){const[s,n]=e.center;return new Lt(Q(s,n,t.z),e.radius)}function Qt(t,e){return Y(e.center[2],t.z)?e:void 0}const Wt=(()=>{const t=R();return(e,s)=>Ht(e.getPlane(t),s,s.slicePlane)})();function Xt(t,{center:e,radius:s}){const n=Math.abs(e[2]-t.z);if(n>s&&!Y(n,s))return;const r=Q(e[0],e[1],t.z),i=Math.sqrt(s**2-n**2);return Y(i,0)?void 0:new Lt(r,i)}const Yt=(()=>{const t=R();return(e,{center:s,radius:n})=>{const r=ot(e.planeLike,s,n),i=s[2];e.getSlicePlane(t);const o=new Array;for(const[c,u]of r){const e=[c,u,i];ht(t,e)&&o.push(e)}return fe(o)}})(),$t=(()=>{const t=R(),e=R();return(s,n)=>Ht(s.getPlane(t),n,s.getSlicePlane(e))})(),te=(()=>{const t=R();return(e,{center:s,radius:n})=>{const r=e.getPlane(t),i=G(r,s),o=Math.abs(i);if(o>n&&!Y(o,n))return;const c=Math.sqrt(n**2-i**2);if(Y(c,0)){const t=K();return I(r,s,t),new dt(t)}const u=K(),a=P(S(r));return p(u,s,a,i),new xt(u,c,a,e.getSlicePlane())}})();function ee(t,e){}function se(t,e){const s=i(J(t.center),J(e.center));if(Y(s,0)&&Y(t.radius,e.radius))return e;return le(ct(J(t.center),t.radius,J(e.center),e.radius),e.center[2])}function ne(t,e){}function re(t,e){}function ie(t,e){}function oe(t,e){if(!at(t.center,e.center))return;const s=i(J(t.center),J(e.center));if(Y(s,0)&&Y(t.radius,e.radius))return t;return le(ct(J(t.center),t.radius,J(e.center),e.radius),t.center[2])}function ce(t,e){}function ue(t,e){}function ae(t,e){const{planeLike:s,getZ:n}=t,r=new Array;if(me(e))t.addIfOnTheGround(r,ut(s,e.point));else if(ge(e))t.addIfOnTheGround(r,st(s,e.lineLike));else if(Le(e))for(const[i,o]of ot(s,e.center,e.radius)){const t=n(i,o);null!=t&&r.push(M(i,o,t))}else if(ke(e)||Me(e))for(const[i,o]of it(s,e.planeLike)){const t=n(i,o)??qe;r.push(M(i,o,t))}return fe(r)}function he(t){return de(t.map(([t,e])=>{const s=Q(t,e,0),n=Q(t,e,1);return new mt(s,n)}))}function fe(t){return de(t.map(t=>t?new dt(W(t)):void 0))}function le(t,e){return fe(t.map(([t,s])=>[t,s,e]))}function de(e){if(0!==e.length)return 1===e.length?e[0]??void 0:new _t(e.filter(t))}function pe(t){return t instanceof _t}function me(t){return t instanceof dt}function ge(t){return t instanceof pt}function _e(t){return t instanceof Mt}function ke(t){return t instanceof Tt}function Le(t){return t instanceof kt}function xe(t){return t instanceof Lt}function ye(t){return t instanceof xt}function ze(t){return t instanceof Rt}function Me(t){return t instanceof At}function Pe(t){return t instanceof Ut}function Te(t){return t instanceof Zt}const qe=0;export{xt as CircleConstraint,lt as Constraint,Zt as CoordinateConstraint,At as DrapedLineConstraint,Ut as GeodesicConstraint,Lt as HorizontalCircleConstraint,Mt as HorizontalPlaneConstraint,mt as LineConstraint,pt as LineLikeConstraint,dt as PointConstraint,gt as RayConstraint,_t as SetConstraint,Rt as SphereConstraint,kt as VerticalCylinderConstraint,Dt as VerticalHalfPlaneConstraint,bt as VerticalPlaneConstraint,Tt as VerticalPlaneLikeConstraint,de as constraintOrSet,me as isPoint};
