/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{abortMaybe as n,removeMaybe as e}from"../../../core/maybe.js";import{ignoreAbortErrors as t,debounce as o}from"../../../core/promiseUtils.js";import{watch as r}from"../../../core/reactiveUtils.js";import{pointEquals as i}from"../../../layers/graphics/dehydratedFeatureComparison.js";import{clonePoint as a}from"../../../layers/graphics/hydratedFeatures.js";import{absoluteHeightElevationInfo as l}from"../../../support/elevationInfoUtils.js";import{EventPipeline as s}from"../dragEventPipeline.js";import{SnappingContext as u}from"./SnappingContext.js";import{ImmediateTask as p,TaskPriority as c}from"../../support/Scheduler.js";function f({predicate:o=()=>!0,snappingManager:i,snappingContext:a,updatingHandles:u,useZ:p=!0}){const c=new s;if(null==i)return{snappingStep:[y,c],cancelSnapping:y};let f,Z=null,j=null,z=null;const T=()=>{Z=n(Z),i.doneSnapping(),j?.frameTask.remove(),j=null,f=e(f),z=null},k=d(i,p,c);let w=null,I=null,U=null;return{snappingStep:[n=>{if(!o(n))return n;const{action:e}=n;if("start"===e){const{info:e}=n,t=m(i.view);if(j=g(a,n,t),j.context.selfSnappingZ=null,!p&&null!=e){const n=S(a.coordinateHelper,e.handle.part);null!=n&&(j.context.selfSnappingZ={value:n,elevationInfo:a.elevationInfo??l})}}if(null!=j){const{context:o,originalScenePos:a,originalPos:l}=j,{mapEnd:s,mapStart:c,scenePoints:d}=n,m=x(l,v(s,c)),g=v(c,l),S={...n,action:"update"},y=j.context,T=P(a,d),C=i.update({point:m,scenePoint:T,context:o});if(U=C,h(s,C,g,p),w=m,I=T,"end"!==e){const{frameTask:n}=j;null==Z&&(Z=new AbortController),z=e=>{u.addPromise(t(k({frameTask:n,event:S,context:y,point:m,scenePoint:T,delta:g,getLastState:()=>({point:w,scenePoint:I,updatePoint:e.forceUpdate?null:U})},Z.signal)))},z({forceUpdate:!1}),null==f&&(f=r(()=>i.options.effectiveEnabled,()=>z?.({forceUpdate:!0})))}}return"end"===e&&T(),n},c],cancelSnapping:n=>(T(),n)}}function d(n,e,t){return o(async({frameTask:o,point:r,scenePoint:a,context:l,event:s,delta:u,getLastState:p},c)=>{const f=await o.schedule(()=>n.snap({point:r,scenePoint:a,context:l,signal:c}),c);if(f.valid){let a=await o.schedule(()=>f.apply(),c);const d=p();null!=d.point&&r!==d.point&&(a=n.update({point:d.point,scenePoint:d.scenePoint,context:l})),null!=d.updatePoint&&i(a,d.updatePoint)||(h(s.mapEnd,a,u,e),t.execute(s))}})}function m(n){return"3d"===n.type?n.resourceController.scheduler.registerTask(c.SNAPPING):p}function g(n,e,t){return{context:new u({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:null!=e.info?e.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:null!=e.snapOrigin?n.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,originalScenePos:null!=e.scenePoints?e.scenePoints.sceneStart:null,frameTask:t}}function x(n,[e,t,o]){const r=a(n);return r.x+=e,r.y+=t,r.hasZ&&(r.z+=o),r}function P(n,e){return null==n||null==e?null:x(n,v(e.sceneEnd,e.sceneStart))}function v(n,e){const t=n.hasZ&&e.hasZ?n.z-e.z:0;return[n.x-e.x,n.y-e.y,t]}function h(n,e,[t,o,r],i){n.x=e.x+t,n.y=e.y+o,i&&n.hasZ&&e.hasZ&&(n.z=e.z+r)}function S(n,e){if(!n.hasZ())return null;const t=e.vertices;let o=null;for(const r of t){const e=n.getZ(r.pos);if(null!=o&&null!=e&&Math.abs(e-o)>1e-6)return null;null==o&&(o=e)}return o}function y(n){return n}export{f as createSnapDragEventPipelineStep};
