/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../Color.js";import r from"../../../core/Accessor.js";import{isSome as i}from"../../../core/arrayUtils.js";import s from"../../../core/Error.js";import has from"../../../core/has.js";import{getOrCreateMapValue as o}from"../../../core/MapUtils.js";import{debounce as a,throwIfAborted as l,ignoreAbortErrors as n}from"../../../core/promiseUtils.js";import{on as p}from"../../../core/reactiveUtils.js";import{sqlAnd as c}from"../../../core/sql.js";import{getMetersPerUnitForSR as u}from"../../../core/unitUtils.js";import{property as h}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/Logger.js";import{subclass as y}from"../../../core/accessorSupport/decorators/subclass.js";import d from"../../../geometry/Extent.js";import{getResolutionForScale as m}from"../../../geometry/support/scaleUtils.js";import{collectFields as f}from"../../../layers/support/fieldUtils.js";import{getLayerFloorFilterClause as g}from"../../../layers/support/floorFilterUtils.js";import{calculateTolerance as b}from"../../../renderers/support/clickToleranceUtils.js";import{identify as w}from"../../../rest/identify.js";import v from"../../../rest/support/IdentifyParameters.js";import{loadArcade as x}from"../../../support/loadArcade.js";import _ from"../../../symbols/SimpleMarkerSymbol.js";import{getRequiredFields as j,getFetchPopupTemplate as F}from"./popupUtils.js";let G=null;function S(e,t){return"tile"===t.type||"map-image"===t.type}let P=class extends r{constructor(e){super(e),this._featuresResolutions=new WeakMap,this.highlightGraphics=null,this.highlightGraphicUpdated=null,this.updateHighlightedFeatures=a(async e=>{this.destroyed||await this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e).catch(()=>{}))})}initialize(){const e=e=>{for(const t of e){const{sourceLayer:e}=t;null!=e&&"geometryType"in e&&"point"===e.geometryType&&t.visible&&(t.visible=!1,this.highlightGraphicUpdated?.({graphic:t,property:"visible",oldValue:!0,newValue:!1}))}this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e).catch(()=>{})),n(this.updateHighlightedFeatures(this._highlightGeometriesResolution))};this.addHandles([p(()=>this.highlightGraphics,"change",t=>e(t.added),{onListenerAdd:t=>e(t)})])}async fetchPopupFeaturesAtLocation(e,t){const{layerView:{layer:r,view:{scale:i}}}=this;if(!e)throw new s("fetchPopupFeatures:invalid-area","Nothing to fetch without area",{layer:r});const o=U(r.sublayers,i,t);if(!o.length)return[];const a=await R(r,o);if(!((r.capabilities?.operations?.supportsIdentify??!0)&&r.version>=10.5)&&!a)throw new s("fetchPopupFeatures:not-supported","query operation is disabled for this service",{layer:r});return a?this._fetchPopupFeaturesUsingQueries(e,o,t):this._fetchPopupFeaturesUsingIdentify(e,o,t)}clearHighlights(){this.highlightGraphics?.removeAll()}async _updateHighlightedFeaturesSymbols(e){for(const t of e)this._updateSymbology(t)}_updateSymbology(e){if("point"===e.geometry?.type)return this._updatePointSymbology(e)}_setGraphicSymbol(e,t){if(!t)return;const r=e.symbol;e.symbol=t,this.highlightGraphicUpdated?.({graphic:e,property:"symbol",oldValue:r,newValue:t})}_updatePointSymbology(e){const r=e.sourceLayer&&"renderer"in e.sourceLayer&&e.sourceLayer.renderer,{highlightGraphicUpdated:i,highlightGraphics:s,layerView:{view:o}}=this,a=e=>{e.visible||(e.visible=!0,i?.({graphic:e,property:"visible",oldValue:!1,newValue:!0}))};r&&"getSymbolAsync"in r?r.getSymbolAsync(e).then(async i=>{i||=new _;let l=null;const n="visualVariables"in r?r.visualVariables?.find(e=>"size"===e.type):void 0;n&&(G||(G=(await import("../../../renderers/visualVariables/support/visualVariableUtils.js")).getSize),l=G(n,e,{view:o.type,scale:o.scale,shape:"simple-marker"===i.type?i.style:null})),l||="width"in i&&"height"in i&&null!=i.width&&null!=i.height?Math.max(i.width,i.height):"size"in i?i.size:16,s?.includes(e)&&(this._setGraphicSymbol(e,new _({style:"square",size:l,color:new t([255,255,255,1/255]),xoffset:"xoffset"in i?i.xoffset:0,yoffset:"yoffset"in i?i.yoffset:0})),a(e))}):a(e)}get _updateContext(){const{layerView:{layer:e},highlightGraphics:t,highlightGraphicUpdated:r}=this;return r&&t?.length&&e.capabilities.operations.supportsQuery?{highlightGraphicUpdated:r,highlightGraphics:t}:null}get highlightFeaturesActive(){return!!this._updateContext}async _updateHighlightedFeaturesGeometries(e){this._highlightGeometriesResolution=e;const t=this._updateContext;if(!t)return;const r=this._getTargetResolution(e),i=new Map,{highlightGraphics:s,highlightGraphicUpdated:a}=t;for(const c of s)if(!this._featuresResolutions.has(c)||this._featuresResolutions.get(c)>r){const e=c.sourceLayer;o(i,e,()=>new Map).set(c.getObjectId(),c)}const{layerView:{view:l}}=this,n=Array.from(i,([e,t])=>{const i=e.createQuery();return i.objectIds=[...t.keys()],i.outFields=[e.objectIdField],i.returnGeometry=!0,i.maxAllowableOffset=r,i.outSpatialReference=l.spatialReference,e.queryFeatures(i)}),p=await Promise.all(n);if(!this.destroyed)for(const{features:o}of p)for(const e of o){const t=e.sourceLayer,o=i.get(t).get(e.getObjectId());if(o&&s.includes(o)){const t=o.geometry;o.geometry=e.geometry,a({graphic:o,property:"geometry",oldValue:t,newValue:o.geometry}),this._featuresResolutions.set(o,r)}}}_getTargetResolution(e){const t=e*u(this.layerView.view.spatialReference),r=t/16;return r<=10?0:e/t*r}async _fetchPopupFeaturesUsingIdentify(e,t,r){const i=await this._createIdentifyParameters(e,t,r);if(null==i)return[];const{results:s}=await w(this.layerView.layer.parsedUrl,i,r);return s.map(e=>e.feature)}async _createIdentifyParameters(e,t,r){const{floors:i,layer:s,timeExtent:o,view:{spatialReference:a,scale:l}}=this.layerView;if(!t.length)return null;await Promise.all(t.map(({sublayer:e})=>e.load(r).catch(()=>{})));const n=Math.min(has("mapservice-popup-identify-max-tolerance"),s.allSublayers.reduce((e,t)=>t.renderer?b({renderer:t.renderer,pointerType:r?.pointerType}):e,2)),p=this.createFetchPopupFeaturesQueryGeometry(e,n),c=m(l,a),u=Math.round(p.width/c),h=new d({xmin:p.center.x-c*u,ymin:p.center.y-c*u,xmax:p.center.x+c*u,ymax:p.center.y+c*u,spatialReference:p.spatialReference});return new v({floors:i,gdbVersion:"gdbVersion"in s?s.gdbVersion:void 0,geometry:e,height:u,layerOption:"popup",mapExtent:h,returnGeometry:!0,spatialReference:a,sublayers:s.sublayers,timeExtent:o,tolerance:n,width:u})}async _fetchPopupFeaturesUsingQueries(e,t,r){const{layerView:{floors:s,timeExtent:o}}=this,a=t.map(async({sublayer:t,popupTemplate:i})=>{if(await t.load(r).catch(()=>{}),t.capabilities&&!t.capabilities.operations.supportsQuery)return[];const a=t.createQuery(),n=b({renderer:t.renderer,pointerType:r?.pointerType}),p=this.createFetchPopupFeaturesQueryGeometry(e,n),u=new Set,[h]=await Promise.all([j(t,i),t.renderer?.collectRequiredFields(u,t.fieldsIndex)]);l(r),f(u,t.fieldsIndex,h);const y=Array.from(u).sort();a.geometry=p,a.outFields=y,a.timeExtent=o;const d=g(s,t);if(a.where=c(a.where,d),t.capabilities?.query.supportsOrderBy&&t.orderBy?.[0]){const e=t.orderBy[0],r=!e.valueExpression&&e.field,i="ascending"===e.order?"asc":"desc";r&&(a.orderByFields=[`${r} ${i}`])}const m=this._getTargetResolution(p.width/n),w=await V(i);l(r);const v="point"===t.geometryType||w&&w.arcadeUtils.hasGeometryOperations(i);v||(a.maxAllowableOffset=m);let{features:x}=await t.queryFeatures(a,r);const _=v?0:m;x=await A(t,x,r);for(const e of x)this._featuresResolutions.set(e,_);return x});return(await Promise.allSettled(a)).reduce((e,t)=>"fulfilled"===t.status?[...e,...t.value]:e,[]).filter(i)}};function U(e,t,r){const i=[];if(!e)return i;const s=e=>{const o=0===e.minScale||t<=e.minScale,a=0===e.maxScale||t>=e.maxScale;if(e.visible&&o&&a)if(e.sublayers)e.sublayers.forEach(s);else if(e.popupEnabled){const t=F(e,{...r,defaultPopupTemplateEnabled:!1});null!=t&&i.unshift({sublayer:e,popupTemplate:t})}};return e.map(s),i}function V(e){return e.expressionInfos?.length||Array.isArray(e.content)&&e.content.some(e=>"expression"===e.type)?x():Promise.resolve()}async function R(e,t){if(e.capabilities?.operations?.supportsQuery)return!0;try{return await Promise.any(t.map(({sublayer:e})=>e.load().then(()=>e.capabilities.operations.supportsQuery)))}catch{return!1}}async function A(e,t,r){const i=e.renderer;return i&&"defaultSymbol"in i&&!i.defaultSymbol&&(t=i.valueExpression?await Promise.all(t.map(e=>i.getSymbolAsync(e,r).then(t=>t?e:null))).then(e=>e.filter(e=>null!=e)):t.filter(e=>null!=i.getSymbol(e))),t}e([h({constructOnly:!0})],P.prototype,"createFetchPopupFeaturesQueryGeometry",void 0),e([h({constructOnly:!0})],P.prototype,"layerView",void 0),e([h({constructOnly:!0})],P.prototype,"highlightGraphics",void 0),e([h({constructOnly:!0})],P.prototype,"highlightGraphicUpdated",void 0),e([h({constructOnly:!0})],P.prototype,"updatingHandles",void 0),e([h()],P.prototype,"_updateContext",null),P=e([y("esri.views.layers.support.MapServiceLayerViewHelper")],P);export{P as MapServiceLayerViewHelper,U as collectPopupProviders,S as isMapServiceLayerView};
