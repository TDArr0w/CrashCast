/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import o from"../core/Accessor.js";import{clock as e}from"../core/clock.js";import i from"../core/Collection.js";import"../core/has.js";import a from"../core/Logger.js";import{removeMaybe as s}from"../core/maybe.js";import{watch as n}from"../core/reactiveUtils.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/RandomLCG.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as c}from"../core/support/UpdatingHandles.js";import{ViewEventPriorities as h}from"./input/InputManager.js";import{eventTypes as u}from"./input/ViewEvents.js";import{getToolCollectionHandles as p,areToolManipulatorsEditable as m,isCancelEvent as v}from"./interactive/interactiveToolUtils.js";import{ToolViewManagerManipulatorState as d}from"./interactive/ToolViewManagerManipulatorState.js";const g="attached",_="tools",T=1e3;let f=class extends o{constructor(t){super(t),this._updatingHandles=new c,this._clock=e,this._manipulatorState=new d,this.tools=new i,this._interacting=!1,this._interactingTimeout=T,this._interactingTimeoutHandle=null}initialize(){this.addHandles([this.view.on(u,t=>{this._handleInputEvent(t)},h.TOOL),...p(this.tools),this.tools.on("before-add",({item:t})=>{this._updateToolEditableFlag(t)}),this.tools.on("before-remove",({item:t})=>{this._manipulatorState.clearPointers(t,this._manipulatorStateEventArgs)}),this.tools.on("change",()=>{this._refreshToolWatchers()})])}destroy(){this.activeTool=null,this.tools.drain(t=>t.destroy()),this._clearInteractingTimeout(),this._interacting=!1,this._updatingHandles.destroy(),this._manipulatorState.destroy()}get _manipulatorStateEventArgs(){return{tools:this.tools,activeTool:this.activeTool,setActiveTool:t=>{this.activeTool=t},view:this.view}}set activeTool(t){if(null!=t&&!this.view.ready)return void a.getLogger(this).error("Cannot set active tool while view is not ready.");if(t===this.activeTool)return;const o=this.activeTool;this._set("activeTool",t),null!=o&&o.deactivate(),null!=t&&t.activate(),this._removeIncompleteTools(t);for(const e of this.tools){this._updateToolEditableFlag(e);const t=m(e);null!=this.activeTool&&t||this._manipulatorState.clearPointers(e,this._manipulatorStateEventArgs,!t)}}get cursor(){const t=this._manipulatorState.cursor;if(null!=t)return t;for(const o of this.tools)if(o.visible&&null!=o.cursor)return o.cursor;return null}get updating(){return this._updatingHandles.updating||this.tools.some(t=>t.updating)}get interacting(){return this._interacting}_clearInteractingTimeout(){this._interactingTimeoutHandle=s(this._interactingTimeoutHandle)}_startInteractingTimeout(){this._clearInteractingTimeout(),this._interactingTimeoutHandle=this._clock.setTimeout(()=>this._interacting=!1,this._interactingTimeout)}attach(){"3d"===this.view.type?this.addHandles([n(()=>{const{state:t}=this.view;return"camera"in t&&t.camera},()=>this._forEachManipulator(t=>t.onViewChange())),this.view.elevationProvider.on("elevation-change",t=>this._forEachManipulator(o=>o.onElevationChange(t)))],g):this.addHandles(n(()=>this.view.extent,()=>this._forEachManipulator(t=>t.onViewChange())))}detach(){this.activeTool=null,this.tools.removeAll(),this.removeHandles(g),this._clearInteractingTimeout(),this._interacting=!1}_forEachManipulator(t){for(const o of this.tools)o.manipulators&&o.manipulators.forEach(({manipulator:e})=>t(e,o))}_handleInputEvent(t){let o=!1;const e={...t,stopPropagation:()=>{o=!0,t.stopPropagation()}};if(null!=this.activeTool)this.activeTool.handleInputEvent&&this.activeTool.handleInputEvent(e);else for(const i of this.tools)!o&&i.visible&&i.handleInputEvent(e);!o&&v(t)&&this.activeTool&&(t.stopPropagation(),t.preventDefault(),this.activeTool.cancel(),this.activeTool=null),this._manipulatorState.handleInputEvent(e,this._manipulatorStateEventArgs),o||null==this.activeTool||this.activeTool.handleInputEventAfter(e),this._manipulatorState.handleHoverEvent(e,this.tools),"pointer-move"===t.type&&(this._manipulatorState.hasFocusedManipulators||this.activeTool)&&(this._interacting=!0,this._startInteractingTimeout())}_refreshToolWatchers(){this.removeHandles(_);for(const t of this.tools){if(t instanceof o){const o=n(()=>[t.cursor,t.visible,t.editable],()=>{m(t)||this._manipulatorState.clearPointers(t,this._manipulatorStateEventArgs)});this.addHandles(o,_)}t.manipulators&&this.addHandles([t.manipulators.on("after-remove",o=>{this._manipulatorState.clearPointers(t,this._manipulatorStateEventArgs,!0,o.item.manipulator)}),t.manipulators.on("change",()=>{this._manipulatorState.updateHoveredStateFromKnownPointers(this.tools)})],_)}this._manipulatorState.updateHoveredStateFromKnownPointers(this.tools)}_updateToolEditableFlag(t){t.setEditableFlag?.(1,null==this.activeTool||t===this.activeTool)}_removeIncompleteTools(t){this.tools.filter(o=>(null==t||o!==t)&&!o.created&&o.removeIncompleteOnCancel).forEach(t=>{this.tools.remove(t)})}get test(){}};t([r({constructOnly:!0,nonNullable:!0})],f.prototype,"view",void 0),t([r({value:null})],f.prototype,"activeTool",null),t([r({readOnly:!0,type:i})],f.prototype,"tools",void 0),t([r()],f.prototype,"cursor",null),t([r({readOnly:!0})],f.prototype,"updating",null),t([r()],f.prototype,"_interacting",void 0),t([r({readOnly:!0})],f.prototype,"interacting",null),f=t([l("esri.views.ToolViewManager")],f);export{f as ToolViewManager,T as interactingTimeout};
