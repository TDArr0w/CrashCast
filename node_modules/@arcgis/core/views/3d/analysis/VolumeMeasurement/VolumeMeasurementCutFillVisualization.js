/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../../Color.js";import"../../../../intl.js";import{volumeMeasurementConfiguration as i}from"../../../../analysis/VolumeMeasurement/volumeMeasurementConfiguration.js";import s from"../../../../core/Accessor.js";import{equals as o}from"../../../../core/arrayUtils.js";import{cyclicalPI as r}from"../../../../core/Cyclical.js";import{destroyMaybe as l}from"../../../../core/maybe.js";import{formatDecimal as n}from"../../../../core/quantityFormatUtils.js";import{watch as a,initial as c}from"../../../../core/reactiveUtils.js";import{adaptiveVolumeUnit as u}from"../../../../core/unitUtils.js";import{property as m}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import{subclass as d}from"../../../../core/accessorSupport/decorators/subclass.js";import{e as h}from"../../../../chunks/earcut.js";import{create as p}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{j as g,n as y,e as _,i as f,f as v}from"../../../../chunks/vec32.js";import{create as j,fromValues as b}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{computeTranslationToOriginAndRotation as L}from"../../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{newDoubleArray as C}from"../../../../geometry/support/DoubleArray.js";import{newIndexArray as w}from"../../../../geometry/support/Indices.js";import{angleAroundAxis as G}from"../../../../geometry/support/vector.js";import{t as P}from"../../../../chunks/vec3.js";import V from"../../../../symbols/support/ElevationInfo.js";import{LabelVisualElement as R}from"../../interactive/visualElements/LabelVisualElement.js";import{LineVisualElement as F}from"../../interactive/visualElements/LineVisualElement.js";import{OutlineVisualElement as A}from"../../interactive/visualElements/OutlineVisualElement.js";import{EuclideanSegment as O}from"../../interactive/visualElements/support/Segment.js";import{ElevationContext as x}from"../../layers/graphics/ElevationContext.js";import{extrudePolygon as D}from"../../layers/graphics/Graphics3DExtrudeSymbolLayer.js";import{geometryToRenderInfo as M}from"../../support/renderInfoUtils/polygon.js";import{CutFillColor as S,VolumeGeometry as U}from"../../webgl-engine/lib/CutFillColor.js";import{createStipplePatternSimple as E}from"../../webgl-engine/materials/lineStippleUtils.js";import{onLocaleChange as B}from"../../../../intl/locale.js";import{fetchMessageBundle as N}from"../../../../intl/messages.js";import{substitute as H}from"../../../../intl/substitute.js";let T=class extends s{get visible(){return this.analysisViewData.visible&&null!=this.analysisViewData.elevationAlignedGeometry&&null!=this.analysisViewData.targetGeometry}get updating(){return this.loadingMessages}get hasUnsupportedError(){const{error:e}=this.analysisViewData;return!!e&&["unsupported-coordinate-system","unsupported-layer-transparency"].includes(e.name)}constructor(e){super(e),this.unitsMessages=null,this.messages=null,this.loadingMessages=!0,this._elevationContext=x.fromElevationInfo(new V({mode:"absolute-height"})),this._extrusionHeight=i.targetElevationRange,this._projectionLines=[]}initialize(){const{view:e}=this,s={view:e,isDecoration:!0},o=i,r={...s,width:o.geometryOutlineWidth};this._elevationAlignedGeometry=new A({...r,isDraped:!0,color:t.toUnitRGBA(o.geometryOutlineColor)}),this._targetGeometry=new A(r);const l={...s,attached:!0,width:o.projectionLineWidth,renderOccluded:4,polygonOffset:!0},n={...l,stipplePattern:E(o.projectionLineStippleSize)},u=t.toUnitRGBA(o.cutProjectionLineColor),m=t.toUnitRGBA(o.fillProjectionLineColor);this._cutProjectionLines=new F({...l,color:u}),this._occludedCutProjectionLines=new F({...n,color:u}),this._fillProjectionLines=new F({...l,color:m}),this._occludedFillProjectionLines=new F({...n,color:m});const d={...s,attached:!0};this._cutVolumeLabel=new R(d),this._fillVolumeLabel=new R(d),this._cutFillRenderNode=new S({view:e,cutColor:o.cutColor,fillColor:o.fillColor,borderColor:o.geometryOutlineColor}),this.addHandles([a(()=>({elevationAlignedGeometry:this.analysisViewData.elevationAlignedGeometry,targetGeometry:this.analysisViewData.targetGeometry}),({elevationAlignedGeometry:e,targetGeometry:t})=>{this._elevationAlignedGeometry.geometry=e,this._targetGeometry.geometry=t},c),a(()=>({interactive:this.analysisViewData.interactive,measureType:this.analysis.measureType,visible:this.visible}),({visible:e,interactive:t,measureType:i})=>{this._elevationAlignedGeometry.visible=e&&!t,this._targetGeometry.visible=e&&"cut-fill"===i},c),a(()=>({elevationAlignedGeometry:this.analysisViewData.elevationAlignedGeometry,targetGeometry:this.analysisViewData.targetGeometry,visible:this.visible}),({elevationAlignedGeometry:e,targetGeometry:t,visible:i})=>this._updateProjectionLines(e,t,i),c),a(()=>({interactive:this.analysisViewData.interactive,accentColor:this.view.effectiveTheme.accentColor,hasResult:!!this.analysisViewData.result}),({interactive:e,accentColor:t,hasResult:i})=>{this._updateColors(e,t,i)},c),a(()=>this.analysisViewData.targetGeometry,()=>this._updateCutFillGeometry(),c),a(()=>this.visible&&!this.hasUnsupportedError,e=>this._updateCutFillVisibility(e),c),a(()=>{const{messages:e,unitsMessages:t,visible:i,analysisViewData:s}=this;return{labelAnchors:s.labelAnchors,effectiveDisplayUnits:s.effectiveDisplayUnits,messages:e,unitsMessages:t,result:s.result,visible:i&&!!s.result}},e=>this._updateLabels(e)),a(()=>this.view.state.camera,e=>this._updateProjectionLineOcclusion(e),c),B(()=>this._updateMessageBundle())]),this._updateMessageBundle()}destroy(){this._elevationAlignedGeometry=l(this._elevationAlignedGeometry),this._targetGeometry=l(this._targetGeometry),this._cutProjectionLines=l(this._cutProjectionLines),this._occludedCutProjectionLines=l(this._occludedCutProjectionLines),this._fillProjectionLines=l(this._fillProjectionLines),this._occludedFillProjectionLines=l(this._occludedFillProjectionLines),this._cutVolumeLabel=l(this._cutVolumeLabel),this._fillVolumeLabel=l(this._fillVolumeLabel),this._cutFillRenderNode.destroy()}_updateProjectionLines(e,t,i){if(this._cutProjectionLines.visible=i,this._occludedCutProjectionLines.visible=i,this._fillProjectionLines.visible=i,this._occludedFillProjectionLines.visible=i,!e||!t)return;const{renderCoordsHelper:s}=this.view,r=[],l=e.spatialReference,n=e.rings[0],a=n.length>1&&o(n[0],n[n.length-1]),c=n.length-(a?1:0);for(let o=0;o<c;++o){const e=n[o],i=g(j(),e[0],e[1],e[2]);s.toRenderCoords(i,l,i);const a=t.rings[0][o],c=g(j(),a[0],a[1],a[2]);s.toRenderCoords(c,l,c);const u=new O(i,c);r.push(u)}e.isClockwise(n)||r.reverse();const u=[],m=[],d=[],h=[],p=[],y=this.view.state.camera;for(let o=0;o<r.length;++o){const i=r[o],s=r[0===o?r.length-1:o-1],l=r[o===r.length-1?0:o+1],n=e.rings[0][o],a=t.rings[0][o],c=n[2]>a[2],g=new k(i,s,l,c);u.push(g),g.updateOccluded(y);const _=g.isOccluded;c?(_?d:m).push(i):(_?p:h).push(i)}this._projectionLines=u,this._cutProjectionLines.setGeometryFromSegments(m),this._occludedCutProjectionLines.setGeometryFromSegments(d),this._fillProjectionLines.setGeometryFromSegments(h),this._occludedFillProjectionLines.setGeometryFromSegments(p)}_updateProjectionLineOcclusion(e){const t=[],i=[],s=[],o=[];let r=!1,l=!1;for(const n of this._projectionLines){n.updateOccluded(e)&&(r||=n.isCut,l||=!n.isCut);const a=n.isOccluded;(n.isCut?a?i:t:a?o:s).push(n.segment)}l&&(this._fillProjectionLines.setGeometryFromSegments(s),this._occludedFillProjectionLines.setGeometryFromSegments(o)),r&&(this._cutProjectionLines.setGeometryFromSegments(t),this._occludedCutProjectionLines.setGeometryFromSegments(i))}_updateColors(e,s,o){const{geometryOutlineColor:r,cutColor:l,fillColor:n,cutColorMuted:a,fillColorMuted:c,cutProjectionLineColor:u,fillProjectionLineColor:m}=i;if(this._cutFillRenderNode.cutColor=o?l:a,this._cutFillRenderNode.fillColor=o?n:c,e){const e=t.toUnitRGBA(s);this._targetGeometry.color=e,this._cutProjectionLines.color=e,this._occludedCutProjectionLines.color=e,this._fillProjectionLines.color=e,this._occludedFillProjectionLines.color=e,this._cutFillRenderNode.borderColor=s}else{this._targetGeometry.color=t.toUnitRGBA(r);const e=t.toUnitRGBA(o?u:a);this._cutProjectionLines.color=e,this._occludedCutProjectionLines.color=e;const i=t.toUnitRGBA(o?m:c);this._fillProjectionLines.color=i,this._occludedFillProjectionLines.color=i,this._cutFillRenderNode.borderColor=r}}_updateLabels(e){const{labelDistance:t}=i,{effectiveDisplayUnits:s,labelAnchors:o,messages:r,unitsMessages:l,result:n,visible:a}=e;if(this._cutVolumeLabel.visible=a,this._fillVolumeLabel.visible=a,this._cutVolumeLabel.geometry=o.cut?{type:"point",point:o.cut,callout:{distance:t,offset:0}}:null,this._fillVolumeLabel.geometry=o.fill?{type:"point",point:o.fill,callout:{distance:-t,offset:0}}:null,null==n||null==r||null==l)return this._cutVolumeLabel.text="-",void(this._fillVolumeLabel.text="-");const c=s.volume,u=H(r.labels.cut,{volume:I(l,n.cutVolume,c)}),m=H(r.labels.fill,{volume:I(l,n.fillVolume,c)});this._cutVolumeLabel.text=u,this._fillVolumeLabel.text=m}_updateCutFillVisibility(e){e?this._cutFillRenderNode.enable():this._cutFillRenderNode.disable()}_updateCutFillGeometry(){const{renderCoordsHelper:e}=this.view,{targetGeometry:t}=this.analysisViewData;if(!t?.extent)return;const{center:i}=t.extent,s=b(i.x,i.y,0),o=j();e.toRenderCoords(s,t.spatialReference,o);const r=this._getExtrudedVolumes(t,this._extrusionHeight,s),l=this._getExtrudedVolumes(t,-this._extrusionHeight,s);this._cutFillRenderNode.updateGeometries(r,l,o)}_getExtrudedVolumes(e,t,i){const{renderCoordsHelper:s,spatialReference:o,elevationProvider:r}=this.view,l=j(),n=1===s.viewingMode;n||s.worldUpAtPosition([0,0,0],l);const a=M(e,r,s,this._elevationContext),{polygons:c,mapPositions:u,position:m}=a,d=c[0],g=d.count,y=h(d.mapPositions,d.holeIndices,3),_=y.length,f=6*g,v=w(f+_),b=w(_),G=C(3*f),V=C(3*f);D(m,u,y,d,G,null,V,null,v,b,t,l,n);const R=p(),F=p();return L(o,i,R,s.spatialReference),F[12]=-R[12],F[13]=-R[13],F[14]=-R[14],P(G,G,F),new U(G,b,v,V)}async _updateMessageBundle(){this.loadingMessages=!0;try{this.unitsMessages=await N("esri/core/t9n/Units"),this.messages=await N("esri/views/3d/analysis/VolumeMeasurement/t9n/VolumeMeasurementAnalysis")}finally{this.loadingMessages=!1}}};function I(e,t,s){if(!t||!e)return null;const o=u(t.value,t.unit,s),r=i.labelPrecisions[o];return n(e,t,o,r)}e([m({constructOnly:!0})],T.prototype,"view",void 0),e([m({constructOnly:!0})],T.prototype,"analysis",void 0),e([m({constructOnly:!0})],T.prototype,"analysisViewData",void 0),e([m()],T.prototype,"unitsMessages",void 0),e([m()],T.prototype,"messages",void 0),e([m()],T.prototype,"loadingMessages",void 0),e([m({readOnly:!0})],T.prototype,"visible",null),e([m()],T.prototype,"updating",null),e([m()],T.prototype,"hasUnsupportedError",null),T=e([d("esri.views.3d.analysis.VolumeMeasurement.VolumeMeasurementCutFillVisualization")],T);class k{constructor(e,t,i,s){this.segment=e,this.previous=t,this.next=i,this.isCut=s,this._isOccluded=!1,this._n1=j(),this._n2=j();const o=y(z,_(z,e.endRenderSpace,e.startRenderSpace));y(this._n1,f(this._n1,o,y(W,_(W,t.startRenderSpace,e.startRenderSpace)))),y(this._n2,f(this._n2,o,y(W,_(W,e.startRenderSpace,i.startRenderSpace)))),this._isConvex=r.normalize(G(this._n1,this._n2,o))<0}get isOccluded(){return this._isOccluded}updateOccluded(e){_(z,this.segment.startRenderSpace,e.eye);const t=v(this._n1,z)<0,i=v(this._n2,z)<0,s=this._isOccluded;return this._isOccluded=this._isConvex?t&&i:t||i,this._isOccluded!==s}}const z=j(),W=j();export{T as VolumeMeasurementCutFillVisualization};
