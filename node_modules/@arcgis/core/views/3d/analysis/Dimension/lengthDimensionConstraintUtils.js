/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{q as e,h as n,f as t,e as i,m as o}from"../../../../chunks/vec32.js";import r from"../../../../geometry/Point.js";import{sv3d as a}from"../../../../geometry/support/vectorStacks.js";import{automaticHeadingFromCamera as s}from"./lengthDimensionManipulatorUtils.js";import{isGeodesicDimension as l,directUp as d,directStartToEnd as c}from"./lengthDimensionUtils.js";import{constraintThresholdPx as u}from"./settings.js";function m(e,n){return{enabled:n.effectiveFeatureEnabled,elevationAlignedStartPoint:e.elevationAlignedStartPoint,elevationAlignedEndPoint:e.elevationAlignedEndPoint,geometry:e.geometry}}function P(r,s){if(l(r))return 2;if(!r.enabled)return null;const{geometry:m}=r;if(null==m||e(m.directSegment.startRenderSpace,m.directSegment.endRenderSpace))return null;const{camera:P}=s.state,p=d(a.get(),m,s.renderCoordsHelper),f=c(a.get(),m),g=n(a.get(),p,t(f,p)),S=i(a.get(),f,g),v=o(S),y=o(g),{startRenderSpace:A,endRenderSpace:R}=m.directSegment,x=Math.max(P.computeScreenPixelSizeAt(A)*u,P.computeScreenPixelSizeAt(R)*u)**2;return v<x?1:y<x?0:null}function p(e,n,{constraint:t,view:i}){const{unconstrainedGeometry:o}=e;if(null==o)return;const{renderCoordsHelper:a,spatialReference:s}=i,{startRenderSpace:l,endRenderSpace:d}=o.directSegment,c=a.fromRenderCoords(l,new r({spatialReference:s})),u=a.fromRenderCoords(d,new r({spatialReference:s}));let m;m="start"===n?{startPoint:c}:{endPoint:u},f(e,m,{constraint:t,elevationAlignedStartPoint:e.elevationAlignedStartPoint,elevationAlignedEndPoint:e.elevationAlignedEndPoint,unconstrainedGeometry:o,view:i})}function f(e,n,t){const{constraint:i,elevationAlignedStartPoint:o,elevationAlignedEndPoint:r,unconstrainedGeometry:a,view:l}=t,{dimension:d,previousConstraint:c,preConstraintProperties:u}=e;if(null==o||null==r)return;const m=()=>{"startPoint"in n?d.startPoint=n.startPoint:"endPoint"in n&&(d.endPoint=n.endPoint)};if(null==i)m(),null!=c&&null!=u&&(d.measureType=u.measureType,d.orientation=u.orientation);else switch(d.measureType="direct",i){case 0:if(i!==c&&(d.orientation=0),"startPoint"in n){const e=n.startPoint;null!=e&&(e.z=r.z),d.startPoint=e}else if("endPoint"in n){const e=n.endPoint;null!=e&&(e.z=o.z),d.endPoint=e}break;case 1:if(i!==c&&(d.orientation=s(a,l)),"startPoint"in n){const e=n.startPoint;null!=e&&(e.x=r.x,e.y=r.y),d.startPoint=e}else if("endPoint"in n){const e=n.endPoint;null!=e&&(e.x=o.x,e.y=o.y),d.endPoint=e}break;case 2:i!==c&&null!=u&&(d.orientation=u.orientation),m()}e.previousConstraint=i,e.unconstrainedGeometry=a}export{f as applyConstraint,P as computeConstraint,m as constraintDependencies,p as reapplyConstraint};
