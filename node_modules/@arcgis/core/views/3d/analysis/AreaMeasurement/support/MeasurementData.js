/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{deg2rad as e}from"../../../../../core/mathUtils.js";import{createLength as t,toUnit as s,createArea as i}from"../../../../../core/quantityUtils.js";import{lengthUnitFromSpatialReference as n,areaUnitFromSpatialReference as o}from"../../../../../core/unitUtils.js";import{set as r,distance as h}from"../../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{k as l,d,i as g,u as c,e as p,f as m,h as u,g as _,n as f}from"../../../../../chunks/vec32.js";import{create as S}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as L}from"../../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{getReferenceEllipsoid as M}from"../../../../../geometry/ellipsoidUtils.js";import{canProjectWithoutEngine as C}from"../../../../../geometry/projectionUtils.js";import{getSphericalPCPF as P}from"../../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectDirection as R}from"../../../../../geometry/projection/projectDirection.js";import{projectPointToVector as U}from"../../../../../geometry/projection/projectPointToVector.js";import{projectVectorToVector as j}from"../../../../../geometry/projection/projectVectorToVector.js";import{compactIndices as A}from"../../../../../geometry/support/Indices.js";import{segmentIntersects as v}from"../../../../../geometry/support/intersectsBase.js";import{c as I}from"../../../../../chunks/sphere.js";import{areaPoints2d as V}from"../../../../../geometry/support/triangle.js";import{bestFitPlane as w,fitHemisphere as W,triangleAreaGeodesic as F,planePointDistance as y,boundingSphere as G}from"../../support/measurementUtils.js";import{getElevationAtPoint as T}from"../../../support/ElevationProvider.js";import{midpoint3d as x,makeOrthonormal as z,tangentFrame as q}from"../../../support/mathUtils.js";import{triangulate as b}from"../../../../support/euclideanAreaMeasurementUtils.js";import{euclideanDistanceBetweenPoints as E}from"../../../../support/euclideanLengthMeasurementUtils.js";import{supportsGeodesicMeasurement as D}from"../../../../support/geodesicMeasurementUtils.js";import{computeEuclideanMeasurementSR as k}from"../../../../support/measurementUtils.js";class B{get numVertices(){return this._length}get hasStagedVertex(){return null!=this._lastCursorPoint}constructor(e,t,s){this._sceneView=e,this._geodesicAreaMeasurementUtils=t,this._geodesicLengthMeasurementUtils=s,this.validMeasurement=!1,this.positionsWorld=[],this.positionsRender=[],this.positionsFittedWorld=[],this.positionsFittedRender=[],this.positionsGeodesic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=S(),this.areaCentroidRenderCoords=S(),this.geodesicAreaCentroidRenderCoords=S(),this.fittingMode=null,this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=S(),this._planeWorldCoords=L(),this._worldUp=S(),this._worldTangent=S(),this._frame=[S(),S(),S()],this._lastPathVersion=-1,this._lastCursorPoint=null,this._mode=null,this._tempU=S(),this._tempV=S(),this._tempVec3=S(),this._tempSphere=I();const i=k(e.spatialReference);this._measurementSR=i,this._lengthMeasurementUnit=n(i)??"meters",this._areaMeasurementUnit=o(i)??"square-meters"}update(e,t,s,i,n,o){const r=this._lastPathVersion===e.version,h=t?t.equals(this._lastCursorPoint):null==this._lastCursorPoint,a=this._mode===n;return!(r&&!o&&a&&h)&&(this._lastPathVersion=e.version,this._lastCursorPoint=t,this._updateCursorSegmentLength(e,t),this._update(e,t,s,i,n),!0)}_update(e,s,i,n,o){const r=this._sceneView.renderSpatialReference,h=this._measurementSR,a=i.spatialReference;let l=e.numVertices;const d=!(null==s||s.equals(e.lastPoint)||l>2&&s.equals(e.firstPoint)||e.polygonIsClosed);d&&(l+=1);const g=!e.polygonIsClosed&&l>2,c=e.polygonIsClosed||g;this._resize(l);const p=P(a),m=null!=a&&D(a)?a:null,u=null!=m&&C(a,p),{positionsGeodesic:_,positionsWorld:S,positionsRender:L,positionsSpherical:M}=this,R=(e,t)=>{H(i.elevationProvider,e),U(e,S[t],h),U(e,L[t],r),u&&(U(e,_[t],m),U(e,M[t],p),f(M[t],M[t]))};e.forEachVertexPosition((e,t)=>R(e,t)),d&&R(s,l-1);const j=this._updatePathLengths(c);if(this.pathLength=this._length>1?t(j,this._lengthMeasurementUnit):null,u){const e=this._updateGeodesicPathLengths(c,m);this.geodesicPathLength=null!=e&&this._length>1?e:null}else this.geodesicPathLength=null;if(this._updateMode(o),!c)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),void(this.validMeasurement=!1);this._updateAreaAndPerimeterLength(i,r,h,n),u&&this._updateGeodesicArea(i,m),this.validMeasurement=!0}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,positionsRender:this.positionsRender,positionsFittedWorld:this.positionsFittedWorld,positionsFittedRender:this.positionsFittedRender,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorld.length=e,this.positionsRender.length=e,this.positionsFittedWorld.length=e,this.positionsFittedRender.length=e,this.positionsGeodesic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorld.push(S()),this.positionsRender.push(S()),this.positionsFittedWorld.push(a()),this.positionsFittedRender.push(S()),this.positionsGeodesic.push(S()),this.positionsSpherical.push(S()),this.positionsStereographic.push(a()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorld,s=this.pathSegmentLengths;let i=0;const n=this._length;for(let o=0;o<n;++o){const r=s[o]=l(t[o],t[(o+1)%n]);(o<n-1||e)&&(i+=r)}return i}_updateGeodesicPathLengths(e,i){const n=this.positionsGeodesic,o=this.geodesicPathSegmentLengths;let r=0;const h=this._length;for(let t=0;t<h;++t){const a=this._geodesicLengthMeasurementUtils.geodesicDistance(n[t],n[(t+1)%h],i);if(null==a)return null;const l=s(a,"meters").value,d=o[t]=l;(t<h-1||e)&&(r+=d)}return t(r,"meters")}_updateAreaAndPerimeterLength(e,t,s,i){const n=e.renderCoordsHelper,o=this.positionsWorld,h=this.positionsRender,a=this.positionsFittedWorld,l=this.positionsFittedRender,f=this._planeWorldCoords,S=this._centroidRenderCoords;x(h,S),n.worldUpAtPosition(S,this._worldUp),n.worldBasisAtPosition(S,0,this._worldTangent),R(S,this._worldUp,t,this._worldUp,s),R(S,this._worldTangent,t,this._worldTangent,s),o.length>2&&w(o,f),this.fittingMode=this._selectFittingMode(f,o,this._worldUp,i);let L=0;if("horizontal"===this.fittingMode){let e=-1/0;h.forEach((t,s)=>{const i=n.getAltitude(h[s]);i>e&&(e=i,L=s)})}const M=o[L];let C=f,P=this._worldTangent;"horizontal"===this.fittingMode?C=this._worldUp:"vertical"===this.fittingMode&&(C=this._tempVec3,P=this._worldUp,z(f,this._worldUp,C)),d(this._frame[2],C),z(P,C,this._frame[0]),g(this._frame[1],this._frame[0],this._frame[2]),c(this._frame[1],this._frame[1]);const U=this._tempVec3,A=this._tempU,v=this._tempV;for(let d=0;d<this._length;++d){const e=a[d],i=l[d];p(U,o[d],M),r(e,m(this._frame[0],U),m(this._frame[1],U)),u(A,this._frame[0],e[0]),u(v,this._frame[1],e[1]),_(U,A,v),_(U,U,M),j(U,s,i,t)}this.perimeterLength=this._length>0?this._updatePerimeterLengths():null,x(l,this.areaCentroidRenderCoords),j(this.areaCentroidRenderCoords,t,this.areaCentroidWorldCoords,s),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?this._computeArea():null}_updateGeodesicArea(e,t){const{renderCoordsHelper:s,spatialReference:i}=e,{positionsSpherical:n,positionsStereographic:o}=this,h=this._tempVec3,a=W(n,h);if(!a)return void(this.geodesicArea=null);const l=this._tempU,d=this._tempV;q(h,l,d);for(let g=0;g<this._length;++g){const e=m(n[g],l),t=m(n[g],d),s=m(n[g],h);r(o[g],e/s,t/s)}u(h,h,M(i).radius),s.toRenderCoords(h,P(i),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=a&&0===this.geodesicIntersectingSegments.size?this._computeGeodesicArea(t):null}_updatePerimeterLengths(){const e=this.positionsFittedWorld,s=this.perimeterSegmentLengths;let i=0;for(let t=0;t<this._length;++t){i+=s[t]=h(e[t],e[(t+1)%this._length])}return t(i,this._lengthMeasurementUnit)}_updateIntersectingSegments(){const e=this.positionsFittedWorld,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const n=e[s],o=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];v(n,o,r,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsFittedWorld,t=this.triangleIndices=A(b(e));let s=0;for(let i=0;i<t.length;i+=3)s+=V(e[t[i]],e[t[i+1]],e[t[i+2]]);return i(s,this._areaMeasurementUnit)}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const n=e[s],o=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];v(n,o,r,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(e){const t=this.positionsGeodesic,n=this.positionsStereographic,o=this.geodesicTriangleIndices=A(b(n));let r=0;for(let i=0;i<o.length;i+=3){const n=F(t[o[i]],t[o[i+1]],t[o[i+2]],e,this._geodesicAreaMeasurementUtils);if(null==n)return null;r+=s(n,"square-meters").value}return i(r,"square-meters")}_selectFittingMode(t,s,i,n){const o=s.map(e=>Math.abs(y(t,e))).reduce((e,t)=>Math.max(e,t),0);G(s,this._tempSphere);const r=o/(2*this._tempSphere[3]),h=r<n.maxRelativeErrorCoplanar,a=r<n.maxRelativeErrorAlmostCoplanar;let l="horizontal";if(h)l="oblique";else if(a){l=Math.abs(m(i,t))>Math.cos(e(n.verticalAngleThreshold))?"horizontal":"vertical"}return l}_updateCursorSegmentLength(e,t){const s=e.lastPoint;e.isValidPolygon||null==s||null==t?(this.geodesicStagedSegmentLength=null,this.stagedSegmentLength=null):(this.geodesicStagedSegmentLength=this._geodesicLengthMeasurementUtils.geodesicDistanceBetweenPoints(s,t),this.stagedSegmentLength=E(s,t)?.direct)}_updateMode(e){if(0===e){this.actualMeasurementMode="euclidean";let e=0;null!=this.geodesicPathLength&&(e+=this.geodesicPathLength.value),e>Z&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=1===e?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=e}}function H(e,t){t.hasZ||(t.z=T(e,t,"ground")??0)}const Z=1e5;export{B as MeasurementDataManager};
