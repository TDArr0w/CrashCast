/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{acosClamped as e,lerp as t,clamp as i}from"../../../core/mathUtils.js";import{getMetersPerUnitForSR as r}from"../../../core/unitUtils.js";import{b as s,n,h as a,f as o,e as m}from"../../../chunks/vec32.js";import{create as h}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as c}from"../../../geometry/ellipsoidUtils.js";import l from"../../../geometry/Extent.js";import{create as f,fromValues as x}from"../../../geometry/support/ray.js";import{c as p,b as u,i as M}from"../../../chunks/sphere.js";import{computeInnerAltitudeFade as d}from"../environment/atmosphereUtils.js";import{DepthRange as _}from"../webgl-engine/lib/DepthRange.js";function y(e,t,i){return 1===e?new E(t,i):new v(t,i)}class v{constructor(e,t){this._elevationProvider=e,this._referenceEllipsoid=c(t),this._unitInMeters=r(t,this._referenceEllipsoid.metersPerDegree)}compute(e,r,s,a){const{eye:h,center:c}=e;let f=h[2]*this._unitInMeters;const x=f,p=f-a,u=this._elevationProvider?.visibleElevationBounds;u&&(f=p>=0?x-this._unitInMeters*u.min:this._unitInMeters*u.max-x),r??=new l({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0});const M={x:r.xmax-r.xmin,y:r.ymax-r.ymin,z:4*Math.max(r.xmax-r.xmin,r.ymax-r.ymin)},d=Math.max(M.x,M.y,M.z);m(q,c,h),k[0]=q[0]>0?r.xmax:r.xmin,k[1]=q[1]>0?r.ymax:r.ymin,k[2]=q[2]>0?d/2:-d/2,m(k,k,h),n(q,q);const _=1.1*o(k,q)*this._unitInMeters,y=Math.sqrt(f*(f+2*this._referenceEllipsoid.radius)),v=Math.max(r.xmax-r.xmin,r.ymax-r.ymin),E=v*U*this._unitInMeters,I=v*z*this._unitInMeters,b=i((f-I)/(E-I),0,1)**3,w=Math.min(t(y,_,b),y)*Math.max(Math.log(Math.abs(p)),1);return g(Math.min(w,Math.max(34064e4,d))/this._unitInMeters,j,this._unitInMeters,B)}}class E{constructor(e,t){this._elevationProvider=e,this._referenceEllipsoid=c(t)}compute(r,h,c,l){const{eye:f}=r,p=s(f),y=p-this._referenceEllipsoid.radius,v=this._referenceEllipsoid.radius+Math.min(0,l),E=Math.abs(y-l),U=Math.max(E,Math.abs(y)),z=this._elevationProvider?.visibleElevationBounds.max??0,H=d(U),R=Math.sqrt(U*(U+2*v)),Y=p+this._referenceEllipsoid.radius,A=1.2*t(R,Y,H),C=(Math.log(U)-I)/(b-I);g(A,i(j-C*(j-w),w,j),1,B);const G=this._referenceEllipsoid.radius+z,J=this._referenceEllipsoid.radius+this._referenceEllipsoid.atmosphereHeight,K=Math.max(G,J),L=p-K;if(H>0&&L>P){const i=n(k,a(k,r.eye,-1)),h=n(q,r.viewForward),l=e(o(i,h)),f=.5*r.fovY,p=Math.cos(f);let d=_.Infinite.near;if(l<=f)d=L*p;else{const e=n(k,r.viewUp),t=Math.tan(f),i=a(k,e,t),o=n(k,m(k,h,i)),c=x(r.eye,o,F),l=u(D,K);if(M(l,c,k)){const e=m(k,k,r.eye);d=s(e)*p}}const y=.99*Math.min(c.near,d);if(y<_.Infinite.near&&y>B.near){const e=t(B.near,y,H);B.near=e}}return B}}function g(e,t,i,r){const s=P/i,n=e/t;return n>s?(r.far=e,r.near=n):(r.near=s,r.far=r.near*t),r}const I=7.983,b=16.994,j=2e4,w=100,P=2,U=.001,z=1e-4,k=h(),q=h(),B={near:0,far:0},D=p(),F=f();export{y as createNearFarHeuristic,P as minNearDistanceInMeters};
