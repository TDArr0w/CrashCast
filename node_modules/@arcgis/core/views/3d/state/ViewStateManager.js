/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../Camera.js";import i from"../../../Viewpoint.js";import r from"../../../core/Accessor.js";import a from"../../../core/Logger.js";import{destroyMaybe as s}from"../../../core/maybe.js";import{on as n,watch as o,sync as h,when as l}from"../../../core/reactiveUtils.js";import{addFrameTask as c}from"../../../core/scheduling.js";import{createScreenPoint as p}from"../../../core/screenUtils.js";import{property as m}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/RandomLCG.js";import{subclass as d}from"../../../core/accessorSupport/decorators/subclass.js";import{s as v}from"../../../chunks/vec32.js";import{fromArray as u}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{s as w}from"../../../chunks/vec42.js";import{create as g}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import y from"../../../geometry/Extent.js";import _ from"../../../geometry/Point.js";import f from"../../../geometry/Polygon.js";import{isLoadedOrLoadFor as C,requiresLoad as x}from"../../../geometry/projectionUtils.js";import{fromRenderCamera as R,toRenderCamera as P}from"../webgl.js";import{applyAll as S}from"../camera/constraintUtils.js";import{cameraOnContentAlongViewDirection as O,surfaceElevationBelowRenderLocation as b}from"../camera/intersectionUtils.js";import{ConstraintsManager as T}from"./ConstraintsManager.js";import{Frustum as j}from"./Frustum.js";import{GoToOperation as z}from"./GoToOperation.js";import{SurfaceCollisionCorrectionController as M}from"./controllers/SurfaceCollisionCorrectionController.js";import{toArea as I,toExtent as H,applyTiltAdjustToScale as L,scaleToZoom as B,fromExtentSync as E,getObserverForPointAtDistanceSync as V,viewScaleToCameraDistance as A,zoomToScale as U}from"../support/cameraUtils.js";import{fromCamera as k,toCameraSync as D}from"../support/viewpointUtils.js";import F from"../webgl/RenderCamera.js";import{PropertiesPool as G}from"../../support/PropertiesPool.js";import{ensureAttachmentMaxSize as N}from"../../webgl/FramebufferObject.js";let q=class extends r{constructor(e){super(e),this.ready=!1,this._windowDevicePixelRatio=1,this._devicePixelRatioOverride=null,this._idleTimeout=te,this.test={viewStateManager:this,contentCameraResetState:new Map,setDevicePixelRatio:e=>this._devicePixelRatioOverride=e,getDevicePixelRatioOverride:()=>this._devicePixelRatioOverride,renderState:null,get maximumPixelRatio(){return this.viewStateManager.view.qualitySettings.maximumPixelRatio},get updatingIgnoreRenderState(){return null!=this.renderState},get idleTimeoutEnabled(){return this.viewStateManager._idleTimeout>0},set idleTimeoutEnabled(e){this.viewStateManager._idleTimeout=e?te:0}},this._propertiesPool=new G({frustum:()=>new j(null)},this),this._cameraSetByUser=!1,this._gotoOperation=null,this._cameraChangeTime=0,this._tmpCanvasSize=new W}initialize(){this._cameraChangeTime=performance.now(),this.addHandles([n(()=>this.view.state.events,"before-camera-change",({camera:e})=>e&&this._updateElevation(e)),o(()=>this.view.state?.camera,(e,t)=>this._cameraChangedHandler(e,t),h)]),l(()=>this.view.state?.camera,e=>this._updateElevation(e),{once:!0,sync:!0}),this.addHandles([c({prepare:()=>this._prepareFrame()}),o(()=>this.view.state.cameraController,()=>{this._cameraSetByUser=!0,this.removeHandles($)}),n(()=>this.view.state.events,"camera-projection-changed",()=>this.notifyChange("scale"))])}destroy(){this.exit(),this._propertiesPool=s(this._propertiesPool)}get camera(){const e=this._get("camera");if(!this.ready)return e;const t=R(this.view,this.view.state.camera,Q);return t&&e&&t.equals(e)?e:t.clone()}set camera(e){if(this._updatePropertyBeforeReady("camera",e))return;this.view.elevationProvider.enableCache(!0);const t=P(this.view,e);t?this.setStateCamera(t,{applyConstraints:!1})||a.getLogger(this).warnOnce("#camera=","There is a currently active camera controller that has priority."):a.getLogger(this).error("#camera=","Invalid camera",e),this.view.elevationProvider.enableCache(!1)}get contentCamera(){const e=this._get("contentCamera");if(!this.ready)return e;const t=R(this.view,this.view.state.contentCamera,Q);return t&&e&&t.equals(e)?e:t.clone()}set contentCamera(e){if(this._updatePropertyBeforeReady("contentCamera",e))return;const t=P(this.view,e);this.view.state.contentCamera=null!=t?t:null}installContentCameraReset(e){if(this.removeHandles(ee),this.test.contentCameraResetState.clear(),!this.view.state.fixedContentCamera)return!1;const t=this.zoom,i=this.view.state.camera.distance**2,r=u(this.view.state.camera.center),a=e.sticky?this.contentCamera.clone():null;return this.addHandles([o(()=>this.contentCamera,()=>{e.sticky||(this.removeHandles(ee),this.test.contentCameraResetState.clear())}),o(()=>this.zoom,e=>{void 0!==e&&void 0!==t&&(this.test.contentCameraResetState.set("view.zoom",Math.abs(e-t)/2),Math.abs(e-t)>2?this.contentCamera=null:this.view.state.fixedContentCamera||(this.contentCamera=a))}),o(()=>this.view.state.camera,e=>{const t=v(r,e.center);this.test.contentCameraResetState.set("camera.center",t/i),t>i?this.contentCamera=null:this.view.state.fixedContentCamera||(this.contentCamera=a)})],ee),!0}get center(){return this.ready?this.view.pointsOfInterest.centerOnContent.location:this._get("center")}set center(e){this._updatePropertyBeforeReady("center",e)||(e?this.isCompatible(e)?this.setStateCamera(this._centerToCamera(e),{applyConstraints:!0})?this.view.pointsOfInterest.centerOnContent.runTask():a.getLogger(this).error("#center=","Invalid center",e):a.getLogger(this).error("#center=","Center has an incompatible spatial reference (center: "+(e.spatialReference?e.spatialReference.wkid:"none")+", view: "+this.view.spatialReference?.wkid+")",e):a.getLogger(this).error("#center=","Center may not be null or undefined"))}get visibleArea(){if(!this.ready){const e=this._get("extent");return e?f.fromExtent(e):null}return I(this.view,this.view.pointsOfInterest.focus.renderLocation)}get extent(){if(!this.ready)return this._get("extent");const e=this.view,t=H(e,e.state.camera,e.pointsOfInterest.centerOnContent.renderLocation);return null!=t?t:this._get("extent")}set extent(e){this._updatePropertyBeforeReady("extent",e)||(e?this.isCompatible(e)?this.setStateCamera(this._extentToCamera(e),{applyConstraints:!0})||a.getLogger(this).error("#extent=","Invalid extent",e):a.getLogger(this).error("#extent=","Extent has an incompatible spatial reference (extent: "+(e.spatialReference?e.spatialReference.wkid:"none")+", view: "+this.view.spatialReference?.wkid+")",e):a.getLogger(this).error("#extent=","Extent may not be null or undefined"))}get frustum(){const e=this._propertiesPool.get("frustum");return e.renderCoordsHelper=this.view.renderCoordsHelper,e.update(this.view.state.camera),e}get constraintsManager(){return this._constraintsManager}get _initialViewpoint(){const e=this.view.map;return e&&"initialViewProperties"in e?e.initialViewProperties?.viewpoint:void 0}get hasInitialView(){return!!this._initialViewpoint}get scale(){if(!this.ready)return this._get("scale");const e=this.view.basemapTerrain.tilingScheme,t=this.view.pointsOfInterest.cameraOnSurface.scale;return e&&t?L(this.view,t,this.view.state.contentCamera,e):this._get("scale")}set scale(e){this._updatePropertyBeforeReady("scale",e)||this.setStateCamera(this._scaleToCamera(e),{applyConstraints:!0})||a.getLogger(this).error("#scale=","Invalid scale",e)}get padding(){if(!this.ready)return this._get("padding");const e=this.view.state.camera,t=e.padding,i=e.pixelRatio,r=this._get("padding"),a=Math.round(t[0]/i),s=Math.round(t[1]/i),n=Math.round(t[2]/i),o=Math.round(t[3]/i);return null!=r&&r.top===a&&r.right===s&&r.bottom===n&&r.left===o?r:{top:a,right:s,bottom:n,left:o}}set padding(e){this._updatePropertyBeforeReady("padding",e)||(this._paddingToArray(e,this.view.state.camera.pixelRatio,Y),this.view.state.updateCamera(e=>e.padding=Y))}_paddingToArray(e,t,i){e?w(i,e.top||0,e.right||0,e.bottom||0,e.left||0):w(i,0,0,0,0);for(let r=0;r<4;r++)i[r]=Math.round(i[r]*t)}get screenCenter(){const e=this.padding;return p((this.view.width-(e.left+e.right))/2+e.left,(this.view.height-(e.top+e.bottom))/2+e.top)}get viewpoint(){return this.ready?k(this.view,this.camera):this._get("viewpoint")}set viewpoint(e){if(!this._updatePropertyBeforeReady("viewpoint",e))if(e){if(!this.isCompatible(e)){const t=null!=e.camera?e.camera.position:e.targetGeometry,i=null!=t&&t.spatialReference;return void a.getLogger(this).error("#viewpoint=","Viewpoint has an incompatible spatial reference (viewpoint: "+(i?i.wkid:"none")+", view: "+this.view.spatialReference?.wkid+")",e)}this.setStateCamera(this._viewpointToCamera(e),{applyConstraints:!e.camera})||a.getLogger(this).error("#viewpoint=","Invalid viewpoint",e)}else a.getLogger(this).error("#viewpoint=","Viewpoint may not be null or undefined")}get zoom(){return this.ready?B(this.view,this.scale):this._get("zoom")}set zoom(e){this._updatePropertyBeforeReady("zoom",e)||void 0===e||this.setStateCamera(this._zoomToCamera(e),{applyConstraints:!0})||a.getLogger(this).error("#zoom=","Invalid zoom",e)}_computeCanvasSize(){if(this._devicePixelRatioOverride)return this.view.state.contentPixelRatio=this._devicePixelRatioOverride,this._tmpCanvasSize.width=Math.round(this.view.surface.clientWidth*this._devicePixelRatioOverride),this._tmpCanvasSize.height=Math.round(this.view.surface.clientHeight*this._devicePixelRatioOverride),this._tmpCanvasSize.pixelRatio=this._devicePixelRatioOverride,this._tmpCanvasSize;const e=Math.min(this._windowDevicePixelRatio,this.view.qualitySettings.maximumPixelRatio),t=(this._usePhysicalPixelRendering?this._windowDevicePixelRatio:e)*this.view.resolutionScale;this._tmpCanvasSize.width=Math.round(this.view.surface.clientWidth*t),this._tmpCanvasSize.height=Math.round(this.view.surface.clientHeight*t);const i=this.view.stage.renderView.renderingContext?.parameters.maxTextureSize;return i&&N(this._tmpCanvasSize,i),this._tmpCanvasSize.pixelRatio=this._tmpCanvasSize.width>0?this._tmpCanvasSize.width/this.view.surface.clientWidth*.5+this._tmpCanvasSize.height/this.view.surface.clientHeight*.5:t,this.view.state&&(this.view.state.contentPixelRatio=Math.min(this._windowDevicePixelRatio,this.view.qualitySettings.maximumPixelRatio)),this._tmpCanvasSize}get _rasterPixelRatio(){return null!=this._devicePixelRatioOverride?this._devicePixelRatioOverride:this._usePhysicalPixelRenderingAny?this._windowDevicePixelRatio:Math.min(this._windowDevicePixelRatio,this.view.qualitySettings.maximumPixelRatio)}get _usePhysicalPixelRendering(){return this.view?.stage?.renderer.isFeatureEnabled(8)??!1}get _usePhysicalPixelRenderingAny(){const e=this.view?.stage?.renderer;return e&&(e.isFeatureEnabled(8,2)||e.isFeatureEnabled(8,1)||e.isFeatureEnabled(8,0))}preinit(e){return!(this._isOverridden("center")&&!C(this.center.spatialReference,e))&&(!(this._isOverridden("camera")&&!C(this.camera.position.spatialReference,e))&&(!(this._isOverridden("extent")&&!C(this.extent.spatialReference,e))&&!!(!this._isOverridden("viewpoint")||C(this.viewpoint.targetGeometry?.spatialReference,e)&&C(this.viewpoint.camera?.position?.spatialReference,e))))}init(){this._constraintsManager=new T({view:this.view}),this._prepareFrame();const e=this._getInitialProperties();this._cameraSetByUser=!1,this._set("ready",!0);for(const t of e)this.set(t.name,t.value);if(!this._cameraSetByUser){const e=this._initialViewpoint||this.view.initialExtent;e&&this.isCompatible(e)?this._setInitialView(e):2===this.view.state.viewingMode&&this.addHandles(l(()=>this.view.basemapTerrain.ready,()=>{this.removeHandles($),this._setInitialView(this.view.dataExtent)},{once:!0,initial:!0}),$)}}exit(){this._cancelGoToOperation(),this.ready&&(this._override("padding",this.padding),this._set("ready",!1),this._clearOverride("hasInitialView"),this._cameraSetByUser=!1,this.removeHandles($),this._constraintsManager=s(this._constraintsManager))}async goTo(e,t){return t={animate:!0,...t},null!=this._gotoOperation&&this._gotoOperation.abort(t.animate),this._gotoOperation=new z(e,t,this.view),this.view.resourceController.scheduler.stopFrame(),this._gotoOperation.promise}debugSetCameraOnContent(){this.setStateCamera(O(this.view),{applyConstraints:!1})}step(e){const t=this.view.state?.cameraController;t?.stepController&&this.view.state.updateCamera(i=>t.stepController(e,i))}_cancelGoToOperation(){null!=this._gotoOperation&&(this._gotoOperation.abort(),this._gotoOperation=null)}_getInitialProperties(){const e=new Set,t=[];for(const{propertyName:i,overrides:r}of J){const a=e.has(i),s=this._isOverridden(i);!a&&s&&t.push({name:i,value:this._get(i)}),this._clearOverride(i),(a||s)&&r.forEach(t=>e.add(t))}return t}_setInitialView(e){if(null==e||this._cameraSetByUser)return;if(e instanceof t)return void this.setStateCamera(P(this.view,e),{applyConstraints:!1});if(e instanceof i){if(e.targetGeometry instanceof y){const t=E(this.view,e.targetGeometry,0,.5,0);return void(null!=t&&this.setStateCamera(P(this.view,t),{applyConstraints:!0}))}const t={applyConstraints:!e.camera},i=this._viewpointToCamera(e);return void this.setStateCamera(i,t)}const r=E(this.view,e,0,.5,0);null!=r&&this.setStateCamera(P(this.view,r),{applyConstraints:!0})}_updatePropertyBeforeReady(e,t){return!this.ready&&(this._override(e,t),t&&Z.has(e)&&this._override("hasInitialView",!0),!0)}isCompatible(e){return null!=e&&(e instanceof i?e.camera?this.isCompatible(e.camera):this.isCompatible(e.targetGeometry):e instanceof t?this.isCompatible(e.position):e.spatialReference&&!x(e.spatialReference,this.view.spatialReference))}_getPreservingHeadingTilt(e=K){return this._cameraSetByUser?(e.heading=this.camera.heading,e.tilt=this.camera.tilt):(e.heading=0,e.tilt=.5),e}_centerPointAtDistanceToCamera(e,t,i=X){const{heading:r,tilt:a}=this._getPreservingHeadingTilt(),s=V(this.view,r,a,e,t,1);return null==s?null:(i.copyFrom(this.view.state.camera),i.eye=s.eye,i.center=s.center,i.up=s.up,i)}_centerToCamera(e){let t;if(e.hasZ)t=this.view.state.camera.distance;else{const{centerOnContent:e}=this.view.pointsOfInterest;e.runTask(),t=e.distance}return this._centerPointAtDistanceToCamera(e,t)}_extentToCamera(e){const{heading:t,tilt:i}=this._getPreservingHeadingTilt(),r=E(this.view,e,t,i,1,Q);return r?P(this.view,r):null}_scaleToCamera(e){if(null==e)return null;const t=this.view,i=t.pointsOfInterest.centerOnContent;i.runTask();const r=i.renderLocation,a=t.pointsOfInterest.cameraOnSurface.renderLocation,s=A(t,e,r,a);return this._centerPointAtDistanceToCamera(r,s)}_zoomToCamera(e){return this._scaleToCamera(U(this.view,e))}_viewpointToCamera(e){return P(this.view,D(this.view,e))}setStateCamera(e,t){return!(null==e||!this.view.state.stopActiveCameraController())&&(this._cameraSetByUser=!0,t.doNotCancelGoToOperation||this._cancelGoToOperation(),this.view.state.updateCamera(i=>{t.positionAndOrientationOnly?(i.eye=e.eye,i.center=e.center,i.up=e.up,i.fov=e.fov):i.copyFrom(e),t.applyConstraints&&S(this.view,i)}),t.applyConstraints||(this.view.state.cameraController=new M({view:this.view,desiredCamera:e})),!0)}_prepareFrame(){const{surface:e,canvas:t,stage:i}=this.view;if(!e||!t||!i||i.destroyed||i.destroying)return;this._windowDevicePixelRatio=window.devicePixelRatio;const r=this._computeCanvasSize();if(0!==r.width&&0!==r.height&&(t.width===r.width&&t.height===r.height||(t.width=r.width,t.height=r.height),this.view.state)){const e=this.view.state.camera;e.fullWidth===r.width&&e.fullHeight===r.height&&e.pixelRatio===r.pixelRatio||(X.copyFrom(e),X.pixelRatio!==r.pixelRatio&&(this._paddingToArray(this.padding,r.pixelRatio,Y),X.padding=Y),X.fullWidth=r.width,X.fullHeight=r.height,X.pixelRatio=r.pixelRatio,this.view.state.camera=X),this._updateState()}}_updateElevation(e){const t=this.view.renderCoordsHelper?.getAltitude(e.eye)??0,i=this.view.basemapTerrain?.spatialReference,r=i?b(this.view,e.eye):0;e.relativeElevation=t-r}_updateState(){null!=this.test.renderState?this.view.state.mode=this.test.renderState:this.view.animation?this.view.state.mode=0:this.view.interacting?this.view.state.mode=1:(0===this.view.state.mode&&(this._cameraChangeTime=0),performance.now()-this._cameraChangeTime<this._idleTimeout?this.view.state.mode=1:this.view.state.mode=2),this.view.state.rasterPixelRatio=this._rasterPixelRatio}_cameraChangedHandler(e,t){e&&t&&e.almostEquals(t)||(this._cameraChangeTime=performance.now(),this._updateState())}};e([m({type:t,dependsOn:["view.state.camera","ready"]})],q.prototype,"camera",null),e([m({type:t,dependsOn:["view.state.contentCamera","ready"]})],q.prototype,"contentCamera",null),e([m({type:_})],q.prototype,"center",null),e([m()],q.prototype,"visibleArea",null),e([m({type:y})],q.prototype,"extent",null),e([m({readOnly:!0})],q.prototype,"frustum",null),e([m()],q.prototype,"_constraintsManager",void 0),e([m({readOnly:!0})],q.prototype,"constraintsManager",null),e([m()],q.prototype,"_initialViewpoint",null),e([m({readOnly:!0})],q.prototype,"hasInitialView",null),e([m({readOnly:!0,type:Boolean})],q.prototype,"ready",void 0),e([m({type:Number})],q.prototype,"scale",null),e([m()],q.prototype,"padding",null),e([m({readOnly:!0})],q.prototype,"screenCenter",null),e([m({constructOnly:!0})],q.prototype,"view",void 0),e([m({type:i})],q.prototype,"viewpoint",null),e([m({type:Number})],q.prototype,"zoom",null),e([m({readOnly:!0})],q.prototype,"_rasterPixelRatio",null),e([m({readOnly:!0})],q.prototype,"_usePhysicalPixelRendering",null),e([m({readOnly:!0})],q.prototype,"_usePhysicalPixelRenderingAny",null),e([m()],q.prototype,"_windowDevicePixelRatio",void 0),e([m()],q.prototype,"_devicePixelRatioOverride",void 0),q=e([d("esri.views.3d.state.ViewStateManager")],q);class W{constructor(){this.width=0,this.height=0,this.pixelRatio=1}}const Z=new Set(["camera","viewpoint","extent","scale","center","zoom"]),J=[{propertyName:"camera",overrides:["viewpoint"]},{propertyName:"viewpoint",overrides:["extent"]},{propertyName:"extent",overrides:["center","scale"]},{propertyName:"center",overrides:[]},{propertyName:"scale",overrides:["zoom"]},{propertyName:"zoom",overrides:[]},{propertyName:"padding",overrides:[]}],K={heading:0,tilt:0};let Q=new t,X=new F;const Y=g(),$="pending-initial-view",ee="content-camera-reset",te=300,ie=100;function re(){Q=new t,X=new F}export{q as ViewStateManager,re as cleanupViewStateManager,ie as interactingTimeout};
