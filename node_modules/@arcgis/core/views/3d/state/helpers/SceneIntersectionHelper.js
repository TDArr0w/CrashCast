/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import e from"../../../../core/PooledArray.js";import{createRenderScreenPointArray3 as t,castRenderScreenPointArray3 as r}from"../../../../core/screenUtils.js";import{getMetersPerVerticalUnitForSR as n}from"../../../../core/unitUtils.js";import{g as i,n as s,f as o}from"../../../../chunks/vec32.js";import{create as l}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as a,copy as c,negativeInfinity as u,width as h,height as p,expandPointInPlace as d}from"../../../../geometry/support/aaBoundingRect.js";import{create as m}from"../../../../geometry/support/ray.js";import{sv3d as y}from"../../../../geometry/support/vectorStacks.js";import{getElevationOffsetInMeters as f}from"../../../../support/elevationInfoUtils.js";import{computeMapPointFromVec3d as g}from"../../support/hitTest.js";import{fromRenderAtEye as _,fromScreen as w}from"../../support/geometryUtils/ray.js";import{defaultTolerance as R,Intersector as b}from"../../webgl-engine/lib/Intersector.js";import{isValidIntersectorResult as v}from"../../webgl-engine/lib/IntersectorResult.js";import{sliceFilterPredicate as I}from"../../webgl-engine/lib/intersectorUtils.js";import{HUDMaterial as P}from"../../webgl-engine/materials/HUDMaterial.js";class j{constructor(t,r,n){this.viewingMode=t,this._forEachLayer=r,this._view=n,this._externalIntersectionHandlers=new e,this._tolerance=R,this._tmpRay=m(),this._tmpRegion=a(),this._validateHUDIntersector=new b(this.viewingMode),this._validateHUDIntersector.options.hud=!1}destroy(){this._externalIntersectionHandlers.prune()}intersectScreen(e,t,r){return this.intersectRay(this._getPickRay(e,this._tmpRay),L(this.viewingMode),t,r)}intersectScreenFreePointFallback(e,t,r){return this.intersectRayFreePointFallback(this._getPickRay(e,this._tmpRay),t,r)}intersectRayFreePointFallback(e,t,r){return this.intersectRay(e,L(this.viewingMode),t,r)||this._intersectRayFreePointLocal(e,t)}intersectRay(e,t,r,n){return t.options.selectionMode=!1,t.options.store=0,this.computeIntersection(e,t,!1,n),!!t.results.min&&t.results.min.getIntersectionPoint(r)}getCenterRayWithSubpixelOffset(e,t,r=.5,n=.5){return e.getRenderCenter(F,r,n),F[0]+=.0466,F[1]-=.0123,_(e,F,t)}intersectIntersectorScreen(e,t,r){this.computeIntersection(this._getPickRay(e,this._tmpRay),t,!1,r)}intersectToolIntersectorScreen(e,t,r){const n=this._getPickRay(e,this._tmpRay);this.intersectToolIntersectorRay(n,t,r)}intersectToolIntersectorRay(e,t,r){t.options.selectionMode=!0,this.computeIntersection(e,t,!1,r);const n=t.results.min;!!this._view.basemapTerrain&&this._view.basemapTerrain.opaque||v(n)&&7!==n.intersector||(t.options.selectionMode=!1,this.computeIntersection(e,t,!1,r))}setTolerance(e=R){this._tolerance=e}addIntersectionHandler(e){this._externalIntersectionHandlers.push(e),this._externalIntersectionHandlers.sort((e,t)=>7===e.type?1:7===t.type?-1:0)}removeIntersectionHandler(e){null!=this._externalIntersectionHandlers.removeUnordered(e)&&this._externalIntersectionHandlers.sort((e,t)=>7===e.type?1:7===t.type?-1:0)}_getPickRay(e,t){const r=this._view.state.camera;return w(r,e,t)}_intersectRayFreePointLocal(e,t){return 2!==this.viewingMode||null==e||i(t,e.origin,s(y.get(),e.direction)),!1}intersectElevationFromScreen(e,t,r=0,n=null){return this._intersectElevation(this._getPickRay(e,this._tmpRay),t,r,n)}_intersectElevation(e,t,l=0,a=null){if(null==e)return null;const c=this._view,{renderCoordsHelper:u}=c,h=n(c.spatialReference),p=null!=t?t.mode:"absolute-height",d=f(t)/h,m=("on-the-ground"!==p?d+l:0)*h/u.unitInMeters,{camera:_}=c.state;if("absolute-height"===p){const t=u?.getAltitude(_.eye),r=o(s(E,e.direction),u.worldUpAtPosition(_.eye,V));if(t<m&&r<0||t>=m&&r>0)return null;if(u.intersectInfiniteManifold(e,m,E)){const e=g(c,E);return e.z??=0,e.z-=d,e}return null}const w=_.projectToRenderScreen(e.origin,r(y.get())),R=new k(null,this._forEachLayer),v=c.slice.plane,P=null!=v?I(v):null,j=new b(this.viewingMode);j.options.store=0,j.options.verticalOffset=m,j.options.normalRequired=!1;const U=e.origin,x=i(y.get(),U,e.direction);j.reset(U,x,_),j.point=w;let M=null;if(a&&"type"in a&&"graphics"===a.type){const e=c.allLayerViews.find(e=>e.layer===a)?.uid;M=e?t=>t.layerViewUid===e:null}else a&&(M=e=>e.graphicUid!==a.uid);switch(p){case"relative-to-scene":{const e=e=>(!M||M(e))&&!!e.lastValidElevationBB;j.intersect(R.layers,w,this._tolerance,null,e),this._externalIntersectionHandlers.forAll(e=>{if(2===e.type||7===e.type||8===e.type){const t=e.slicePlaneEnabled?P:null;e.intersect(j,t,j.rayBegin,j.rayEnd,w,!1)}});break}case"on-the-ground":case"relative-to-ground":this._externalIntersectionHandlers.forAll(e=>{if(e.isGround){const t=e.slicePlaneEnabled?P:null;e.intersect(j,t,j.rayBegin,j.rayEnd,w,!1)}})}if(j.results.min.getIntersectionPoint(E)){const e=g(c,E);return e.z=l,e}return null}computeIntersection(e,t,n,s){if(null==e)return;const o=this._view.state.camera,l=o.projectToRenderScreen(e.origin,r(y.get())),a=new k(s,this._forEachLayer);t.options.selectOpaqueTerrainOnly=!s||!("include"in s||"exclude"in s);const c=e.origin,u=i(y.get(),e.origin,e.direction);t.reset(c,u,o),t.intersect(a.layers,l,this._tolerance);const h=this._view.slice.plane,p=null!=h?I(h):null;t.intersect(a.sliceableLayers,l,this._tolerance,p);const d=s&&(s.requiresGroundFeedback||s.enableDraped);this._externalIntersectionHandlers.forAll(e=>{const r=e.layerViewUid,i=e.sublayerId,s=Array.isArray(r),o=s?r:[r];s&&(t.options.filteredLayerViewUids=[]);let h=!1;for(const n of o)a.filterLayerViewUid(n,i)?h=!0:s&&t.options.filteredLayerViewUids.push(n);if(t.options.isFiltered=!h,e.isGround&&d||!t.options.isFiltered){const r=e.slicePlaneEnabled?p:null;e.intersect(t,r,c,u,l,n)}});const m=y.get(),f=this._view,g=f.basemapTerrain;if(s&&s.enableDraped&&null!=g.spatialReference&&t.results.ground.getIntersectionPoint(m)){const e=f.overlayManager.renderer,r=f.renderCoordsHelper.spatialReference,n=y.get();f.renderCoordsHelper.fromRenderCoords(m,n,g.spatialReference),n[2]=f.elevationProvider?.getElevation(m[0],m[1],m[2],r,"ground")??0,e.intersect(t,n,t.results.ground,e=>a.filterRenderGeometry(e))}t.sortResults(),this._processHUDResults(t)}_processHUDResults(e){const t=e.results.hud;c(this._tmpRegion,u);const r=this._view.state.camera,n=[],i=this._tmpRegion,s=e=>{const t=new M(e),s=t.result.target.object.geometries.every(e=>e.material instanceof P&&e.material.parameters.occlusionTest);n.push({item:t,occlusionTest:s}),s&&(r.projectToRenderScreen(e.target.center,t.screenPoint),t.screenPoint[0]=Math.floor(t.screenPoint[0]),t.screenPoint[1]=Math.floor(t.screenPoint[1]),d(i,t.screenPoint))};e.sortResults(t.all),null!=t.min.distance&&s(t.min);for(const c of t.all)t.min.target.object!==c.target.object&&t.max.target.object!==c.target.object&&s(c);if(null!=t.max.distance&&t.max.target.object!==t.min.target.object&&s(t.max),!n.length)return;i[0]===i[2]&&(i[2]+=1),i[1]===i[3]&&(i[3]+=1);const o=r.fullWidth,l=r.fullHeight,a=Math.max(0,i[0]-U),m=Math.max(0,i[1]-U),y=Math.min(h(i)+2*U,o-a),f=Math.min(p(i)+2*U,l-m),g=y>0&&f>0?new Uint8Array(y*f*4):null;g&&this._view.stage.renderer.readHUDVisibility(a,m,y,f,g);let _=!0;const w=null==e.results.max.distance;let R=0;for(const{item:c,occlusionTest:u}of n){let t=!u;if(u&&g)for(const e of x){const r=4*(Math.min(c.screenPoint[0]+e[0],o)-i[0]+(Math.min(c.screenPoint[1]+e[1],l)-i[1])*y);if(r>=0&&r<g.length&&g[r]){t=!0;break}}t&&(_&&(e.results.min.copy(c.result),_=!1),w&&e.results.max.copy(c.result),2===e.options.store&&e.results.all.splice(R++,0,c.result))}}}const U=1,x=(()=>{const e=[],t=U;for(let r=-t;r<=t;r++)for(let n=-t;n<=t;n++)e.push([n+t,r+t]);return e})();class M{constructor(e){this.result=e,this.screenPoint=t()}}let H;function L(e){return H&&H.viewingMode===e||(H=new b(e)),H}class k{constructor(e,t){this.layers=new Array,this.sliceableLayers=new Array,this.include=e?.include,this.exclude=e?.exclude,t(e=>{e.pickable&&this.filterLayerViewUid(e.apiLayerViewUid)&&(e.sliceable?this.sliceableLayers:this.layers).push(e)})}filterLayerViewUid(e,t){const{include:r,exclude:n}=this;if(null==e)return null==r&&null==n;const i=r instanceof Map?r.get(e)??!1:r?.has(e),s=n instanceof Map?n.get(e)??!1:n?.has(e);return(null==i||("boolean"==typeof i?i:null!=t&&i.has(t)))&&(null==s||!("boolean"==typeof s?s:null!=t&&s.has(t)))}filterRenderGeometry(e){return this.filterLayerViewUid(e.layerViewUid)}}function T(e){return"object"==typeof e&&"intersect"in e}const E=l(),V=l(),F=t();export{j as SceneIntersectionHelper,T as isIntersectionHandler};
