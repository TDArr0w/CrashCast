/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import{createScreenPointArray as i,screenPointObjectToArray as e}from"../../../../core/screenUtils.js";import"../../../../core/Logger.js";import"../../../../core/has.js";import"../../../../core/RandomLCG.js";import"../../../../core/Error.js";import{subclass as n}from"../../../../core/accessorSupport/decorators/subclass.js";import{distance as s}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{u as o,d as r,f as a,e as m,b as h,n as l,h as c,g as p}from"../../../../chunks/vec32.js";import{create as _,fromValues as u}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{wrapAxisAngle as g}from"../../../../geometry/support/axisAngle.js";import{create as d,fromNormalAndOffset as C,setOffsetFromPoint as v,negate as b,getNormal as w}from"../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as M,applyAll as f}from"../../camera/constraintUtils.js";import{ConstraintOptions as j}from"../../camera/constraintUtils/ConstraintOptions.js";import{ExponentialFalloff as P}from"../../input/util.js";import{getVoxelWasm as V}from"../../layers/VoxelWasm.js";import{InteractiveController as z}from"./InteractiveController.js";import{PanPlanarMomentumController as S}from"./momentum/PanPlanarMomentumController.js";import{RotationMomentumController as E}from"./momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as H}from"./momentum/ZoomPlanarMomentumController.js";import{excludeTerrain as y,inferNavigationMode as x,getTiltScaleFactor as O,maxPanDistanceModifier as F,minPinchAndPanCameraHeight as R,pivotSearchAreaSize as A,centroid as T,applyZoomToPoint as U,applyPanPlanar as L,normalizeRotationDelta as k,applyRotation as D,intersectPlaneFromScreenPointAtEye as G}from"../utils/navigationUtils.js";import I from"../../webgl/RenderCamera.js";import{PanPlanarMomentumEstimator as Z}from"../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as W}from"../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as q}from"../../../navigation/ZoomMomentumEstimator.js";const B=u(0,0,1);let J=class extends z{constructor(){super(...arguments),this._rotationValueSmooth=new P(.05),this._scalingValueSmooth=new P(.05),this._planeHorizontal=d(),this._planeVertical=d(),this._rotationMomentumEstimator=new W,this._panMomentumEstimator=new Z(300,12,.9),this._zoomMomentumEstimator=new q,this._beginRadius=0,this._beginCenter=_(),this._beginAngle=0,this._tmpPoints=[],this._navigationMode=1,this._beginCenterScreen=i(),this._tmpCentroid3d=_(),this._tmpCentroid2d=i(),this._tmp2d=i(),this._pointerCount=0,this._beginCamera=new I,this._constraintOptions=new j(15,0,0,this._beginCamera)}begin(t){if(!this.running)return;const i=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=i,this._rotationMomentumEstimator.enabled=i,this._panMomentumEstimator.enabled=i,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),e(t.center,this._beginCenterScreen),C(B,0,this._planeHorizontal);const n=_(),s=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,n,this.view.basemapTerrain.invisible?y:{}),u=_();o(u,this.startCamera.viewForward);const g=_();r(g,B);const d=a(u,g);this._navigationMode=x(this.startCamera,this._beginCenterScreen,this.view.renderCoordsHelper,this.view.viewingMode);const M=O(g,this.startCamera.viewForward,F)*Math.max(Math.abs(this.view.camera.position.z),R);v(this._planeHorizontal,this._planeHorizontal,n),this.startCamera.aboveGround||b(this._planeHorizontal,this._planeHorizontal);const f=_(),j=_(),P=_();m(f,n,this.currentCamera.eye);const z=h(f);if(l(f,f),0===this._navigationMode){c(g,g,d),m(w(this._planeVertical),u,g),l(w(this._planeVertical),w(this._planeVertical)),v(this._planeVertical,this._planeVertical,n);const i=this.view.stage.renderView.getMinimalDepthForArea(V(this.view),this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,A);let e=null!=i?i:M;s&&(e=Math.min(e,z)),r(P,p(j,this.currentCamera.eye,c(j,f,e))),this._planeVertical[3]=-a(w(this._planeVertical),P),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),T(this._tmpPoints,this._beginCenter)}else{const i=s?z:M;r(P,p(j,this.currentCamera.eye,c(j,f,i))),this._planeHorizontal[3]=-a(w(this._planeHorizontal),P),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),T(this._tmpPoints,this._beginCenter)}this._beginCamera.copyFrom(this.startCamera)}update(t){if(!this.running)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,n=1===this._navigationMode?this._planeHorizontal:this._planeVertical,o=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),U(this.currentCamera,o,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=1,this._constraintOptions.interactionFactor=M(Math.abs(t.radius-this._beginRadius)),f(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,n,this.currentCamera,this._tmpPoints),T(this._tmpPoints,this._tmpCentroid3d),e(t.center,this._tmpCentroid2d),L(this.currentCamera,o,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=4,this._constraintOptions.interactionFactor=M(s(this._beginCenterScreen,this._tmpCentroid2d)),f(this.view,this.currentCamera,this._constraintOptions),i){const i=o,e=this._rotationValueSmooth.value,n=e+k(t.angle-e),s=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=s,this._rotationValueSmooth.update(n);const r=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(r,.001*t.timestamp);const a=w(this._planeHorizontal);D(this.currentCamera,i,g(a,r)),this._constraintOptions.interactionType=2,this._constraintOptions.interactionFactor=M(Math.abs(t.radius*r)),f(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new H({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new E({view:this.view,momentum:e,center:this._beginCenter,axis:w(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new S({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const s=this._tmp2d;let o=0;return t.forEach(t=>{s[0]=t.x,s[1]=t.y,void 0===n[o]&&(n[o]=_()),G(i,e,s,n[o]),o+=1}),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};J=t([n("esri.views.3d.state.controllers.PinchAndPanControllerLocal")],J);export{J as PinchAndPanControllerLocal};
