/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import{acosClamped as i,clamp as s}from"../../../../core/mathUtils.js";import{createScreenPointArray as r}from"../../../../core/screenUtils.js";import{property as o}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as e}from"../../../../core/accessorSupport/decorators/subclass.js";import{fromRotation as a,rotate as n}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as h}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{copy as p}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as m}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{d as c,e as l,b as _,n as v,g as f,h as P,f as u,i as w,t as C}from"../../../../chunks/vec32.js";import{create as d}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{applyAll as g}from"../../camera/constraintUtils.js";import{ConstraintOptions as j}from"../../camera/constraintUtils/ConstraintOptions.js";import{getVoxelWasm as x}from"../../layers/VoxelWasm.js";import{TiltRange as y}from"../Constraints.js";import{InteractiveController as b}from"./InteractiveController.js";import{excludeTerrain as R,normalizeCoordinate as M,getTiltScaleFactor as U,maxRotatePivotDistanceModifier as V,minRotatePivotDistance as D,inferNavigationMode as O,rotatePivotSearchAreaSize as T}from"../utils/navigationUtils.js";let A=class extends b{get _intersectionHelper(){return this.view.sceneIntersectionHelper}constructor(t){super(t),this.pivot=0,this._rotScale=0,this._lastPoint=m(),this._tmpWorldUp=d(),this._tmpViewDir=d(),this._tmpRotCurPoint=m(),this._tmpTransf=h(),this._tmpAxis=d(),this._tmpPivotPoint=d(),this._pivotPos=d(),this._constraintOptions=new j(15,2,0,this.startCamera)}initialize(){this._rotScale=0===this.pivot?3:1.5}begin(t){if(this.running){switch(this.pivot){case 1:c(this._pivotPos,this.startCamera.eye),this._constraintOptions.interactionType=3,this._constraintOptions.tiltMode=1,this._constraintOptions.selection=0;break;case 0:{const i=this._intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray,this._pivotPos,this.view.basemapTerrain.invisible?R:{});i||c(this._pivotPos,this.startCamera.center),this._constrainPivotPoint(t,i),this.startCamera.center=this._pivotPos,this._constraintOptions.interactionType=2,this._constraintOptions.tiltMode=0,this._constraintOptions.selection=11;break}}M(this.startCamera,t,this._lastPoint)}}_constrainPivotPoint(t,i){const s=this.startCamera,o=d();l(o,this._pivotPos,s.eye);const e=_(o),a=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(s.eye,S);let n=Math.max(U(S,s.viewForward,V)*a,D);i&&(n=Math.min(e,n));const h=r(s.width/s.pixelRatio*.5,s.height/s.pixelRatio*.5),p=O(this.startCamera,h,this.view.renderCoordsHelper,this.view.viewingMode);let m=this.view.stage.renderView.getMinimalDepthForArea(x(this.view),s.fullWidth/s.pixelRatio*.5,s.fullHeight/s.pixelRatio*.5,s,2.5*T,T),u=this.view.stage.renderView.getMinimalDepthForArea(x(this.view),t[0],t[1],s,T);null==m&&null==u||(m=m??u??0,u=null==u||1===p?m:u,n=m>u?u:m,n=i?Math.min(n,e):n),v(o,o),c(this._pivotPos,f(this._tmpPivotPoint,s.eye,P(this._tmpPivotPoint,o,n)))}update(t){if(this.running){switch(this.pivot){case 1:this.currentCamera.center=this._applyRotation(this.currentCamera,t,this.currentCamera.center,this._pivotPos);break;case 0:this.currentCamera.center=this._pivotPos,this.currentCamera.eye=this._applyRotation(this.currentCamera,t,this.currentCamera.eye,this._pivotPos)}g(this.view,this.currentCamera,this._constraintOptions),this.commitCamera()}}end(){this.running&&this.finishController()}_applyRotation(t,r,o,e){this.view.renderCoordsHelper.worldUpAtPosition(e,this._tmpWorldUp),M(t,r,this._tmpRotCurPoint);let h=(this._lastPoint[1]-this._tmpRotCurPoint[1])*this._rotScale,m=(this._tmpRotCurPoint[0]-this._lastPoint[0])*this._rotScale;l(this._tmpViewDir,o,e);const c=_(this._tmpViewDir),v=i(u(this._tmpViewDir,this._tmpWorldUp)/c);if(1===this.pivot){h*=-.5;const t=.5*Math.PI-v,i=.5*Math.PI*.99;h=t-Math.max(-i,Math.min(i,t+h))}return h=s(h+v,y.min,y.max)-v,w(this._tmpAxis,t.up,this._tmpViewDir),0===this.pivot&&(m=-m),a(this._tmpTransf,m,this._tmpWorldUp),n(this._tmpTransf,this._tmpTransf,h,this._tmpAxis),C(this._tmpViewDir,this._tmpViewDir,this._tmpTransf),t.up=C(H,t.up,this._tmpTransf),f(H,e,this._tmpViewDir),p(this._lastPoint,this._tmpRotCurPoint),H}};t([o()],A.prototype,"pivot",void 0),A=t([e("esri.views.3d.state.controllers.RotateController")],A);const H=d(),S=d();export{A as RotateController};
