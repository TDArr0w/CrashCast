/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{neverReached as e}from"../../../../core/compilerUtils.js";import{acosClamped as t,clamp as r,asinClamped as n,deg2rad as i}from"../../../../core/mathUtils.js";import{fromRotation as a}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as s}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{e as c,t as o,h as u,g as l,m,k as d,f,n as h,b as p}from"../../../../chunks/vec32.js";import{create as M}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as y}from"../../../../geometry/ellipsoidUtils.js";import{l as C,b as I,t as x}from"../../../../chunks/sphere.js";import{defaultConstraintOptions as S,hasConstraintType as v,adjustRangeForInteraction as w}from"./common.js";import{viewAngle as A}from"../../state/utils/viewUtils.js";function R(t,r,n,i=!0){Q.eyeCenterDistance=0,Q.requiresTwoSteps=!1;const s=T(t,r,n,S,Q);if(0===s)return!1;switch(a(z,-s,r.viewRight),n.tiltMode){case 1:o(L,r.viewForward,z),u(L,L,Q.eyeCenterDistance),r.center=l(B,r.eye,L);break;case 0:c(L,r.center,r.eye),o(L,L,z),r.eye=c(B,r.center,L);break;default:e(n.tiltMode)}return r.up=o(B,r.up,z),!Q.requiresTwoSteps||!i||R(t,r,n,!1)}function T(e,t,r,n=S,i){if(!e.state.constraints.tilt)return 0;const a=Math.min(t.relativeElevation*J,t.distance),s=e.state.constraints.tilt(a,K);return E(e,r,s),2===n.interactionType&&v(n.selection,2)&&U(e,n.interactionStartCamera,s),1===r.tiltMode||1===n.tiltMode?P(e,t,s,i):b(e,t,s)}function b(e,t,n){const i=A(e.renderCoordsHelper,t.center,t.eye),a=i-r(i,n.min,n.max);return q(a)?a:0}function P(e,t,r,n){switch(n&&(n.requiresTwoSteps=!1),e.viewingMode){case"global":return g(e,t,r,n);case"local":return j(e,t,r,n)}}function j(e,t,n,i){const a=A(e.renderCoordsHelper,t.center,t.eye),s=r(a,n.min,n.max),c=a-s;if(!q(c))return 0;if(i){const r=Math.abs(e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude),n=e.renderCoordsHelper.getAltitude(t.eye)-r,a=Math.max(Math.cos(s),1e-4);Math.abs(a)>1e-4?i.eyeCenterDistance=n/a:i.eyeCenterDistance=t.distance}return c}function g(e,t,n,i){const a=O(e,t,N),s=r(a.tiltAtCenter,n.min,n.max);if(!q(a.tiltAtCenter-s))return 0;let c,o;return a.centerIsOnSurface?(c=H(a),o=k(a,c)):(c=a.constraints.clampTilt(a.distance,a.tiltAtCenter),i&&c<Math.PI/2&&(i.requiresTwoSteps=!0,c=Math.PI/2-1e-5),o=F(a,c)),i&&(i.eyeCenterDistance=D(a,c)),o}function O(e,r,n){const i=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,a=i+y(e.spatialReference).radius,s=e.renderCoordsHelper.intersectManifold(r.ray,i,B);return n.distance=Math.min(r.relativeElevation*J,r.distance),n.centerIsOnSurface=!1,null!=s?(n.distance=Math.min(r.relativeElevation*J,d(r.eye,s)),n.tiltAtCenter=A(e.renderCoordsHelper,s,r.eye),n.centerIsOnSurface=!0):e.state.isLocal?n.tiltAtCenter=A(e.renderCoordsHelper,r.center,r.eye):(C(I(x,a),r.ray,B),n.distance=Math.min(r.relativeElevation*J,d(r.eye,B)),n.tiltAtCenter=t(-f(r.viewForward,h(B,B)))),n.radius=a,n.eyeRadius=p(r.eye),n.constraints=e.state.constraints,n}function q(e){return Math.abs(e)>1e-9}function H(e){const{constraints:t,distance:r,tiltAtCenter:n}=e;let i=n,a=t.clampTilt(r,n);const s=D(e,a);if(t.clampTilt(s,n)===a)return a;let c=0;for(;c<10&&q(a-i);){const r=(i+a)/2,n=D(e,r);q(t.clampTilt(n,r)-r)?i=r:a=r,c++}return a}function D(e,t){if(!e.centerIsOnSurface)return e.distance;const i=Math.PI-r(t,0,Math.PI),a=n(e.radius/e.eyeRadius*Math.sin(i)),s=Math.PI-i-a,c=Math.sin(s)/Math.sin(i);if(e.eyeRadius<e.radius&&c>1){const t=Math.PI-a,r=Math.PI-i-t;return Math.sin(r)/Math.sin(i)*e.eyeRadius}return c*e.eyeRadius}function k(e,t){const r=n(e.radius/e.eyeRadius*Math.sin(e.tiltAtCenter)),i=n(e.radius/e.eyeRadius*Math.sin(t));return e.eyeRadius>e.radius?r-i:i-r}function F(e,t){return e.tiltAtCenter-Math.PI/2-(t-Math.PI/2)}function E(e,t,r){if(0===t.interactionType)return;const{interactionStartCamera:n,interactionFactor:i}=t;if(!n)return;const{min:a,max:s}=r,c=T(e,n,S,t),o=0===c?0:A(e.renderCoordsHelper,n.center,n.eye);r.min=a,r.max=s,2===t.interactionType?(v(t.selection,2)&&U(e,n,r),w(c,o,!0,i,G,r)):w(c,o,!1,i,G,r)}function U(e,r,n){const i=e.state.constraints;if(e.state.isLocal||!i.altitude||!r)return;const a=m(r.center),s=Math.sqrt(a),c=r.distance,o=y(e.spatialReference).radius,u=i.altitude.min+o,l=i.altitude.max+o,d=(u*u-c*c-a)/(-2*s*c),f=(l*l-c*c-a)/(-2*s*c);n.min=Math.max(n.min,Math.min(Math.PI-t(f),n.max)),n.max=Math.min(n.max,Math.PI-t(d))}const L=M(),z=s(),B=M(),G=i(5),J=30,K={min:0,max:0},N={constraints:null,radius:0,eyeRadius:0,centerIsOnSurface:!0,distance:0,tiltAtCenter:0},Q={eyeCenterDistance:0,requiresTwoSteps:!1};export{R as applyTiltConstraint,T as getTiltConstraintError};
