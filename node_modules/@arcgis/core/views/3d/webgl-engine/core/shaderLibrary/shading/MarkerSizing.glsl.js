/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{markerSizePerLineWidth as e}from"../../../../support/engineContent/marker.js";import{addPixelRatio as r}from"../util/View.glsl.js";import{FloatBindUniform as t}from"../../shaderModules/FloatBindUniform.js";import{If as o,glsl as a}from"../../shaderModules/glsl.js";function i(i,n){const d=i.vertex,l=n.hasScreenSizePerspective;r(d),null==d.uniforms.get("markerScale")&&d.constants.add("markerScale","float",1),d.constants.add("markerSizePerLineWidth","float",e).code.add(a`
  float getLineWidth(${o(l,"vec3 pos")}) {
     return max(getSize(${o(l,"pos")}), 1.0) * pixelRatio;
  }

  float getScreenMarkerSize(float lineWidth) {
    return markerScale * markerSizePerLineWidth * lineWidth;
  }
  `),2===n.space&&(d.constants.add("maxSegmentLengthFraction","float",.45),d.uniforms.add(new t("perRenderPixelRatio",e=>e.camera.perRenderPixelRatio)),d.code.add(a`
  bool areWorldMarkersHidden(vec3 pos, vec3 other) {
    vec3 midPoint = mix(pos, other, 0.5);
    float distanceToCamera = length(midPoint);
    float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
    float worldMarkerSize = getScreenMarkerSize(getLineWidth(${o(l,"pos")})) * screenToWorldRatio;
    float segmentLen = length(pos - other);
    return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
  }

  float getWorldMarkerSize(vec3 pos) {
    float distanceToCamera = length(pos);
    float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
    return getScreenMarkerSize(getLineWidth(${o(l,"pos")})) * screenToWorldRatio;
  }
  `))}export{i as MarkerSizing};
