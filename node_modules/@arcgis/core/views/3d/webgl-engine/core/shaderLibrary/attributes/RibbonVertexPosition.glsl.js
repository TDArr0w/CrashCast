/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{invert as e,translate as i}from"../../../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as a}from"../../../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{VisualVariables as t}from"../shading/VisualVariables.glsl.js";import{ScreenSizePerspective as r,addScreenSizePerspective as o}from"../util/ScreenSizePerspective.glsl.js";import{addCameraPosition as c}from"../util/View.glsl.js";import{Float3PassUniform as l}from"../../shaderModules/Float3PassUniform.js";import{FloatPassUniform as s}from"../../shaderModules/FloatPassUniform.js";import{FloatsPassUniform as v}from"../../shaderModules/FloatsPassUniform.js";import{glsl as n,If as p}from"../../shaderModules/glsl.js";import{Matrix4DrawUniform as d}from"../../shaderModules/Matrix4DrawUniform.js";const u=8;function f(a,f){const{vertex:S,attributes:m}=a;S.uniforms.add(new s("intrinsicWidth",e=>e.width));const{hasScreenSizePerspective:y,spherical:O}=f;y?(a.include(r,f),o(S),c(S,f),S.uniforms.add(new d("inverseViewMatrix",(a,t)=>e(z,i(z,t.camera.viewMatrix,a.origin)))),S.code.add(n`
      float applyLineSizeScreenSizePerspective(float size, vec3 pos) {
        vec3 worldPos = (inverseViewMatrix * vec4(pos, 1)).xyz;
        vec3 groundUp = ${O?n`normalize(worldPos + localOrigin)`:n`vec3(0.0, 0.0, 1.0)`};
        float absCosAngle = abs(dot(groundUp, normalize(worldPos - cameraPosition)));

        return screenSizePerspectiveScaleFloat(size, absCosAngle, length(pos), screenSizePerspective);
      }
    `)):S.code.add(n`float applyLineSizeScreenSizePerspective(float size, vec3 pos) {
return size;
}`),f.hasVVSize?(m.add("sizeFeatureAttribute","float"),S.uniforms.add(new l("vvSizeMinSize",e=>e.vvSize.minSize),new l("vvSizeMaxSize",e=>e.vvSize.maxSize),new l("vvSizeOffset",e=>e.vvSize.offset),new l("vvSizeFactor",e=>e.vvSize.factor),new l("vvSizeFallback",e=>e.vvSize.fallback)),S.code.add(n`
    float getSize(${p(y,"vec3 pos")}) {
      float size = isnan(sizeFeatureAttribute)
        ? vvSizeFallback.x
        : intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;

      return ${p(y,"applyLineSizeScreenSizePerspective(size, pos)","size")};
    }
    `)):(m.add("size","float"),S.code.add(n`
    float getSize(${p(y,"vec3 pos")}) {
      float fullSize = intrinsicWidth * size;
      return ${p(y,"applyLineSizeScreenSizePerspective(fullSize, pos)","fullSize")};
    }
    `)),f.hasVVOpacity?(m.add("opacityFeatureAttribute","float"),S.constants.add("vvOpacityNumber","int",8),S.uniforms.add(new v("vvOpacityValues",e=>e.vvOpacity.values,u),new v("vvOpacityOpacities",e=>e.vvOpacity.opacityValues,u),new s("vvOpacityFallback",e=>e.vvOpacity.fallback,{supportsNaN:!0})),S.code.add(n`
    float interpolateOpacity(float value) {
      if (value <= vvOpacityValues[0]) {
        return vvOpacityOpacities[0];
      }

      for (int i = 1; i < vvOpacityNumber; ++i) {
        if (vvOpacityValues[i] >= value) {
          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
          return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
        }
      }

      return vvOpacityOpacities[vvOpacityNumber - 1];
    }

    vec4 applyOpacity(vec4 color) {
      if (isnan(opacityFeatureAttribute)) {
        // If there is a color vv then it will already have taken care of applying the fallback
        return ${p(f.hasVVColor,"color","vec4(color.rgb, vvOpacityFallback)")};
      }

      return vec4(color.rgb, interpolateOpacity(opacityFeatureAttribute));
    }
    `)):S.code.add(n`vec4 applyOpacity(vec4 color) {
return color;
}`),f.hasVVColor?(a.include(t,f),m.add("colorFeatureAttribute","float"),S.code.add(n`vec4 getColor() {
vec4 color = interpolateVVColor(colorFeatureAttribute);
if (isnan(color.r)) {
return vec4(0);
}
return applyOpacity(color);
}`)):(m.add("color","vec4"),S.code.add(n`vec4 getColor() {
return applyOpacity(color);
}`))}const z=a();export{f as RibbonVertexPosition};
