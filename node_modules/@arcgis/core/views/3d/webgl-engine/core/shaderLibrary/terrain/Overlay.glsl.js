/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{create as e}from"../../../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{hasArea as o,width as r,height as t}from"../../../../../../geometry/support/aaBoundingRect.js";import{isColorOrColorEmission as l}from"../ShaderOutput.js";import{addMainLightDirection as a,addMainLightIntensity as c}from"../shading/MainLighting.glsl.js";import{Water as i}from"../shading/Water.glsl.js";import{Float4DrawUniform as v}from"../../shaderModules/Float4DrawUniform.js";import{FloatPassUniform as s}from"../../shaderModules/FloatPassUniform.js";import{glsl as n}from"../../shaderModules/glsl.js";import{Texture2DPassUniform as d}from"../../shaderModules/Texture2DPassUniform.js";import{Texture2DUintPassUniform as u}from"../../shaderModules/Texture2DUintPassUniform.js";import{Uniform as x}from"../../../../../webgl/Uniform.js";function y(e,o){const{vertex:r,fragment:t}=e;r.uniforms.add(new v("overlayTexOffset",(e,o)=>C(e,o)),new v("overlayTexScale",(e,o)=>h(e,o))),t.constants.add("overlayOpacity","float",1),t.uniforms.add(new d("ovColorTex",(e,o)=>p(e,o))),g(e,o)}function p(e,o){return 0===e.identifier&&l(e.output)?e.occludedGround?o.overlay?.allSourcesOccluders?o.overlay?.getTexture(1):o.overlay?.getTexture(4):o.overlay?.getTexture(1):0===e.identifier&&10===e.output?o.overlay?.getTexture(5):2===e.identifier?o.overlay?.getTexture(2):null}function m(e,o){const{vertex:r,fragment:t}=e,{output:l}=o;r.uniforms.add(new T("overlayTexOffset"),new T("overlayTexScale")),t.uniforms.add(new s("overlayOpacity",e=>e.overlayOpacity)),9!==l&&t.uniforms.add(new d("ovColorTex",(e,o)=>o.overlay?.getTexture(e.overlayContent))),g(e,o)}function f(e,o){switch(e){case 0:case 1:return 9!==o.slot||o.overlay?.allSourcesOccluders?0:4;case 2:case 3:return 0;case 9:return 2;case 4:case 6:case 7:case 8:return null;case 10:return 5}return null}function g(e,o){const r=3===o.pbrMode||4===o.pbrMode||6===o.pbrMode;r&&e.include(i,o);const{vertex:t,fragment:l,varyings:v}=e;v.add("vtcOverlay","vec4");const{output:s}=o,d=9===s;t.code.add(n`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`),l.code.add(n`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),d?l.uniforms.add(new u("overlayHighlightTexture",(e,o)=>o.overlay?.getTexture(2))).code.add(n`uvec2 getAllOverlayHighlightValuesEncoded() {
vec4 texCoords = vtcOverlay;
vec2 uvInner = texCoords.xy;
vec2 uvOuter = texCoords.zw;
bool isValidInner = isValid(uvInner, fwidth(uvInner));
bool isValidOuter = isValid(uvOuter, vec2(0.0, 0.0));
vec2 texelCoordInner = uvInner * vec2(0.5, 1.0);
vec2 texelCoordOuter = uvOuter * vec2(0.5, 1.0) + vec2(0.5,0.0);
vec2 texDim =  vec2(textureSize(overlayHighlightTexture, 0));
uvec2 texelValueInner = texelFetch(overlayHighlightTexture, ivec2(texelCoordInner * texDim), 0).rg;
uvec2 texelValueOuter = texelFetch(overlayHighlightTexture, ivec2(texelCoordOuter * texDim), 0).rg;
return
isValidInner ? texelValueInner :
isValidOuter ? texelValueOuter :
uvec2(0);
}`):(l.code.add(n`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`),l.code.add(n`vec4 getOverlayColorTexel() {
vec4 texCoords = vtcOverlay;
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec4 color0 = texelFetch(ovColorTex, ivec2(vec2(texCoords.x * 0.5, texCoords.y) * texDim), 0);
vec4 color1 = texelFetch(ovColorTex, ivec2(vec2(texCoords.z * 0.5 + 0.5, texCoords.w) * texDim), 0);
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`)),r&&(a(l),c(l),l.code.add(n`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position, vec3 positionWorld) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, mainLightDirection, colorInput.rgb, mainLightIntensity, localUp, 1.0 - shadow, maskInput.w, position, positionWorld);
return vec4(final, colorInput.w);
}`))}function C(e,l){const a=l.overlay?.overlays[0]?.extent;o(a)&&(O[0]=e.toMapSpace[0]/r(a)-a[0]/r(a),O[1]=e.toMapSpace[1]/t(a)-a[1]/t(a));const c=l.overlay?.overlays[1]?.extent;return o(c)&&(O[2]=e.toMapSpace[0]/r(c)-c[0]/r(c),O[3]=e.toMapSpace[1]/t(c)-c[1]/t(c)),O}function h(e,l){const a=l.overlay?.overlays[0]?.extent;o(a)&&(O[0]=e.toMapSpace[2]/r(a),O[1]=e.toMapSpace[3]/t(a));const c=l.overlay?.overlays[1]?.extent;return o(c)&&(O[2]=e.toMapSpace[2]/r(c),O[3]=e.toMapSpace[3]/t(c)),O}const O=e();class T extends x{constructor(e){super(e,"vec4")}}export{y as OverlayIM,m as OverlayTerrain,p as getIMColorTexture,f as getOverlayContentForOutputTerrain};
