/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../../core/Logger.js";import{getOrCreateMapValue as t}from"../../../../../core/MapUtils.js";import i from"../../../../../core/PooledArray.js";import{isTypedArray as o}from"../../../../../core/typedArrayUtil.js";import{s as n}from"../../../../../chunks/vec32.js";import{clone as r}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as s}from"../../../../../geometry/support/aaBoundingBox.js";import{compactIndices as a}from"../../../../../geometry/support/Indices.js";import{c}from"../../../../../chunks/vec3.js";import{c as l}from"../../../../../chunks/vec33.js";import{encodeSymbolColor as m}from"../../../layers/support/symbolColorUtils.js";import{computeOffsetObb as h}from"../../../support/orientedBoundingBox.js";import{glLayout as f}from"../../../support/buffer/glUtil.js";import{ComponentData as p}from"./ComponentData.js";import{ComponentObject as g}from"./ComponentObject.js";import{IntersectionGeometry as d}from"./IntersectionGeometry.js";import{Renderable as u}from"./Renderable.js";import{RenderGeometry as b}from"./RenderGeometry.js";import{RenderSubmitSystem as v}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as y}from"./SourceGeometry.js";import{UniformComponentParameters as _}from"./UniformComponentParameters.js";import{ComponentParametersVarying as M,ComponentParametersUniform as C,ComponentMaterial as j}from"./Material/ComponentMaterial.js";import{indexGlLayout as w}from"./Material/ComponentTechnique.js";import{getComponentFieldCount as O,encodeElevationOffset as x,encodeEmissiveStrength as D}from"./Material/shader/ComponentData.glsl.js";import{olidEnabled as R}from"../../effects/geometry/olidUtils.js";import{getVisibility as S,updatePickabilityWithCount as A}from"../../lib/ComponentUtils.js";import{assert as P}from"../../lib/Util.js";import{VertexArrayObject as B}from"../../lib/VertexArrayObject.js";import{getVerticalOffsetI3S as E}from"../../lib/verticalOffsetUtils.js";import{BufferManager as H}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as U}from"../../../../webgl/BufferObject.js";import{PrimitiveType as V}from"../../../../webgl/enums.js";import{VertexBuffer as I}from"../../../../webgl/VertexBuffer.js";const N=()=>e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class k{constructor(e,t){this._renderManager=e,this._viewingMode=t,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._activeHighlightOptions=new Map,this._visible=new i,this._hidden=new i,this._renderSubmit=new v(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new H(e.rctx,O())}destroy(){P(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._componentBufferManager=null,this._visible.forAll(e=>e.destroy()),this._visible.prune(),this._hidden.forAll(e=>e.destroy()),this._hidden.prune(),this._renderSubmit.destroy()}createObject(e){const{geometry:t}=e,i=new p(this._componentBufferManager,a(t.componentOffsets)),o=this._createRenderable(e,i),n=new d(this._viewingMode,t.positionData,i,e.elevationAlignable),r=new g(e.transform,e.toMapSpace,e.obb.clone(),i,o,n);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const i=e;t!==i.visible&&(t?(this._hidden.removeUnordered(i),this._visible.push(i)):(this._visible.removeUnordered(i),this._hidden.push(i)),i.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll(e=>e.renderable.meta.cameraDepthSquared=n(t,e.obb.center))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const i=e.renderable.material;t(i),i.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const i=e;i.componentData.visibility.reset(t),i.componentData.markVisibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.componentData.visibility.forEachComponent(t)}getComponentCount(e){const t=e,i=t.componentData.visibility.componentCount;return{visible:i,invisible:t.componentData.count-i}}setComponentData(e,t){const i=e,{renderable:o,componentData:n}=i,r=o.material,s=n.materialDataBuffer,a=n.materialDataIndices,c=new _,l=s.textureBuffer,f=new Uint8Array(4),p=new Uint32Array(f.buffer);let g=0,d=0,u=0,b=0,v=0,y=n.verticalOffsets,j=1/0,w=-1/0,O=!1,P=!1,B=!1,E=0;for(let h=0;h<n.count;h++){t(h,c),g+=+(c.externalColor[3]<1),d+=+(3===c.externalColorMixMode&&1===c.externalColor[3]),b+=+(c.emissiveStrength>0),v+=+(1===c.emissiveSource),P||=1!==c.emissiveStrength,u+=+c.castShadows,m(c.externalColor,c.externalColorMixMode,f),f[2]=254&f[2]|+c.castShadows,l.setData(a[h],0,f[0],f[1],f[2],f[3]),O||=h>0&&E!==p[0],E=p[0],B||=0!==c.elevationOffset,B&&null==y&&(y=new Array(h).fill(0)),null!=y&&(y[h]=c.elevationOffset),j=Math.min(j,c.elevationOffset),w=Math.max(w,c.elevationOffset),x(c.elevationOffset,f),l.setData(a[h],1,f[0],f[1],f[2],f[3]),D(c.emissiveStrength,f),l.setData(a[h],2,f[0],f[1],f[2],0===c.emissiveSource?0:255);const e=c.olidColor;null!=e&&l.setData(a[h],3,e[0],e[1],e[2],e[3]),c.pickable!==S(n.pickability,h)&&A(n,h,c.pickable)}n.verticalOffsets=B?y:null,i.offsetObb=B?h(i.obb,j,w,this._viewingMode,i.offsetObb??i.obb.clone()):null,O||B||R()||(P||v>0)&&b>0?(r.componentParameters=new M,r.componentParameters.castShadows=G(u,n.count),r.componentParameters.transparent=G(g,n.count),r.componentParameters.opaqueOverride=G(d,n.count),r.componentParameters.emissiveOverride=G(b,n.count),r.componentParameters.emissiveSourceOverride=G(v,n.count),r.componentParameters.texture=l,l.updateTexture()):(r.componentParameters=new C,r.componentParameters.castShadows=c.castShadows?0:2,r.componentParameters.externalColor=c.externalColor,r.componentParameters.externalColorMixMode=c.externalColorMixMode,r.componentParameters.emissiveStrength=c.emissiveStrength,r.componentParameters.emissiveSource=c.emissiveSource),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,i,o=!1){e.intersectionGeometry.getComponentAabb(t,i);const n=e,r=n.componentData.verticalOffsets;if(o||null==r)return i;const s=r[t];if(2===this._viewingMode||0===s)return i[2]+=s,i[5]+=s,i;const a=E(s);return a.localOrigin=n.transform.position,a.applyToAabb(i)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,i){return e.intersectionGeometry.getComponentPositions(t,i)}expandRangeWithComponentObjectElevationRange(e,t,i,o){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||o.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const n=e,r=n.componentData,s=r.count,a=r.verticalOffsets,c=n.intersectionGeometry,l=2===this._viewingMode,m=c.getComponentAabbs(),h=L;let f=1/0,p=-1/0;for(let g=0;g<s;g++){const e=6*g,r=a?.[g]??0;let s=1/0,c=-1/0;if(l)s=m[e+2]+r+t,c=m[e+5]+r+t;else{if(h[0]=m[e],h[1]=m[e+1],h[2]=m[e+2],h[3]=m[e+3],h[4]=m[e+4],h[5]=m[e+5],0!==r){const e=E(r);e.localOrigin=n.transform.position,e.applyToAabb(h)}const s=Math.max(Math.abs(h[3]),Math.abs(h[0])),a=Math.max(Math.abs(h[4]),Math.abs(h[1])),c=t+h[5]+i;o.expandElevationRangeValues(t+h[2],Math.sqrt(s*s+a*a+c*c)-i)}o.expandElevationRangeValues(s,c),f=Math.min(f,s),p=Math.max(p,c)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=f,this._elevationRangeCacheMax=p}intersect(e,t,i,o,n,r){const s=e,{transform:a,componentData:c,intersectionGeometry:l}=s;return null!=o&&(o.localOrigin=a.position),l.intersect(t,i,o,c.verticalOffsets,a,n,r)}addEdges(e,t,i,o,n){const r=e,{indices:s,positions:a}=r.intersectionGeometry,c=r.componentData.offsets;return t.addComponentObject(r,a,s,c,i,o,n)}async extractEdgeInformation(e,t,i){const o=e,n=o.componentData.visibility;if(n.allInvisible()){const{extractComponentsEdgeLocationsLayout:e}=await import("../../lib/edgeRendering/edgeProcessing.js");return{buffer:e.createBuffer(0),origin:[0,0,0]}}const{indices:s,positions:a}=o.intersectionGeometry,m=o.componentData.offsets,{EdgeInputBufferLayout:h}=await import("../../lib/edgeRendering/bufferLayouts.js"),f=h.createBuffer(a.length/3);l(f.position.typedBuffer,a,f.position.typedBufferStride,3),c(f.position,f.position,o.transform.rotationScale),this._setComponentIndices(f.componentIndex,s,m);const p=f.count,g=this._computeVisibilityIndices(s,n,m,p);return{origin:r(o.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:g,indicesLength:g.length,skipDeduplicate:!0,data:f,writerSettings:{reducedPrecision:!1,variants:0}},i)}}_setComponentIndices(e,t,i){let o=0;for(let n=0;n<i.length-1;n++){const r=i[n],s=i[n+1];for(let i=r;i<s;i++){const n=t?t[i]:i;e.set(n,o)}o++}}_computeVisibilityIndices(e,t,i,n){if(e&&t.allVisible())return e;let r=0;t.forEachComponentRange((e,t)=>(r+=i[t]-i[e],!0));const s=o(e)?2===e?.BYTES_PER_ELEMENT||n<=65536?new Uint16Array(r):new Uint32Array(r):new Array(r);let a=0;return t.forEachComponentRange((t,o)=>{const n=i[t],r=i[o];for(let i=n;i<r;i++)s[a++]=e?e[i]:i;return!0}),s}addComponentHighlight(e,i,o){const n=e.componentData,r=t(n.componentHighlights,o,()=>new Uint32Array(n.count+1));{const e=this._activeHighlightOptions.get(o)??0;this._activeHighlightOptions.set(o,e+1)}0===r[i]++&&(n.markHighlightsDirty(),this._notifyDirty()),r[n.count]++}removeComponentHighlight(e,t,i){const{componentData:o}=e,n=o.componentHighlights.get(i);if(void 0===n)return void N().warn("Removing non-existing highlight.");const r=n[t];if(0===r)return void N().warn("Removing non-existing highlight.");this._removeActiveHighlight(i);const s=n[o.count];if(r>1)return n[t]=r-1,void(n[o.count]=s-1);n[t]=0,1===s?o.componentHighlights.delete(i):n[o.count]=s-1,o.markHighlightsDirty(),this._notifyDirty()}_removeActiveHighlight(e,t=1){const i=this._activeHighlightOptions.get(e);if(void 0===i)N().warn("Removing non-existing highlight.");else{const o=i-t;o<0&&N().warn("Removing non-existing highlight."),o<=0?this._activeHighlightOptions.delete(e):this._activeHighlightOptions.set(e,o)}}clearHighlights(e){const{componentData:t}=e,{componentHighlights:i}=t;if(i.size>0){for(const e of i)this._removeActiveHighlight(e[0],e[1][t.count]);i.clear(),t.markHighlightsDirty(),this._notifyDirty()}}hasHighlight(e){return this._activeHighlightOptions.has(e)}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const i=this._renderManager.rctx,o=e.geometry,n=o.vertices.layoutParameters,r=f(y(n)),s=new I(i,r,o.vertices.data),a=o.indices?U.createIndex(i,35044,o.indices):null,c=new Uint16Array(o.vertices.count);for(let f=0;f<t.count;f++){const e=t.offsets[f],i=t.offsets[f+1],n=t.materialDataIndices[f];if(null!=o.indices)for(let t=e;t<i;t++){c[o.indices[t]]=n}else for(let t=e;t<i;t++)c[t]=n}const l=new I(i,w,c.buffer),m=new j(e.transform,e.toMapSpace),h=new B(i,new Map([["geometry",s],["componentIndices",l]]),a),p=new b(h,V.TRIANGLES,n,null!=a),g={cameraDepthSquared:.5,gpuMemoryEstimate:s.usedMemory+l.usedMemory+(null!=a?a.usedMemory:0)};return new u(m,p,g)}_notifyDirty(){this._renderManager.notifyDirty()}}function G(e,t){return e===t?0:0===e?2:1}const L=s();export{k as ComponentObjectCollection};
