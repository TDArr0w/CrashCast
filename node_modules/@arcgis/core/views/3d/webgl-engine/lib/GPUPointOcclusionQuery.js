/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import{disposeMaybe as e,destroyMaybe as i}from"../../../../core/maybe.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as s}from"../../../../core/accessorSupport/decorators/subclass.js";import{multiply as o,fromTranslation as n}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as h}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{j as u,a as f}from"../../../../chunks/vec32.js";import{create as a}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{RenderCategory as p}from"../../webgl.js";import c from"../../webgl/RenderNode.js";import{Pos2Locations as _}from"./DefaultVertexBufferLayouts.js";import{TaskPriority as d}from"../../../support/Scheduler.js";import{Yield as l}from"../../../support/Yield.js";import{DataType as m,PixelType as g}from"../../../webgl/enums.js";import{makePipelineState as x,defaultColorWrite as v}from"../../../webgl/renderState.js";import{Sync as y}from"../../../webgl/Sync.js";import{Texture as T}from"../../../webgl/Texture.js";import{TextureDescriptor as w}from"../../../webgl/TextureDescriptor.js";let B=class extends c{constructor(t){super(t),this.category=p.COMPOSITE,this.readyToRun=!1,this.done=!0,this._origin=a(),this._textureWidth=256,this._uploadBuffer=new Float32Array(3*this._textureWidth),this._counter=0,this._width=0,this._height=0,this._pixelBufferSize=0,this._pipeline=x({colorWrite:v}),this._format=0}initialize(){const t=this.view.resourceController.scheduler.registerTask(d.GRAPHICS_CORE,this);this.addHandles(t),this.produces="disabled",this.consumes.required=[this.category],this.formatOverride&&(this._format=this.formatOverride)}destroy(){this._program=e(this._program);const t=this.gl;this._sync=i(this._sync),this._pixelBuffer&&(t.deleteBuffer(this._pixelBuffer),this._pixelBuffer=null,this._pixelBufferSize=0),this._texture=e(this._texture)}precompile(){this._ensureProgram(this.renderingContext)}render(t){const e=t.find(({name:t})=>t===this.category);if(this._sync)return e;this.produces="disabled";const i=this.renderingContext,r=this.gl,s=e.getTexture(r.DEPTH_STENCIL_ATTACHMENT);if(!s)return e;const h=this.view.stage.renderer.fboCache.acquire(this._width,this._height,"hud visibility",9);i.bindFramebuffer(h.fbo),i.setPipelineState(this._pipeline);const u=this._ensureProgram(i);i.useProgram(u);const f=0;i.bindTexture(s,f),u.setUniform1i("depthTex",f);const a=1;return i.bindTexture(this._texture,a),u.setUniform1i("positionTex",a),o(C,this.camera.viewMatrix,n(C,this._origin)),u.setUniformMatrix4fv("view",C),u.setUniformMatrix4fv("proj",this.camera.projectionMatrix),u.setUniform1i("count",this._counter),i.screen.draw(),this._pixelBuffer||(this._pixelBuffer=r.createBuffer()),0===this._format&&(this._format=6403===r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)&&r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE)===m.FLOAT?6403:6408),this._pixelBufferSize=this._width*this._height*(6403===this._format?4:16),r.bindBuffer(r.PIXEL_PACK_BUFFER,this._pixelBuffer),r.bufferData(r.PIXEL_PACK_BUFFER,this._pixelBufferSize,r.STREAM_READ),r.readPixels(0,0,this._width,this._height,this._format,m.FLOAT,0),this._sync=new y(r),h.release(),setTimeout(()=>this.readyToRun=!0,0),e}runTask(){if(!this._sync)return void(this.readyToRun=!1);try{if(!this._sync.poll())return l}catch(e){return this.readyToRun=!1,void(this._sync=i(this._sync))}this.readyToRun=!1,this._sync=i(this._sync);const t=this.gl;t.bindBuffer(t.PIXEL_PACK_BUFFER,this._pixelBuffer),this._cpuBuffer=new Float32Array(this._width*this._height*(6403===this._format?1:4)),t.getBufferSubData(t.PIXEL_PACK_BUFFER,0,this._cpuBuffer),t.bindBuffer(t.PIXEL_PACK_BUFFER,null),this.done=!0}init(t,e){const i=this._textureWidth;if(this._width=i,this._height=Math.ceil(t/i),this._counter=0,this._texture?.dispose(),0===this._height)return;const r=new w(this._width,this._height);r.pixelFormat=6407,r.dataType=g.FLOAT,r.samplingMode=9728,this._texture=new T(this.renderingContext,r),this.done=!1,u(this._origin,Math.fround(e[0]),Math.fround(e[1]),Math.fround(e[2]))}addPosition(t){const e=this._width;if(this._counter>=e*this._height)return-1;const i=this._counter%e;return f(j,t,this._origin),this._uploadBuffer[3*i+0]=j[0],this._uploadBuffer[3*i+1]=j[1],this._uploadBuffer[3*i+2]=j[2],i===e-1&&this._flush(),this._counter++}start(){if(0===this._width||0===this._height)return;const t=this._width;this._counter%t>0&&this._flush(),this.produces=this.category,this.requestRender(1)}getOcclusion(t){return this._cpuBuffer?.[6403===this._format?t:4*t]??-1}get usedMemory(){return(this._texture?.usedMemory??0)+this._pixelBufferSize+4*(this._uploadBuffer?.length??0)+4*(this._cpuBuffer?.length??0)}_flush(){const t=this._width,e=Math.floor(this._counter/t);this._texture?.updateData(0,0,e,t,1,this._uploadBuffer)}_ensureProgram(t){return this._program??=t.programCache.acquire(P,b,_),this._program}};t([r()],B.prototype,"category",void 0),t([r()],B.prototype,"formatOverride",void 0),t([r()],B.prototype,"readyToRun",void 0),t([r()],B.prototype,"done",void 0),B=t([s("esri.views.3d.webgl-engine.lib.GPUPointOcclusionQuery")],B);const P="#version 300 es\nprecision highp float;\nin vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}",b="#version 300 es\nprecision highp float;\nout highp vec4 fragColor;\n\nuniform highp mat4 proj;\nuniform highp mat4 view;\n\nuniform highp int count;\n\nuniform highp sampler2D depthTex;\nuniform highp sampler2D positionTex;\n\nfloat linearizeDepth(float depth) {\n  float depthNdc = depth * 2.0 - 1.0;\n  float c1 = proj[3][2];\n  float c2 = proj[2][2];\n  return -c1 / (depthNdc + c2 + 1e-7);\n}\n\nvoid main() {\n  int u = int(floor(gl_FragCoord.x));\n  int v = int(floor(gl_FragCoord.y));\n  if (u + v * textureSize(positionTex, 0).x >= count) {\n    fragColor = vec4(-1);\n    return;\n  }\n  vec4 posWorld = vec4(texelFetch(positionTex, ivec2(u, v), 0).rgb, 1.0);\n\n  vec4 posView = view * posWorld;\n  vec4 projected = proj * posView;\n\n  vec3 clipPos = projected.xyz / projected.w;\n\n  if (clipPos.x < -1.0 || clipPos.x > 1.0 || clipPos.y < -1.0 || clipPos.y > 1.0) {\n    fragColor = vec4(-1);\n    return;\n  }\n\n  vec3 uvDepth = 0.5 * clipPos + vec3(0.5);\n\n  float depth = texture(depthTex, uvDepth.xy).r;\n\n  if (uvDepth.z <= depth) {\n    fragColor = vec4(0);\n    return;\n  }\n\n  fragColor = vec4(linearizeDepth(depth) - linearizeDepth(uvDepth.z));\n}\n",j=a(),C=h();export{B as GPUPointOcclusionQuery};
