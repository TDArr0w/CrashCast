/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{g as t,t as s}from"../../../../chunks/vec32.js";import{create as i}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as r,fromPoints as e,copy as n}from"../../../../geometry/support/ray.js";import a from"../../webgl/RenderCamera.js";import{HUDTarget as o,HUDIntersectorResult as h}from"./HUDIntersectorResult.js";import{IntersectorOptions as c}from"./IntersectorInterfaces.js";import{IntersectorResult as l}from"./IntersectorResult.js";import{IntersectorTransform as f,getVerticalOffsetObject3D as d}from"./verticalOffsetUtils.js";const m=1e-5;class u{constructor(t){this.options=new c,this._results=new _,this.transform=new f,this.camera=new a,this.tolerance=m,this.verticalOffset=null,this._ray=r(),this._rayEnd=i(),this._rayBeginTransformed=i(),this._rayEndTransformed=i(),this.viewingMode=t??1}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,s,i){this.resetWithRay(e(t,s,this._ray),i)}resetWithRay(s,i){this.camera=i,s!==this._ray&&n(s,this._ray),0!==this.options.verticalOffset?2===this.viewingMode?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,t(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,s,i,r,e){this.point=s,this.filterPredicate=r,this.tolerance=i??m;const n=d(this.verticalOffset);if(t&&t.length>0){const s=e?t=>{e(t)&&this.intersectObject(t)}:t=>{this.intersectObject(t)};for(const i of t){const t=i.getSpatialQueryAccelerator?.();null!=t?(null!=n?t.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,s,n):t.forEachAlongRay(this._ray.origin,this._ray.direction,s),this.options.selectionMode&&this.options.hud&&t.forEachDegenerateObject(s)):i.objects.forEach(t=>s(t))}}this.sortResults()}intersectObject(t){const i=t.geometries;if(!i)return;const r=t.effectiveTransformation,e=d(this.verticalOffset);for(const n of i){if(!n.visible)continue;const{material:i,id:a}=n;if(!i.visible)continue;this.transform.setAndInvalidateLazyTransforms(r,n.transformation),s(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),s(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const o=this.transform.transform;null!=e&&(e.objectTransform=this.transform),i.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(s,i,r,e)=>this.handleObjectIntersection({object:t,geometryId:a,primitiveIndex:r},s,i,o,e))}}handleObjectIntersection(t,s,i,r,e){if(s<0||null!=this.filterPredicate&&!this.filterPredicate(this._ray.origin,this._rayEnd,s))return;const n=e?this._results.hud:this._results;t=e?new o(t,e):t;const a=e?r=>r.set(1,t,s,i):e=>e.set(4,t,s,i,r);if((null==n.min.distance||s<n.min.distance)&&a(n.min),0!==this.options.store&&(null==n.max.distance||s>n.max.distance)&&a(n.max),2===this.options.store)if(e){const t=new h(this._ray);a(t),this._results.hud.all.push(t)}else{const t=new l(this._ray);a(t),this._results.all.push(t)}}sortResults(t=this._results.all){t.sort((t,s)=>t.distance!==s.distance?(t.distance??0)-(s.distance??0):t.drapedLayerOrder!==s.drapedLayerOrder?y(t.drapedLayerOrder,s.drapedLayerOrder):y(t.renderPriority,s.renderPriority))}}function y(t,s){return(s??-Number.MAX_VALUE)-(t??-Number.MAX_VALUE)}class _{constructor(){this.min=new l(r()),this.max=new l(r()),this.hud={min:new h(r()),max:new h(r()),all:new Array},this.ground=new l(r()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}export{u as Intersector,m as defaultTolerance};
