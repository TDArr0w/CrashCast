/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../../../../core/RandomLCG.js";import{g as e,n as o}from"../../../../../chunks/vec32.js";import{create as n}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{compressNormal as r}from"../Normals.js";import{RegularEdgeInstancesLayout as i,SilhouetteEdgeInstancesLayout as s}from"./bufferLayouts.js";const a=.7;class c{updateSettings(t){this.settings=t,this._edgeHashFunction=t.reducedPrecision?d:u}write(t,e,o){S.seed=this._edgeHashFunction(o);const n=S.getIntRange(0,255),r=S.getIntRange(0,this.settings.variants-1),i=S.getFloat(),s=255*(.5*g(-(1-Math.min(i/a,1))+Math.max(0,i-a)/(1-a),1.2)+.5);t.position0.setVec(e,o.position0),t.position1.setVec(e,o.position1),t.componentIndex.set(e,o.componentIndex),t.variantOffset.set(e,n),t.variantStroke.set(e,r),t.variantExtension.set(e,s)}}const m=new Float32Array(6),f=new Uint32Array(m.buffer),p=new Uint32Array(1);function u(t){return m[0]=t.position0[0],m[1]=t.position0[1],m[2]=t.position0[2],m[3]=t.position1[0],m[4]=t.position1[1],m[5]=t.position1[2],p[0]=31*(31*(31*(31*(31*(166811+f[0])+f[1])+f[2])+f[3])+f[4])+f[5],p[0]}function d(t){const e=m;e[0]=h(t.position0[0]),e[1]=h(t.position0[1]),e[2]=h(t.position0[2]),e[3]=h(t.position1[0]),e[4]=h(t.position1[1]),e[5]=h(t.position1[2]),p[0]=5381;for(let o=0;o<f.length;o++)p[0]=31*p[0]+f[o];return p[0]}const l=1e4;function h(t){return Math.round(t*l)/l}function g(t,e){return Math.abs(t)**e*Math.sign(t)}class w{constructor(){this._commonWriter=new c}updateSettings(t){this._commonWriter.updateSettings(t)}allocate(t){return i.createBuffer(t)}write(t,n,i){this._commonWriter.write(t,n,i),e(N,i.faceNormal0,i.faceNormal1),o(N,N);const{typedBuffer:s,typedBufferStride:a}=t.normalCompressed;r(s,n,N[0],N[1],N[2],a)}}class y{constructor(){this._commonWriter=new c}updateSettings(t){this._commonWriter.updateSettings(t)}allocate(t){return s.createBuffer(t)}write(t,e,o){this._commonWriter.write(t,e,o);{const{typedBuffer:n,typedBufferStride:i}=t.normalCompressed;r(n,e,o.faceNormal0[0],o.faceNormal0[1],o.faceNormal0[2],i)}{const{typedBuffer:n,typedBufferStride:i}=t.normal2Compressed;r(n,e,o.faceNormal1[0],o.faceNormal1[1],o.faceNormal1[2],i)}}}const N=n(),S=new t;export{w as RegularEdgeBufferWriter,y as SilhouetteEdgeBufferWriter};
