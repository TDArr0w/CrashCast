/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{generateUID as t}from"../../../../core/uid.js";import{multiply as i,copy as e,hasIdentityRotation as s}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as o,IDENTITY as r}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{l as a,t as h,k as n,j as m,g as d,q as l,d as c}from"../../../../chunks/vec32.js";import{create as g,fromValues as _}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{o as u,a as f,c as b}from"../../../../chunks/sphere.js";import{maxScale as v}from"../../support/mathUtils.js";import{Object3DOccludeeStateID as p,Object3DHighlightStateID as y}from"./Object3DStateID.js";import{assert as j}from"./Util.js";import{affectsGeometry as S}from"./VertexAttribute.js";import{addObject3DStateID as V,removeObject3DStateID as x}from"../materials/renderers/utils.js";class W{constructor(i={}){this.id=t(),this._highlightIds=new Set,this._shaderTransformation=null,this._visible=!0,this.castShadow=i.castShadow??!0,this.usesVerticalDistanceToGround=i.usesVerticalDistanceToGround??!1,this.graphicUid=i.graphicUid,this.layerViewUid=i.layerViewUid,i.isElevationSource&&(this.lastValidElevationBB=new A),this._geometries=i.geometries?Array.from(i.geometries):new Array}dispose(){this._geometries.length=0}get layer(){return this._layer}set layer(t){j(null==this._layer||null==t,"Object3D can only be added to a single Layer"),this._layer=t}addGeometry(t){t.visible=this._visible,this._geometries.push(t);for(const i of this._highlightIds)t.addHighlight(i);this._emit("geometryAdded",{object:this,geometry:t}),this._highlightIds.size&&this._emit("highlightChanged",this),this._invalidateBoundingVolume()}removeGeometry(t){const i=this._geometries.splice(t,1)[0];if(i){for(const t of this._highlightIds)i.removeHighlight(t);this._emit("geometryRemoved",{object:this,geometry:i}),this._highlightIds.size&&this._emit("highlightChanged",this),this._invalidateBoundingVolume()}}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttributeUpdated(t,i,e=!1){this._emit("attributesChanged",{object:this,geometry:t,attribute:i,sync:e}),S(i)&&this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(t){if(this._visible!==t){this._visible=t;for(const t of this._geometries)t.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new p;for(const i of this._geometries)i.occludees=V(i.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const i of this._geometries)i.occludees=x(i.occludees,t);this._emit("occlusionChanged",this)}highlight(t){const i=new y(t);for(const e of this._geometries)e.addHighlight(i);return this._emit("highlightChanged",this),this._highlightIds.add(i),i}removeHighlight(t){this._highlightIds.delete(t);for(const i of this._geometries)i.removeHighlight(t);this._emit("highlightChanged",this)}removeStateID(t){0===t.channel?this.removeHighlight(t):this.removeOcclude(t)}getCombinedStaticTransformation(t,e){return i(e,this.transformation,t.transformation)}getCombinedShaderTransformation(t,e=o()){return i(e,this.effectiveTransformation,t.transformation)}get boundingVolumeWorldSpace(){return this._bvWorldSpace||(this._bvWorldSpace=this._bvWorldSpace||new M,this._validateBoundingVolume(this._bvWorldSpace,0)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace||(this._bvObjectSpace=this._bvObjectSpace||new M,this._validateBoundingVolume(this._bvObjectSpace,1)),this._bvObjectSpace}_validateBoundingVolume(t,i){const e=1===i;for(const s of this._geometries){const i=s.boundingInfo;i&&T(i,t,e?s.transformation:this.getCombinedShaderTransformation(s))}u(t.bounds,a(U,t.min,t.max,.5));for(const s of this._geometries){const i=s.boundingInfo;if(null==i)continue;const o=e?s.transformation:this.getCombinedShaderTransformation(s),r=v(o);h(U,i.center,o);const a=n(U,f(t.bounds)),m=i.radius*r;t.bounds[3]=Math.max(t.bounds[3],a+m)}}_invalidateBoundingVolume(){const t=this._bvWorldSpace?.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this.layer&&t&&this.layer.notifyObjectBBChanged(this,t)}_emit(t,i){this.layer?.events.emit(t,i)}get geometries(){return this._geometries}get transformation(){return this._transformation??r}set transformation(t){this._transformation=e(this._transformation??o(),t),this._invalidateBoundingVolume(),this._emit("transformationChanged",this)}get shaderTransformation(){return this._shaderTransformation}set shaderTransformation(t){this._shaderTransformation=t?e(this._shaderTransformation??o(),t):null,this._invalidateBoundingVolume(),this._emit("shaderTransformationChanged",this)}get effectiveTransformation(){return this.shaderTransformation??this.transformation}get test(){}}class A{constructor(){this._data=[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]}get min(){return _(this._data[0],this._data[1],this._data[2])}get max(){return _(this._data[3],this._data[4],this._data[5])}minWith(t){const{_data:i}=this;i[0]=Math.min(i[0],t[0]),i[1]=Math.min(i[1],t[1]),i[2]=Math.min(i[2],t[2])}maxWith(t){const{_data:i}=this;i[3]=Math.max(i[3],t[0]),i[4]=Math.max(i[4],t[1]),i[5]=Math.max(i[5],t[2])}assignMinMax(t,i){for(let e=0;e<3;++e)this._data[0+e]=t[e],this._data[3+e]=i[e]}isEmpty(){return this._data[3]<this._data[0]&&this._data[4]<this._data[1]&&this._data[5]<this._data[2]}}class M extends A{constructor(){super(...arguments),this.bounds=b()}}function T(t,i,e){const o=t.bbMin,r=t.bbMax;if(s(e)){const t=m(C,e[12],e[13],e[14]);return d(B,o,t),d(O,r,t),i.minWith(B),void i.maxWith(O)}if(h(B,o,e),l(o,r))return i.minWith(B),void i.maxWith(B);h(O,r,e),i.minWith(B),i.minWith(O),i.maxWith(B),i.maxWith(O);for(let s=0;s<3;++s)c(B,o),c(O,r),B[s]=r[s],O[s]=o[s],h(B,B,e),h(O,O,e),i.minWith(B),i.minWith(O),i.maxWith(B),i.maxWith(O)}const C=g(),B=g(),O=g(),U=g();export{M as BoundingVolume,W as Object3D};
