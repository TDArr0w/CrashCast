/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../../Color.js";import{disposeMaybe as i}from"../../../../core/maybe.js";import{watch as s,syncAndInitial as o}from"../../../../core/reactiveUtils.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as l}from"../../../../core/accessorSupport/decorators/subclass.js";import{d as a}from"../../../../chunks/vec32.js";import{RenderCategory as n,InternalRenderCategory as u}from"../../webgl.js";import{glLayout as c}from"../../support/buffer/glUtil.js";import{newLayout as h}from"../../support/buffer/InterleavedLayout.js";import m from"../../webgl/RenderNode.js";import{VertexArrayObject as d}from"./VertexArrayObject.js";import{C as p}from"../../../../chunks/CutFillComposition.glsl.js";import{CutFillCompositionTechnique as f}from"../shaders/CutFillCompositionTechnique.js";import{C}from"../../../../chunks/CutFillMask.glsl.js";import{CutFillMaskTechnique as _}from"../shaders/CutFillMaskTechnique.js";import{DefaultMaterialPassParameters as g,DefaultMaterialDrawParameters as b,DefaultMaterialTechnique as q}from"../shaders/DefaultMaterialTechnique.js";import{DefaultMaterialTechniqueConfiguration as v}from"../shaders/DefaultMaterialTechniqueConfiguration.js";import{DepthStencilAttachment as T,PrimitiveType as F}from"../../../webgl/enums.js";import{noParameters as w}from"../../../webgl/NoParameters.js";import{VertexBuffer as V}from"../../../webgl/VertexBuffer.js";let P=class extends m{constructor(e){super(e),this.consumes={required:[n.OPAQUE]},this.produces=u.CUTFILL_COLOR,this._vaoCut=null,this._vaoFill=null,this._countCut=0,this._countFill=0,this._maskParameters=new C,this._cutVolumeParameters=new g,this._fillVolumeParameters=new g,this._compositeParameters=new p,this._drawParameters=new b;const t=1===e.view.state.viewingMode;this._cutVolumeTechniqueConfiguration=new v(t),this._cutVolumeTechniqueConfiguration.customDepthTest=2,this._cutVolumeTechniqueConfiguration.writeDepth=!1,this._cutVolumeTechniqueConfiguration.cullFace=1,this._cutVolumeTechniqueConfiguration.doubleSidedMode=1,this._fillVolumeTechniqueConfiguration=new v(t),this._fillVolumeTechniqueConfiguration.cullFace=2}initialize(){this.addHandles([s(()=>[this.cutColor,this.fillColor],()=>this._updateColors(),o)])}destroy(){this._vaoCut=i(this._vaoCut),this._vaoFill=i(this._vaoFill)}precompile(){this.techniques.precompile(q,this._cutVolumeTechniqueConfiguration),this.techniques.precompile(q,this._fillVolumeTechniqueConfiguration),this.techniques.precompile(_),this.techniques.precompile(f)}render(e){const i=this.techniques.get(q,this._cutVolumeTechniqueConfiguration),s=this.techniques.get(q,this._fillVolumeTechniqueConfiguration),o=this.techniques.get(_),r=this.techniques.get(f),l=e.find(({name:e})=>e===this.produces);if(!this._vaoCut||!this._vaoFill)return l;if(!(i&&s&&o.compiled&&r.compiled))return this.requestRender(1),l;const a=this.bindParameters,n=a.camera,u=n.fullViewport[2],c=n.fullViewport[3],h=this.renderingContext,m=this.fboCache,d=m.acquire(u,c,"cutfill color mask",2);d.attachDepth(l.getAttachment(T)),h.bindFramebuffer(d.fbo),h.setClearColor(0,0,0,1),h.clear(17408),h.setViewport(0,0,u,c),h.bindTechnique(o,a,w,this._maskParameters),h.setFaceCullingEnabled(!1),h.setStencilTestEnabled(!0),h.setStencilOpSeparate(1028,7680,34055,7680),h.setStencilOpSeparate(1029,7680,34056,7680),h.setDepthWriteEnabled(!1),h.bindVAO(this._vaoCut),h.setDepthTestEnabled(!0),h.setStencilWriteMask(255),h.setStencilFunction(519,0,255),h.setColorMask(!1,!1,!1,!1),h.drawArrays(F.TRIANGLES,0,this._countCut),h.setDepthTestEnabled(!1),h.setStencilWriteMask(0),h.setStencilFunction(517,0,255),h.setColorMask(!0,!1,!1,!1),h.drawArrays(F.TRIANGLES,0,this._countCut),h.bindVAO(this._vaoFill),h.setDepthTestEnabled(!0),h.setStencilWriteMask(255),h.setStencilFunction(519,0,255),h.setColorMask(!1,!0,!1,!1),h.drawArrays(F.TRIANGLES,0,this._countFill);const p=m.acquire(u,c,"cutfill color volumes",5);p.attachDepth(l.getAttachment(T)),h.bindFramebuffer(p.fbo),h.setClearColor(0,0,0,0),h.clear(16384),h.setColorMask(!0,!0,!0,!0),h.bindTechnique(i,this.bindParameters,this._cutVolumeParameters,this._drawParameters),h.setPolygonOffset(1,1),h.setPolygonOffsetFillEnabled(!0),h.bindVAO(this._vaoCut),h.drawArrays(F.TRIANGLES,0,this._countCut),h.bindTechnique(s,this.bindParameters,this._fillVolumeParameters,this._drawParameters),h.setPolygonOffset(0,0),h.setPolygonOffsetFillEnabled(!1),h.bindVAO(this._vaoFill),h.drawArrays(F.TRIANGLES,0,this._countFill);const C=this.fboCache.acquire(u,c,this.produces);return h.bindFramebuffer(C.fbo),this._compositeParameters.color=l.getTexture(),this._compositeParameters.cutFillVolumes=p.getTexture(),this._compositeParameters.cutFillMask=d.getTexture(),t.toUnitRGBA(this.borderColor,this._compositeParameters.borderColor),h.bindTechnique(r,a,this._compositeParameters),h.screen.draw(),d.release(),p.release(),C.attachDepth(l.getAttachment(T)),C}enable(){this.produces=u.CUTFILL_COLOR,this.requestRender(1)}disable(){this.produces="disabled",this.requestRender(1)}updateGeometries(e,t,s){this._vaoCut=i(this._vaoCut),this._vaoCut=this._createVao(e),this._countCut=e.indicesBottom.length+e.indicesExtruded.length,this._vaoFill=i(this._vaoFill),this._vaoFill=this._createVao(t),this._countFill=t.indicesBottom.length+t.indicesExtruded.length,this._maskParameters.origin=s,a(this._drawParameters.origin,s),this.requestRender(1)}_updateColors(){this._cutVolumeParameters.diffuse=t.toUnitRGB(this.cutColor),this._cutVolumeParameters.opacity=this.cutColor.a,this._fillVolumeParameters.diffuse=t.toUnitRGB(this.fillColor),this._fillVolumeParameters.opacity=this.fillColor.a,this.requestRender(1)}_createVao(e){const t=this.renderingContext,{vertices:i,normals:s,indicesBottom:o,indicesExtruded:r}=e,l=j.createBuffer(o.length+r.length),{position:a,normal:n}=l;for(let c=0;c<o.length;c++){const e=3*o[c];a.set(c,0,i[e]),a.set(c,1,i[e+1]),a.set(c,2,i[e+2]),n.set(c,0,s[e]),n.set(c,1,s[e+1]),n.set(c,2,s[e+2])}for(let c=0;c<r.length;c++){const e=c+o.length,t=3*r[c];a.set(e,0,i[t]),a.set(e,1,i[t+1]),a.set(e,2,i[t+2]),n.set(e,0,s[t]),n.set(e,1,s[t+1]),n.set(e,2,s[t+2])}const u=new V(t,c(j),l.buffer);return new d(t,u)}};e([r()],P.prototype,"consumes",void 0),e([r()],P.prototype,"produces",void 0),e([r()],P.prototype,"cutColor",void 0),e([r()],P.prototype,"fillColor",void 0),e([r()],P.prototype,"borderColor",void 0),P=e([l("esri.views.3d.webgl-engine.lib.CutFillColor")],P);const j=h().vec3f("position").vec3f("normal").freeze();class y{constructor(e,t,i,s){this.vertices=e,this.indicesBottom=t,this.indicesExtruded=i,this.normals=s}}export{P as CutFillColor,y as VolumeGeometry};
