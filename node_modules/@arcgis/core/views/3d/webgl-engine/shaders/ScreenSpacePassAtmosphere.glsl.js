/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{invertOrIdentity as e}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as i}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{If as r,glsl as o}from"../core/shaderModules/glsl.js";import{Matrix4BindUniform as t}from"../core/shaderModules/Matrix4BindUniform.js";function a(i,a={needUVs:!0,needEyeDirection:!0}){i.attributes.add("position","vec2"),i.varyings.add("worldRay","vec3");const{needUVs:n,needEyeDirection:c}=a;n&&i.varyings.add("uv","vec2"),c&&i.varyings.add("eyeDir","vec3"),i.vertex.uniforms.add(new t("inverseProjectionMatrix",e=>e.camera.inverseProjectionMatrix),new t("inverseViewMatrix",i=>e(s,i.camera.viewMatrix))),i.vertex.main.add(o`
    vec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1.0, 1.0)).xyz;
    ${r(c,"eyeDir = posViewNear;")}
    worldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;
    ${r(n,"uv = position * 0.5 + vec2(0.5);")}
    gl_Position = vec4(position, 1, 1);
  `)}const s=i();export{a as ScreenSpacePassAtmosphere};
