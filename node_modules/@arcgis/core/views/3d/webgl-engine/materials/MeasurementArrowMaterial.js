/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{j as t,n as e,e as r,i as s,k as o,t as i}from"../../../../chunks/vec32.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromValues as a}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{isColorOrColorEmission as c}from"../core/shaderLibrary/ShaderOutput.js";import l from"../lib/GLMaterial.js";import{Material as u,MaterialParameters as p}from"../lib/Material.js";import{MeasurementArrowTechnique as h,layout as f}from"../shaders/MeasurementArrowTechnique.js";import{MeasurementArrowTechniqueConfiguration as m}from"../shaders/MeasurementArrowTechniqueConfiguration.js";import{alphaCutoff as g}from"../../../../webscene/support/AlphaCutoff.js";class d extends u{constructor(t){super(t,w),this._configuration=new m,this.intersectDraped=void 0,this.produces=new Map([[2,t=>!this._transparent&&c(t)],[8,t=>this._transparent&&c(t)]])}getConfiguration(t,e){return super.getConfiguration(t,e,this._configuration),this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset,this._configuration.transparent=this._transparent,this._configuration.oitPass=e.oitPass,this._configuration}get visible(){const{outlineColor:t,stripeEvenColor:e,stripeOddColor:r}=this.parameters;return t[3]>=g||e[3]>=g||r[3]>=g}intersect(){}createGLMaterial(t){return new C(t)}createBufferWriter(){return new O}get _transparent(){const{parameters:t}=this;return t.outlineColor[3]<1||t.stripeEvenColor[3]<1||t.stripeOddColor[3]<1}}class C extends l{beginSlot(t){return this.getTechnique(h,t)}}class w extends p{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=a(1,.5,0,1),this.stripeEvenColor=a(1,1,1,1),this.stripeOddColor=a(1,.5,0,1),this.stripeLength=1,this.polygonOffset=!1}}const j=n(),_=n(),b=n(),v=n(),M=n();class O{constructor(){this.layout=f}elementCount(t){return 2*(t.get("position").indices.length/2+1)}write(n,a,c,l,u,p){const{data:h,indices:f}=c.get("position"),m=c.get("normal").data,g=h.length/3;f&&f.length!==2*(g-1)&&console.warn("MeasurementArrowMaterial does not support indices");const d=j,C=_,w=b,O=v,x=M,y=u.position,A=u.normal,E=u.uv0;let L=0;for(let j=0;j<g;++j){const c=3*j;if(t(d,h[c],h[c+1],h[c+2]),j<g-1){const o=3*(j+1);t(C,h[o],h[o+1],h[o+2]),t(x,m[o],m[o+1],m[o+2]),e(x,x),r(w,C,d),e(w,w),s(O,x,w),e(O,O)}const l=o(d,C);n&&a&&(i(d,d,n),i(C,C,n),i(O,O,a));const u=p+2*j,f=u+1;y.setVec(u,d),y.setVec(f,d),A.setVec(u,O),A.setVec(f,O),E.set(u,0,L),E.set(u,1,-1),E.set(f,0,L),E.set(f,1,1),j<g-1&&(L+=l)}const V=u.length;for(let t=0;t<2*g;++t)V.set(p+t,L);return null}}export{d as MeasurementArrowMaterial,w as Parameters};
