/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clamp as e,deg2rad as t}from"../../../../core/mathUtils.js";import{fromMat4 as i}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as s}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{invert as r}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as a}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{set as n,rotate as o}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{fromValues as l,create as c}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{j as u,t as f,n as p,e as h,h as m,d,b as g,k as b,g as v,a as x,o as S,f as y}from"../../../../chunks/vec32.js";import{create as O,fromValues as z}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromArray as _,create as P,freeze as j}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{isMat4 as M}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as V}from"../../../../geometry/support/aaBoundingRect.js";import{BufferViewVec4u8 as D}from"../../../../geometry/support/buffer/BufferView.js";import{evaluateModelTransformScale as R}from"../../layers/support/FastSymbolUpdates.js";import{debugFlags as A}from"../../support/debugFlags.js";import{isColorEmissionHighlightOrOID as C,isColorOrColorEmission as w}from"../core/shaderLibrary/ShaderOutput.js";import{HUDVerticalPixelOffset as F}from"../core/shaderLibrary/hud/HUD.glsl.js";import{GLTextureMaterialBindParameters as T,GLTextureMaterial as L}from"../lib/GLTextureMaterial.js";import{Material as E}from"../lib/Material.js";import{SeparateScreenSizePerspectiveEvaluators as U}from"../lib/screenSizePerspectiveUtils.js";import{assert as B}from"../lib/Util.js";import{writePosition as I,writeNormal as q,writeColor as G,writeBufferVec2 as W,writeBufferFloat as H,writeBufferVec4 as N,writeBufferVec4Zeros as X,writeOlidColor as Y}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as k}from"./internal/MaterialUtil.js";import{c as J,f as K}from"../../../../chunks/HUDMaterial.glsl.js";import{baseLayout as Q,getInstanceLayout as Z,HUDMaterialTechnique as $}from"../shaders/HUDMaterialTechnique.js";import{HUDMaterialTechniqueConfiguration as ee}from"../shaders/HUDMaterialTechniqueConfiguration.js";import{alphaCutoff as te}from"../../../../webscene/support/AlphaCutoff.js";class ie extends E{constructor(e,t){super(e,Ve),this.produces=new Map([[13,e=>C(e)&&!this.parameters.drawAsLabel],[14,e=>C(e)&&this.parameters.drawAsLabel],[12,()=>this.parameters.occlusionTest],[18,e=>this.parameters.draped&&C(e)]]),this._visible=!0,this._configuration=new ee(t)}getConfiguration(e,t){const i=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=i,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.hasVVSize=!!this.parameters.vvSize,this._configuration.hasVVColor=!!this.parameters.vvColor,this._configuration.occlusionPass=12===t.slot,this._configuration.occludedFragmentFade=!i&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||12===t.slot,w(e)&&(this._configuration.debugDrawLabelBorder=!!A.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,s,a,n,o){const{options:{selectionMode:l,hud:c,excludeLabels:v},point:x,camera:S}=s,{parameters:y}=this;if(!l||!c||v&&y.isLabel||!e.visible||!x||!S)return;const z=e.attributes.get("featureAttribute"),P=null==z?null:_(z.data,Oe),{scaleX:j,scaleY:M}=Re(P,y,S.pixelRatio);i(ge,t),e.attributes.has("featureAttribute")&&ne(ge);const V=e.attributes.get("position"),D=e.attributes.get("size"),R=e.attributes.get("normal"),A=e.attributes.get("rotation"),C=e.attributes.get("centerOffsetAndDistance");B(V.size>=3);const w=J(y),F="screen"===this.parameters.centerOffsetUnits;for(let i=0;i<V.data.length/V.size;i++){const e=i*V.size;u(ce,V.data[e],V.data[e+1],V.data[e+2]),f(ce,ce,t),f(ce,ce,S.viewMatrix);const a=i*C.size;if(u(Se,C.data[a],C.data[a+1],C.data[a+2]),!F&&(ce[0]+=Se[0],ce[1]+=Se[1],0!==Se[2])){const e=Se[2];p(Se,ce),h(ce,ce,m(Se,Se,e))}const n=i*R.size;if(u(ue,R.data[n],R.data[n+1],R.data[n+2]),ae(ue,ge,S,ze),Ae(this.parameters,ce,ze,S,le),S.applyProjection(ce,fe),fe[0]>-1){F&&(Se[0]||Se[1])&&(fe[0]+=Se[0]*S.pixelRatio,0!==Se[1]&&(fe[1]+=le.alignmentEvaluator.apply(Se[1])*S.pixelRatio),S.unapplyProjection(fe,ce)),fe[0]+=this.parameters.screenOffset[0]*S.pixelRatio,fe[1]+=this.parameters.screenOffset[1]*S.pixelRatio,fe[0]=Math.floor(fe[0]),fe[1]=Math.floor(fe[1]);const e=i*D.size;je[0]=D.data[e],je[1]=D.data[e+1],le.evaluator.applyVec2(je,je);const t=_e*S.pixelRatio;let a=0;if(y.textureIsSignedDistanceField){a=Math.min(y.outlineSize,.5*je[0])*S.pixelRatio/2}je[0]*=j,je[1]*=M;const n=i*A.size,l=y.rotation+A.data[n];if(oe(x,fe[0],fe[1],je,t,a,l,y,w)){const e=s.ray;if(f(he,ce,r(ve,S.viewMatrix)),fe[0]=x[0],fe[1]=x[1],S.unprojectFromRenderScreen(fe,ce)){const t=O();d(t,e.direction);const i=1/g(t);m(t,t,i);o(b(e.origin,ce)*i,t,-1,he)}}}}}intersectDraped(e,t,i,s,r){const a=e.attributes.get("position"),n=e.attributes.get("size"),o=e.attributes.get("rotation"),l=this.parameters,c=J(l),u=e.attributes.get("featureAttribute"),f=null==u?null:_(u.data,Oe),{scaleX:p,scaleY:h}=Re(f,l,e.screenToWorldRatio),m=Pe*e.screenToWorldRatio;for(let d=0;d<a.data.length/a.size;d++){const t=d*a.size,u=a.data[t],f=a.data[t+1],g=d*n.size;je[0]=n.data[g],je[1]=n.data[g+1];let b=0;if(l.textureIsSignedDistanceField){b=Math.min(l.outlineSize,.5*je[0])*e.screenToWorldRatio/2}je[0]*=p,je[1]*=h;const v=d*o.size,x=l.rotation+o.data[v];oe(i,u,f,je,m,b,x,l,c)&&s(r.distance,r.normal,-1)}}createBufferWriter(){return new De}applyShaderOffsetsView(e,t,i,s,r,a,n){const o=ae(t,i,r,ze);return this._applyVerticalGroundOffsetView(e,o,r,n),Ae(this.parameters,n,o,r,a),this._applyPolygonOffsetView(n,o,s[3],r,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,t,i,s,r){return this._applyCenterOffsetNDC(e,t,i,s),null!=r&&d(r,s),this._applyPolygonOffsetNDC(s,t,i,s),s}_applyPolygonOffsetView(t,i,s,r,a){const n=r.aboveGround?1:-1;let o=Math.sign(s);0===o&&(o=n);const l=n*o;if(this.parameters.shaderPolygonOffset<=0)return d(a,t);const c=e(Math.abs(i.cosAngle),.01,1),u=1-Math.sqrt(1-c*c)/c/r.viewport[2];return m(a,t,l>0?u:1/u),a}_applyVerticalGroundOffsetView(e,t,i,s){const r=g(e),a=i.aboveGround?1:-1,n=i.computeRenderPixelSizeAtDist(r)*F,o=m(ce,t.normal,a*n);return v(s,e,o),s}_applyCenterOffsetView(e,t,i){const s="screen"!==this.parameters.centerOffsetUnits;return i!==e&&d(i,e),s&&(i[0]+=t[0],i[1]+=t[1],t[2]&&(p(ue,i),x(i,i,m(ue,ue,t[2])))),i}_applyCenterOffsetNDC(e,t,i,s){const r="screen"!==this.parameters.centerOffsetUnits;return s!==e&&d(s,e),r||(s[0]+=t[0]/i.fullWidth*2,s[1]+=t[1]/i.fullHeight*2),s}_applyPolygonOffsetNDC(e,t,i,s){const r=this.parameters.shaderPolygonOffset;if(e!==s&&d(s,e),r){const e=i.aboveGround?1:-1,a=e*Math.sign(t[3]);s[2]-=(a||e)*r}return s}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:i}=this.parameters,s=e[3]>=te||t>=te&&i[3]>=te;return this._visible&&s}createGLMaterial(e){return new se(e)}calculateRelativeScreenBounds(e,t,i=V()){return re(this.parameters,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class se extends L{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique($,e)}}function re(e,t,i,s){s[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*i,s[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*i}function ae(e,t,s,r){return M(t)&&(t=i(be,t)),S(r.normal,e,t),f(r.normal,r.normal,s.viewInverseTransposeMatrix),r.cosAngle=y(pe,Me),r}function ne(e){const t=e[0],i=e[1],s=e[2],r=e[3],a=e[4],n=e[5],o=e[6],l=e[7],c=e[8],u=1/Math.sqrt(t*t+i*i+s*s),f=1/Math.sqrt(r*r+a*a+n*n),p=1/Math.sqrt(o*o+l*l+c*c);return e[0]=t*u,e[1]=i*u,e[2]=s*u,e[3]=r*f,e[4]=a*f,e[5]=n*f,e[6]=o*p,e[7]=l*p,e[8]=c*p,e}function oe(e,i,s,r,a,l,c,u,f){let p=i-a-r[0]*f[0],h=p+r[0]+2*a,m=s-a-r[1]*f[1],d=m+r[1]+2*a;const g=u.distanceFieldBoundingBox;return u.textureIsSignedDistanceField&&null!=g&&(p+=r[0]*g[0],m+=r[1]*g[1],h-=r[0]*(1-g[2]),d-=r[1]*(1-g[3]),p-=l,h+=l,m-=l,d+=l),n(de,i,s),o(me,e,de,t(c)),me[0]>p&&me[0]<h&&me[1]>m&&me[1]<d}const le=new U,ce=O(),ue=O(),fe=P(),pe=O(),he=O(),me=c(),de=c(),ge=s(),be=s(),ve=a(),xe=P(),Se=O(),ye=O(),Oe=P(),ze={normal:pe,cosAngle:0},_e=1,Pe=2,je=l(0,0),Me=z(0,0,1);class Ve extends T{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1,this.color=j(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=l(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=j(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=P(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}class De{constructor(){this.layout=Q,this.instanceLayout=Z()}elementCount(e){return e.get("position").indices.length}elementCountBaseInstance(e){return e.get("uv0").indices.length}write(e,t,i,s,r,a){const{position:n,normal:o,color:l,size:c,rotation:u,centerOffsetAndDistance:f,featureAttribute:p,uvi:h}=r;I(i.get("position"),e,n,a),q(i.get("normal"),t,o,a);const m=i.get("position").indices.length;let d=0,g=0,b=K,v=K;const x=i.get("uvi")?.data;x&&x.length>=4&&(d=x[0],g=x[1],b=x[2],v=x[3]);for(let S=0;S<m;++S){const e=a+S;h.setValues(e,d,g,b,v)}if(G(i.get("color"),4,l,a),W(i.get("size"),c,a),H(i.get("rotation"),u,a),i.get("centerOffsetAndDistance")?N(i.get("centerOffsetAndDistance"),f,a):X(f,a,m),i.get("featureAttribute")?N(i.get("featureAttribute"),p,a):X(p,a,m),null!=s){const e=i.get("position")?.indices;if(e){const t=e.length,i=r.getField("olidColor",D);Y(s,i,t,a)}}return{numVerticesPerItem:1,numItems:m}}writeBaseInstance(e,t){const{uv0:i}=t;W(e.get("uv0"),i,0)}intersect(e,t,i,s,a,n,o){const{options:{selectionMode:l,hud:c,excludeLabels:x},point:S,camera:y}=s;if(!l||!c||x&&t.isLabel||!S)return;const z=this.instanceLayout.createView(e),{position:_,normal:P,rotation:j,size:M,featureAttribute:V,centerOffsetAndDistance:D}=z,R="screen"===t.centerOffsetUnits,A=J(t);if(null==_||null==P||null==j||null==M||null==D||null==y)return;const C=null==V?null:V.getVec(0,Oe),{scaleX:w,scaleY:F}=Re(C,t,y.pixelRatio),T=_.count;for(let L=0;L<T;L++){if(_.getVec(L,ce),null!=i&&v(ce,ce,i),f(ce,ce,y.viewMatrix),D.getVec(L,xe),u(Se,xe[0],xe[1],xe[2]),!R&&(ce[0]+=Se[0],ce[1]+=Se[1],0!==Se[2])){const e=Se[2];p(Se,ce),h(ce,ce,m(Se,Se,e))}if(P.getVec(L,ue),ae(ue,ge,y,ze),Ae(t,ce,ze,y,le),y.applyProjection(ce,fe),fe[0]>-1){R&&(Se[0]||Se[1])&&(fe[0]+=Se[0]*y.pixelRatio,0!==Se[1]&&(fe[1]+=le.alignmentEvaluator.apply(Se[1])*y.pixelRatio),y.unapplyProjection(fe,ce)),fe[0]+=t.screenOffset[0]*y.pixelRatio,fe[1]+=t.screenOffset[1]*y.pixelRatio,fe[0]=Math.floor(fe[0]),fe[1]=Math.floor(fe[1]),M.getVec(L,je),le.evaluator.applyVec2(je,je);const e=_e*y.pixelRatio;let i=0;if(t.textureIsSignedDistanceField){i=Math.min(t.outlineSize,.5*je[0])*y.pixelRatio/2}je[0]*=w,je[1]*=F;const a=j.get(L),n=t.rotation+a;if(oe(S,fe[0],fe[1],je,e,i,n,t,A)){const e=s.ray;if(f(he,ce,r(ve,y.viewMatrix)),fe[0]=S[0],fe[1]=S[1],y.unprojectFromRenderScreen(fe,ce)){const t=O();d(t,e.direction);const i=1/g(t);m(t,t,i);o(b(e.origin,ce)*i,t,L,he)}}}}}}function Re(e,t,i){return null==e||null==t.vvSize?{scaleX:i,scaleY:i}:(R(ye,t,e),{scaleX:ye[0]*i,scaleY:ye[1]*i})}function Ae(e,t,i,s,r){if(!e.verticalOffset?.screenLength){const s=g(t);return r.update(i.cosAngle,s,e.screenSizePerspective,e.screenSizePerspectiveMinPixelReferenceSize,e.screenSizePerspectiveAlignment,null),t}const a=g(t),n=e.screenSizePerspectiveAlignment??e.screenSizePerspective,o=k(s,a,e.verticalOffset,i.cosAngle,n,e.screenSizePerspectiveMinPixelReferenceSize);return r.update(i.cosAngle,a,e.screenSizePerspective,e.screenSizePerspectiveMinPixelReferenceSize,e.screenSizePerspectiveAlignment,null),m(i.normal,i.normal,o),v(t,t,i.normal)}export{ie as HUDMaterial,Ve as Parameters};
