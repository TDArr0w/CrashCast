/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../../../core/Accessor.js";import{removeUnordered as s,filterInPlace as n}from"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import{getOrCreateMapValue as r}from"../../../../../core/MapUtils.js";import{NestedMap as o}from"../../../../../core/NestedMap.js";import a from"../../../../../core/PooledArray.js";import{nullUid as i}from"../../../../../core/uid.js";import{property as l}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/Logger.js";import{subclass as c}from"../../../../../core/accessorSupport/decorators/subclass.js";import{assert as u}from"../../lib/Util.js";import{BufferRange as d,mergeAdjacentRanges as f}from"./BufferRange.js";import{Instance as h}from"./Instance.js";import{PerBaseInstanceData as m}from"./PerBaseInstanceData.js";import{PerBufferData as p,getTargetBuffer as g,hasVao as y}from"./PerBufferData.js";import{PerOriginData as v}from"./PerOriginData.js";import{VaoWriter as _}from"./VaoWriter.js";let B=class extends t{constructor(e){super(e),this._vaoWriter=null,this._useMetalWorkaround=!1,this._hasOccludees=!1}destroy(){this.uninitializeRenderContext()}initializeRenderContext(e){this._useMetalWorkaround=e.renderContext.rctx.isAssumedMetalDriver,this._vaoWriter=new _(this.material,e.renderContext.rctx)}uninitializeRenderContext(){this._useMetalWorkaround=!1,this._vaoWriter=null}get hasOccludees(){return this._hasOccludees}modify(e,t){this._applyUpdates(e,t),this._applyAddsAndRemoves(e),this._updateDrawCommands()}get canCompact(){for(const e of this.dataByBaseInstance.values())for(const t of e.dataByOrigin.values())if(t.buffers.some(e=>e.holes.length>1))return!0;return!1}compact(e){if(!this.canCompact)return!1;let t=!1;for(const n of this.dataByBaseInstance.values())for(const r of n.dataByOrigin.values()){const o=new Array;for(let t=0;t<r.buffers.length&&!e.done;){const n=r.buffers[t];n.holes.length<=1?++t:(n.instances.forEach(({geometry:e})=>o.push(e)),this._vaoWriter?.deleteBuffer(n),s(r.buffers,n,void 0,{last:t}),e.madeProgress())}if(o.length>0){const{baseInstanceData:e}=n;r.buffers.forEach(t=>this._applyAdds(e,t,o));const s=g(null!=e);for(;o.length>0;)r.buffers.push(this._applyAndRebuild(e,new p(s),o,null));t=!0}}return t}updateHighlights(e){this.highlightOrderMap=e;for(const t of this.dataByBaseInstance.values())for(const s of t.dataByOrigin.values())for(const t of s.buffers)t.updateHighlights(e)}_applyUpdates(e,t){const n=this._vaoWriter;if(null==n)return void e.clearUpdates();let r;const o=this._useMetalWorkaround?(e,t)=>{r??=new Map;let s=r.get(t);s||(s=[],r.set(t,s)),s.push(e)}:(e,t)=>n.updateInstance(e,t);for(const a of e.updates){if(t.done)return;const{renderGeometry:n,updateType:r}=a;s(e.pending.updates,a),t.madeProgress();const l=this.dataByBaseInstance.get(n.geometry.baseGeometry?.id??i),c=l?.dataByOrigin.get(n.localOrigin.id)?.findBuffer(n.id);if(null==c)return;const u=c.instances.get(n.id);6&r&&o(u,c),25&r&&(c.drawCommandsDirty=!0)}r&&n.updateInstancesMetal(r)}_computeDeltas(e,t){const s=new Map;for(const n of e){const e=n.localOrigin;if(null==e)continue;const t=n.geometry.baseGeometry,o=r(s,t??null,M);let a=o.get(e,null);null==a&&(a=new b(e.vec3,t),o.set(e,null,a)),a.changes.push(n)}for(const n of t){const e=n.localOrigin;if(null==e)continue;const t=n.geometry.baseGeometry,o=this.dataByBaseInstance.get(t?.id??i),a=o?.dataByOrigin.get(e.id)?.findBuffer(n.id);if(null==a)continue;const l=r(s,t??null,M);let c=l.get(e,a);null==c&&(c=new b(e.vec3,t),l.set(e,a,c)),c.changes.push(n)}return s}_applyAddsAndRemoves(e){const{_vaoWriter:t,dataByBaseInstance:n}=this;if(null==t)return void e.clearAddsAndRemoves();const o=this._computeDeltas(e.adds,e.removes);for(const[a,l]of o){const e=r(n,a?.id??i,()=>new m(t.createBaseInstanceData(a))),o=null!=a;for(const[n,a]of l.outerMap()){const i=a.get(null),c=i?.changes??[];l.delete(n,null);const d=r(e.dataByOrigin,n.id,()=>new v(n.vec3,o));for(const[r,o]of a){if(l.delete(n,r),null==r&&u(!1,"No VAO for removed geometries"),r.instances.size===o.changes.length){t.deleteBuffer(r),s(d.buffers,r),0===d.buffers.length&&0===c.length&&e.dataByOrigin.delete(n.id);continue}const a=r.numElements;switch(t.evaluateBufferAllocation(a,c,o.changes,r)){case 0:o.changes.forEach(({id:e})=>r.deleteInstance(e)),r.instances.forEach(({geometry:e})=>c.push(e)),t.deleteBuffer(r),s(d.buffers,r);break;case 1:this._applyAndRebuild(e.baseInstanceData,r,c,o);break;case 2:this._applyRemoves(r,o)}}if(c.length>0){const{baseInstanceData:t}=e,s=g(o);for(const e of d.buffers)this._applyAdds(t,e,c);for(;c.length>0;)d.buffers.push(this._applyAndRebuild(t,new p(s),c,null))}}0===e.dataByOrigin.size&&(e.dispose(),n.delete(e.id))}e.clearAddsAndRemoves()}_updateDrawCommands(){this._hasOccludees=!1;for(const e of this.dataByBaseInstance.values())for(const t of e.dataByOrigin.values())for(const e of t.buffers)e.updateIfDrawCommandsDirty(this.highlightOrderMap),this._hasOccludees||=e.hasOccludees}_applyAndRebuild(e,t,s,n){if(n)for(const c of n.changes)t.deleteInstance(c.id);const r=this._vaoWriter,o=r.maxElements(t.targetBuffer);let a=t.numElements;for(;s.length>0;){const e=s.pop(),n=r.elementCount(e.geometry);if(a+n>o&&a>0){s.push(e);break}a+=n;const i=new h(e,0,0,this.highlightOrderMap);u(null==t.instances.get(e.id)),t.addInstance(e.id,i)}t.resetInstanceSummary(),t.vao=r.reallocateBuffer(e,t,a),t.vaoEndElement=r.endElement(t);const i=r.rebuildInstances(a,t.writeableInstances.values(),t);t.updateInstances(),t.holes.clear();const l=t.holes.pushNew();return l.from=i,l.to=t.vaoEndElement,t.updateDrawCommands(this.highlightOrderMap),t}_applyRemoves(e,t){const{_vaoWriter:s}=this;if(0===t.changes.length||null==s)return;let n=1/0,r=-1/0;for(const o of t.changes){const t=o.id,s=e.instances.get(t);if(!s)continue;e.deleteInstance(t),this._useMetalWorkaround&&(n=Math.min(n,s.from),r=Math.max(r,s.to));const a=I.back();if(a){if(a.to===s.from){a.to=s.to;continue}if(a.from===s.to){a.from=s.from;continue}}const i=I.pushNew();i.from=s.from,i.to=s.to}f(I),this._useMetalWorkaround?s.clearHolesMetal(e.instances.values(),n,r,e):s.clearHoles(I,e),e.holes.pushArray(I.data,I.length),I.forAll((e,t)=>I.data[t]=null),I.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t,s){if(0===s.length||null==this._vaoWriter)return;if(!y(t))return void this._applyAndRebuild(e,t,s,null);const r=this._vaoWriter,o=t.numElements,a=s.reduce((e,{geometry:t})=>e+r.elementCount(t),0),i=Math.min(o+a,r.maxElements(t.targetBuffer));if(r.canGrow(t,i))return void this._applyAndRebuild(e,t,s,null);f(t.holes);const l=new Array;let c=1/0,u=-1/0;for(const{geometry:n}of s){const e=r.elementCount(n),s=w(t.holes,e);l.push(s),this._useMetalWorkaround&&null!=s&&(c=Math.min(s,c),u=Math.max(s+e,u))}const d=this._addInstances(s,t,l);if(this._useMetalWorkaround){for(const e of d);r.writeInstanceRangeMetal(u,c,t.instances.values(),t)}else r.writeRandomInstances(i,d,t);n(s,(e,t)=>null==l[t])}*_addInstances(e,t,s){const n=e.length,r=this._vaoWriter;for(let o=0;o<n;++o){const n=s[o];if(null==n)continue;const a=e[o],i=r.elementCount(a.geometry),l=new h(a,n,n+i,this.highlightOrderMap);u(null==t.instances.get(a.id)),t.addInstance(a.id,l),t.drawCommandsDirty=!0,yield l}}static prune(){_.prune()}};e([l({constructOnly:!0})],B.prototype,"dataByBaseInstance",void 0),e([l({constructOnly:!0})],B.prototype,"material",void 0),e([l()],B.prototype,"highlightOrderMap",void 0),B=e([c("esri.views.3d.webgl-engine.materials.renderers.MergedBuffer")],B);class b{constructor(e,t){this.origin=e,this.baseInstance=t,this.changes=new Array}}function w(e,t){const s=e.find(e=>e.numElements>=t);if(null==s)return null;const n=s.from;return s.from+=t,s.from>=s.to&&e.removeUnordered(s),n}const I=new a({allocator:e=>e||new d,deallocator:null});function M(){return new o}export{B as MergedBuffer};
