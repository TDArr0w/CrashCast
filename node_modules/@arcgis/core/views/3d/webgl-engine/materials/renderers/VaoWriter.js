/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{nextHighestPowerOfTwo as t}from"../../../../../core/mathUtils.js";import{copy as e,invert as r,transpose as a}from"../../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as o}from"../../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{glLayout as s}from"../../../support/buffer/glUtil.js";import{assert as n}from"../../lib/Util.js";import{VertexArrayObject as i}from"../../lib/VertexArrayObject.js";import{DrawCommand as f}from"./DrawCommand.js";import{BaseInstanceData as u}from"./PerBaseInstanceData.js";import{VertexBuffer as c}from"../../../../webgl/VertexBuffer.js";class l{constructor(t,e){this._rctx=e,this._bufferWriter=t.createBufferWriter(),this._vaoCache=e.getVaoCache(s(this._bufferWriter.layout))}maxElements(t){return Math.floor(d/this._targetStrideFloats(t))}_targetStrideFloats(t){return this._targetStrideBytes(t)/4}_targetStrideBytes(t){return this._targetLayout(t)?.stride??0}_targetLayout(t){return"geometry"===t?this._bufferWriter.layout:this._bufferWriter.instanceLayout}endElement(t){return Math.floor((t.vao?.getByteLength(t.targetBuffer)??0)/this._targetStrideBytes(t.targetBuffer))}evaluateBufferAllocation(t,e,r,a){const o=this._targetStrideFloats(a.targetBuffer),s=e.reduce((t,{geometry:e})=>t+this.elementCount(e),0),n=r.reduce((t,{geometry:e})=>t+this.elementCount(e),0),i=Math.min((t+s-n)*o,d),f=a.vao?.buffer(a.targetBuffer),u=(f?.sizeBytes??0)/4;return i>h&&i<u/2?0:i>u?1:2}deleteBuffer(t){if("instances"===t.targetBuffer)return t.instancedCommandVAOs?.dispose(),t.vao?.buffer("instances")?.dispose(),t.vao?.disposeVAOOnly(),void(t.vao=null);this._vaoCache.deleteVao(t.vao)}createBaseInstanceData(t){const{_bufferWriter:e}=this;if(null==t||null==e.writeBaseInstance||null==e.elementCountBaseInstance)return null;const r=e.layout,a=e.elementCountBaseInstance(t.attributes),o=a*this._targetStrideFloats("geometry"),n=new c(this._rctx,s(r));n.setSize(Math.ceil(4*o));const i=w(o),l=r.createView(i.buffer);e.writeBaseInstance(t.attributes,l),n.setSubData(i,0,0,o);const m=new f;return m.first=0,m.count=a,new u(t,n,m)}_allocateInstanceBuffer(t){const e=this._bufferWriter.instanceLayout;n(null!=e,"Trying to allocate an instance buffer, but the BufferWriter does not support instancing");const r=t*this._targetStrideFloats("instances"),a=new c(this._rctx,s(e,1));return a.setSize(S(r)),a}_createInstancedVao(t,e){return new i(this._rctx,new Map([["geometry",t],["instances",e]]))}reallocateBuffer(t,e,r){if(this.deleteBuffer(e),null!=t){const e=t.baseInstanceBuffer,a=this._allocateInstanceBuffer(r);return this._createInstancedVao(e,a)}const a=r*this._targetStrideFloats("geometry");return this._vaoCache.newVao(S(a))}elementCount(t){return this._bufferWriter.elementCount(t.attributes)}canGrow(t,e){const{targetBuffer:r,vao:a}=t;if(null==a)return!0;const o=4*(e*this._targetStrideFloats(r));return a.getByteLength(r)<S(d-h)&&o>a.getByteLength(r)}clearHoles(t,{vao:e,targetBuffer:r}){const a=this._targetStrideFloats(r),o=t.reduce((t,e)=>Math.max(t,e.numElements),0)*a,s=w(o);s.fill(0,0,o);const n=e.buffer(r);for(const i of t)n?.setSubData(s,i.from*a,0,i.numElements*a)}clearHolesMetal(t,e,r,{vao:a,targetBuffer:o}){const s=this._targetStrideFloats(o),n=(r-e)*s,i=w(n),f=this._targetLayout(o).createView(i.buffer);i.fill(0,0,n);for(const u of t){if(!(u.from>=e&&u.to<=r))continue;const t=u.from-e;this._writeGeometry(u.geometry,f,t)}a.buffer(o)?.setSubData(i,e*s,0,n)}writeRandomInstances(t,e,{vao:r,targetBuffer:a}){const o=this._targetStrideFloats(a),s=w(t*o),n=this._targetLayout(a).createView(s.buffer);let i=0,f=0,u=0;const c=r.buffer(a);for(const m of e){if(!(u===m.from)){const t=u-f;t>0&&c?.setSubData(s,f*o,0,t*o),f=m.from,i=0}this._writeGeometry(m.geometry,n,i),i+=m.numElements,u=m.to}const l=u-f;l>0&&c?.setSubData(s,f*o,0,l*o)}writeInstanceRangeMetal(t,e,r,{vao:a,targetBuffer:o}){const s=this._targetStrideFloats(o),n=t-e,i=n*s,f=w(i),u=this._targetLayout(o).createView(f.buffer);f.fill(0,0,i);for(const c of r){if(!(c.from>=e&&c.to<=t))continue;const r=c.from-e;this._writeGeometry(c.geometry,u,r)}n>0&&a.buffer(o)?.setSubData(f,e*s,0,i)}rebuildInstances(t,e,{vao:r,targetBuffer:a}){const o=this._targetStrideFloats(a),s=w(t*o),n=this._targetLayout(a).createView(s.buffer);let i=0;for(const f of e){this._writeGeometry(f.geometry,n,i);const t=i;i+=this.elementCount(f.geometry.geometry),f.from=t,f.to=i}return r?.buffer(a)?.setSubData(s,0,0,i*o),i}updateInstance(t,{vao:e,targetBuffer:r}){const{_bufferWriter:a}=this,o=this._targetStrideFloats(r),s=w(a.elementCount(t.geometry.geometry.attributes)*o),n=this._targetLayout(r).createView(s.buffer);this._writeGeometry(t.geometry,n,0),e.buffer(r)?.setSubData(s,t.from*o,0,t.numElements*o)}updateInstancesMetal(t){for(const[e,r]of t){let t=1/0,a=-1/0;for(const e of r)t=Math.min(t,e.from),a=Math.max(a,e.to);this.writeInstanceRangeMetal(a,t,e.instances.values(),e)}}_writeGeometry(t,o,s){const{_bufferWriter:n}=this;null!=n&&(e(m,t.transformation),m[12]-=t.localOrigin.vec3[0],m[13]-=t.localOrigin.vec3[1],m[14]-=t.localOrigin.vec3[2],r(g,m),a(g,g),n.write(m,g,t.geometry.attributes,t.geometry.olidColor,o,s))}static prune(){B=new Float32Array(h)}}const m=o(),g=o(),h=65536,_=4*h,y=1024,b=16777216,d=b/4;let B=new Float32Array(h);function w(t){return B.length<t&&(B=new Float32Array(t)),B}function S(e){const r=4*e;return r<=y?y:r<_?t(r):Math.max(Math.min(Math.ceil(1.5*r/_)*_,b),r)}export{l as VaoWriter};
