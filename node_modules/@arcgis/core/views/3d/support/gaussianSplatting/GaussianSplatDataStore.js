/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{reallocGrowthFactor as e}from"../../../../core/arrayUtils.js";import"../../../../core/has.js";import{signal as s}from"../../../../core/signal.js";import{makeScheduleFunction as t}from"../../layers/support/makeScheduleFunction.js";import{GaussianSplatSortWorkerHandle as r}from"../GaussianSplatWorkerHandle.js";import{GaussianSplatOrderTexture as i}from"./GaussianSplatOrderTexture.js";import{GaussianSplatTextureAtlas as a}from"./GaussianSplatTextureAtlas.js";class n{constructor(e){this._updating=s(!1),this.visibleGaussians=0,this._visibleGaussianTiles=new Array,this._workerHandle=null,this._isSorting=!1,this._pendingSortTask=!1,this._bufferCapacity=0,this._renderer=e,this._orderTexture=new i(this._renderer.renderingContext),this._textureAtlas=new a(this._renderer.renderingContext,this._renderer.view.resourceController.memoryController,this._renderer.fboCache);const{resourceController:n}=this._renderer.view;this._workerHandle=new r(t(n))}get textureAtlas(){return this._textureAtlas}get orderTexture(){return this._orderTexture}get visibleGaussianTiles(){return this._visibleGaussianTiles}updateGaussianVisibility(e){this._visibleGaussianTiles=e,this.requestSort()}isUpdating(){return this._updating.value}destroy(){this._pendingSortTask=!1,this._workerHandle?.destroyWorkerAndSelf(),this._textureAtlas.destroy(),this._orderTexture.destroy()}requestSort(){this._updating.value=!0,this._isSorting?this._pendingSortTask=!0:(this._isSorting=!0,this._pendingSortTask=!1,this._sortOnWorker().then(()=>this._handleSortComplete()).catch(()=>this._handleSortComplete()))}_handleSortComplete(){this._isSorting=!1,this._pendingSortTask?this.requestSort():this._updating.value=!1}_clearBuffersAndTextures(){this._bufferCapacity=0,this._orderTexture.clear(),this._textureAtlas.clear()}_ensureBufferCapacity(s){if(this._bufferCapacity<s){const t=Math.ceil(s*e);this._atlasIndicesBuffer=new Uint32Array(t),this._sortedAtlasIndicesBuffer=new Uint32Array(t),this._distancesBuffer=new Float64Array(t),this._sortOrderBuffer=new Uint32Array(t),this._bufferCapacity=t}}async _sortOnWorker(){let e=0;if(this._visibleGaussianTiles.forEach(s=>e+=s.gaussianAtlasIndices.length),0===e)return this.visibleGaussians=0,this._clearBuffersAndTextures(),void this._renderer.requestRender(1);this._ensureBufferCapacity(e),this._textureAtlas.ensureTextureAtlas();const s=this._renderer.camera.eye,t=s[0],r=s[1],i=s[2],a=this._atlasIndicesBuffer.subarray(0,e);let n=0;this._visibleGaussianTiles.forEach(e=>{const s=e.gaussianAtlasIndices,o=e.positions;for(let u=0;u<s.length;u++){a[n]=s[u];const e=3*u,h=o[e],l=o[e+1],d=o[e+2],_=h-t,f=l-r,c=d-i;this._distancesBuffer[n]=_*_+f*f+c*c,n++}});for(let u=0;u<e;u++)this._sortOrderBuffer[u]=u;const o={distances:this._distancesBuffer,sortOrderIndices:this._sortOrderBuffer,numGaussians:e,preciseSort:!1};await(this._workerHandle?.sort(o).then(s=>{this._distancesBuffer=s.distances,this._sortOrderBuffer=s.sortedOrderIndices;const t=this._sortedAtlasIndicesBuffer.subarray(0,e);for(let i=0;i<e;i++)t[i]=a[s.sortedOrderIndices[i]];this._orderTexture.setData(t,e);const r=this._renderer.view.qualitySettings.gaussianSplat.maxAllowedVisibleGaussians;this.visibleGaussians=Math.min(e,r),this._renderer.requestRender(1)}))}}export{n as GaussianSplatDataStore};
