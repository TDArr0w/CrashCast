/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{reallocGrowthFactor as t}from"../../../../core/arrayUtils.js";import"../../../webgl/BufferObject.js";import{FramebufferObject as e}from"../../../webgl/FramebufferObject.js";import"../../../webgl/Program.js";import"../../../../core/has.js";import"../../../webgl/Renderbuffer.js";import{Texture as r}from"../../../webgl/Texture.js";import"../../../../core/Logger.js";import{PixelType as s,SizedPixelFormat as a}from"../../../webgl/enums.js";import"../../../webgl/checkWebGLError.js";import{initialSplatAtlasTextureHeight as i,GaussianSplatAtlasPages as o,splatAtlasTextureWidth as l,elementsPerSplatPage as h}from"./GaussianSplatAtlasPages.js";import{TextureDescriptor as u}from"../../../webgl/TextureDescriptor.js";class p{constructor(t,e,r){this._splatAtlasTextureHeight=i,this.texture=null,this._rctx=t,this._fboCache=r,this.pageAllocator=new o,this._cache=e.newCache("gaussian texture cache",t=>t.dispose())}ensureTextureAtlas(){if(this.texture)return;const t=this._cache.pop("splatTextureAtlas");if(t)return void(this.texture=t);const e=new u;e.height=this._splatAtlasTextureHeight,e.width=l,e.pixelFormat=36249,e.dataType=s.UNSIGNED_INT,e.internalFormat=a.RGBA32UI,e.samplingMode=9728,e.wrapMode=33071,this.texture=new r(this._rctx,e),this._updatePageAllocator()}grow(){if(!this.texture)return this.ensureTextureAtlas(),!1;const r=Math.floor(this._splatAtlasTextureHeight*t);if(r*l>this._rctx.parameters.maxPreferredTexturePixels)return!1;const s=new e(this._rctx,this.texture),a=this._fboCache.acquire(l,r,"gaussian splat atlas resize",11);return this._rctx.blitFramebuffer(s,a.fbo,16384,9728,0,0,l,this._splatAtlasTextureHeight,0,0,l,this._splatAtlasTextureHeight),this.texture?.dispose(),this.texture=a.fbo?.detachColorTexture(),s.dispose(),a.dispose(),this._splatAtlasTextureHeight=r,this._updatePageAllocator(),!0}requestPage(){let t=this.pageAllocator.findFirstFreePage();return null===t&&this.grow()&&(t=this.pageAllocator.findFirstFreePage()),null!==t&&this.pageAllocator.allocate(t),t}freePage(t){this.pageAllocator.free(t)}update(t,e,r){this.ensureTextureAtlas(),this.texture.updateData(0,t,e,h,1,r)}_updatePageAllocator(){const t=l*this._splatAtlasTextureHeight/h;this.pageAllocator.pageCount!==t&&this.pageAllocator.resize(t)}clear(){this.texture&&(this._cache.put("splatTextureAtlas",this.texture),this.texture=null)}destroy(){this._cache.destroy(),this.texture?.dispose()}}export{p as GaussianSplatTextureAtlas};
