/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{fromQuat as t,scale as a}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{create as e}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{create as s}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{set as i,conjugate as r,multiply as n}from"../../../core/libs/gl-matrix-2/math/quat.js";import{IDENTITY as o,create as h}from"../../../core/libs/gl-matrix-2/factories/quatf64.js";import{j as c,v as d,w as _,x as m,y as f,o as u,g as l,h as g,a as p,z as M,A as b,b as j,c as S,B as z,C as y}from"../../../chunks/vec32.js";import{ZEROS as x,freeze as C,create as q,UNIT_Z as Q}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{t as v}from"../../../chunks/vec42.js";import{create as A}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{getReferenceEllipsoid as P}from"../../../geometry/ellipsoidUtils.js";import{getSphericalPCPF as w}from"../../../geometry/spatialReferenceEllipsoidUtils.js";import{computeTranslationToOriginAndRotation as R}from"../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectBuffer as D}from"../../../geometry/projection/projectBuffer.js";import{getProjector as H}from"../../../geometry/projection/projectors.js";import{getNormal as B}from"../../../geometry/support/plane.js";import{isPlateCarree as F}from"../../../geometry/support/spatialReferenceUtils.js";import{sv3d as W,sq4d as k}from"../../../geometry/support/vectorStacks.js";import{computeOBB as U}from"./dito.js";import{Vertices as Z}from"../webgl-engine/lib/Attribute.js";class G{constructor(t=x,a=lt,e=o){this._data=[t[0],t[1],t[2],a[0],a[1],a[2],e[0],e[1],e[2],e[3]]}clone(){return G.fromData(this._data)}invalidate(){this._data[3]=-1}get isValid(){return this._data[3]>=0}static fromData(t){const a=new G;return a._copyFromData(t),a}static fromJSON(t){return new G(t.center,t.halfSize,t.quaternion)}copy(t){this._copyFromData(t.data)}_copyFromData(t){for(let a=0;a<10;++a)this._data[a]=t[a]}get center(){return c(W.get(),this._data[0],this._data[1],this._data[2])}get centerX(){return this._data[0]}get centerY(){return this._data[1]}get centerZ(){return this._data[2]}getCenter(t){return t[0]=this._data[0],t[1]=this._data[1],t[2]=this._data[2],t}set center(t){this._data[0]=t[0],this._data[1]=t[1],this._data[2]=t[2]}setCenter(t,a,e){this._data[0]=t,this._data[1]=a,this._data[2]=e}get halfSize(){return c(W.get(),this._data[3],this._data[4],this._data[5])}get halfSizeX(){return this._data[3]}get halfSizeY(){return this._data[4]}get halfSizeZ(){return this._data[5]}getHalfSize(t){return t[0]=this._data[3],t[1]=this._data[4],t[2]=this._data[5],t}set halfSize(t){this._data[3]=t[0],this._data[4]=t[1],this._data[5]=t[2]}get quaternion(){return i(k.get(),this._data[6],this._data[7],this._data[8],this._data[9])}getQuaternion(t){return t[0]=this._data[6],t[1]=this._data[7],t[2]=this._data[8],t[3]=this._data[9],t}set quaternion(t){this._data[6]=t[0],this._data[7]=t[1],this._data[8]=t[2],this._data[9]=t[3]}get data(){return this._data}getCorners(t){const a=this._data,e=i(I,a[6],a[7],a[8],a[9]);for(let s=0;s<8;++s){const i=t[s];i[0]=(1&s?-1:1)*a[3],i[1]=(2&s?-1:1)*a[4],i[2]=(4&s?-1:1)*a[5],d(i,i,e),i[0]+=a[0],i[1]+=a[1],i[2]+=a[2]}}doesIntersectFrustumConservativeApproximation(t){return this.intersectPlane(t[0])<=0&&this.intersectPlane(t[1])<=0&&this.intersectPlane(t[2])<=0&&this.intersectPlane(t[3])<=0&&this.intersectPlane(t[4])<=0&&this.intersectPlane(t[5])<=0}get radius(){const t=this._data[3],a=this._data[4],e=this._data[5];return Math.sqrt(t*t+a*a+e*e)}intersectSphere(t){X[0]=this._data[0]-t[0],X[1]=this._data[1]-t[1],X[2]=this._data[2]-t[2];const a=this.getQuaternion(O);return r(I,a),d(X,X,I),_(X,X),Y[0]=Math.min(X[0],this._data[3]),Y[1]=Math.min(X[1],this._data[4]),Y[2]=Math.min(X[2],this._data[5]),m(Y,X)<t[3]*t[3]}intersectSphereWithMBS(t,a=this.radius){const e=this._data;X[0]=e[0]-t[0],X[1]=e[1]-t[1],X[2]=e[2]-t[2];const s=t[3],i=s+a;return!(f(X)>i*i)&&(I[0]=-e[6],I[1]=-e[7],I[2]=-e[8],I[3]=e[9],d(X,X,I),_(X,X),Y[0]=Math.min(X[0],e[3]),Y[1]=Math.min(X[1],e[4]),Y[2]=Math.min(X[2],e[5]),m(Y,X)<s*s)}intersectPlane(t){const a=t[0]*this._data[0]+t[1]*this._data[1]+t[2]*this._data[2]+t[3],e=this.projectedRadius(B(t));return a>e?1:a<-e?-1:0}intersectRay(t,a,e=0){const s=this._data,i=I;i[0]=-s[6],i[1]=-s[7],i[2]=-s[8],i[3]=s[9],X[0]=t[0]-s[0],X[1]=t[1]-s[1],X[2]=t[2]-s[2];const r=d(X,X,I),n=d(Y,a,I);let o=-1/0,h=1/0;const c=this.getHalfSize(ht);for(let d=0;d<3;d++){const t=r[d],a=n[d],s=c[d]+e;if(Math.abs(a)>1e-6){const e=(s-t)/a,i=(-s-t)/a;o=Math.max(o,Math.min(e,i)),h=Math.min(h,Math.max(e,i))}else if(t>s||t<-s)return!1}return o<=h}projectedArea(e,s,i,n){const o=this.getQuaternion(O);r(I,o),X[0]=e[0]-this._data[0],X[1]=e[1]-this._data[1],X[2]=e[2]-this._data[2],d(X,X,I);const h=this.getHalfSize(ht),_=X[0]<-h[0]?-1:X[0]>h[0]?1:0,m=X[1]<-h[1]?-1:X[1]>h[1]?1:0,f=X[2]<-h[2]?-1:X[2]>h[2]?1:0,g=Math.abs(_)+Math.abs(m)+Math.abs(f);if(0===g)return 1/0;const p=1===g?4:6,M=6*(_+3*m+9*f+13);t(ct,o),a(ct,ct,h);const b=this.getCenter(nt);for(let t=0;t<p;t++){const a=V[M+t];c(X,((1&a)<<1)-1,(2&a)-1,((4&a)>>1)-1),u(X,X,ct),l(E,b,X),E[3]=1,v(E,E,s);const e=1/Math.max(1e-6,E[3]);N[2*t]=E[0]*e,N[2*t+1]=E[1]*e}const j=2*p-2;let S=N[0]*(N[3]-N[j+1])+N[j]*(N[1]-N[j-1]);for(let t=2;t<j;t+=2)S+=N[t]*(N[t+3]-N[t-1]);return Math.abs(S)*i*n*.125}projectedRadius(t){const a=this.getQuaternion(O);return r(I,a),d(X,t,I),Math.abs(X[0]*this._data[3])+Math.abs(X[1]*this._data[4])+Math.abs(X[2]*this._data[5])}minimumDistancePlane(t){return t[0]*this._data[0]+t[1]*this._data[1]+t[2]*this._data[2]+t[3]-this.projectedRadius(B(t))}maximumDistancePlane(t){return t[0]*this._data[0]+t[1]*this._data[1]+t[2]*this._data[2]+t[3]+this.projectedRadius(B(t))}toAaBoundingBox(a){const e=this.getQuaternion(O),s=t(ct,e),i=this._data[3]*Math.abs(s[0])+this._data[4]*Math.abs(s[3])+this._data[5]*Math.abs(s[6]),r=this._data[3]*Math.abs(s[1])+this._data[4]*Math.abs(s[4])+this._data[5]*Math.abs(s[7]),n=this._data[3]*Math.abs(s[2])+this._data[4]*Math.abs(s[5])+this._data[5]*Math.abs(s[8]);a[0]=this._data[0]-i,a[1]=this._data[1]-r,a[2]=this._data[2]-n,a[3]=this._data[0]+i,a[4]=this._data[1]+r,a[5]=this._data[2]+n}transform(t,a,e,s=0,i=w(e),r=w(a),n=H(a,r)){if(e===i)a.isGeographic?et(this,t,a,s,r):at(this,t,a,s,r,n);else if(a.isWGS84&&(e.isWebMercator||F(e)))L(a,this,e,t,s);else if(a.isWebMercator&&F(e))$(a,this,e,t,s);else{const i=this.getCenter(nt);i[2]+=s,D(i,a,0,i,e,0),t.center=i,this!==t&&(t.quaternion=this.getQuaternion(O),t.halfSize=this.getHalfSize(ht))}}}const I=h(),O=h(),T=h(),X=q(),Y=q(),E=A();function J(t,a=new G){return U(t,a),a}const N=[.1,.2,.3,.4,.5,.6,.7,.8,.9,1,1.1,1.2],V=(()=>{const t=new Int8Array(162);let a=0;const e=e=>{for(let s=0;s<e.length;s++)t[a+s]=e[s];a+=6};return e([6,2,3,1,5,4]),e([0,2,3,1,5,4]),e([0,2,3,7,5,4]),e([0,1,3,2,6,4]),e([0,1,3,2,0,0]),e([0,1,5,7,3,2]),e([0,1,3,7,6,4]),e([0,1,3,7,6,2]),e([0,1,5,7,6,2]),e([0,1,5,4,6,2]),e([0,1,5,4,0,0]),e([0,1,3,7,5,4]),e([0,2,6,4,0,0]),e([0,0,0,0,0,0]),e([1,3,7,5,0,0]),e([2,3,7,6,4,0]),e([2,3,7,6,0,0]),e([2,3,1,5,7,6]),e([0,1,5,7,6,2]),e([0,1,5,7,6,4]),e([0,1,3,7,6,4]),e([4,5,7,6,2,0]),e([4,5,7,6,0,0]),e([4,5,1,3,7,6]),e([0,2,3,7,5,4]),e([6,2,3,7,5,4]),e([6,2,3,1,5,4]),t})();function K(t,a,e,s,i){const n=t.getQuaternion(O);i.quaternion=n,r(I,n);const o=t.getCenter(nt),h=t.getHalfSize(ht);if(1===s){d(mt,o,I),_(ft,mt),b(ut,ft,h),p(ut,ft,ut);const s=j(ut);l(ut,ft,h);const r=j(ut);if(s<e)i.center=o,c(mt,e,e,e),i.halfSize=l(mt,h,mt);else{const n=r>0?1+a/r:1,o=s>0?1+e/s:1,c=(o+n)/2,_=(o-n)/2;g(ut,ft,_),i.halfSize=S(ut,ut,h,c),g(ut,ft,c),S(ut,ut,h,_),z(mt,mt),y(mt,ut,mt);const m=t.getQuaternion(T);i.center=d(mt,mt,m)}}else{i.center=S(mt,o,Q,(e+a)/2);const t=d(mt,Q,I);_(t,t),i.halfSize=S(ft,h,t,(e-a)/2)}return i}function L(t,a,e,s,i){a.getCenter(nt),nt[2]+=i;const r=w(e);D(nt,t,0,nt,r,0),tt(r,a,nt,e,s)}function $(t,a,e,s,i){a.getCenter(nt),nt[2]+=i,tt(t,a,nt,e,s)}function tt(a,e,s,i,r){const n=e.getQuaternion(O),o=t(ct,n),h=e.getHalfSize(ht);for(let t=0;t<8;++t){for(let a=0;a<3;++a)rt[a]=h[a]*(t&1<<a?-1:1);for(let a=0;a<3;++a){let e=s[a];for(let t=0;t<3;++t)e+=rt[t]*o[3*t+a];st[3*t+a]=e}}D(st,a,0,st,i,0,8),J(it,r)}function at(t,a,e,s,i=w(e),o=H(e,i)){t.getCorners(_t),t.getCenter(rt),rt[2]+=s,R(e,rt,dt,i),a.setCenter(dt[12],dt[13],dt[14]);const h=2*Math.sqrt(1+dt[0]+dt[5]+dt[10]);I[0]=(dt[6]-dt[9])/h,I[1]=(dt[8]-dt[2])/h,I[2]=(dt[1]-dt[4])/h,I[3]=.25*h;const m=t.getQuaternion(O);a.quaternion=n(I,I,m),r(I,I),c(ft,0,0,0);const f=a.getCenter(ot);for(const r of _t)r[2]+=s,o(r,0,r,0),p(mt,r,f),d(mt,mt,I),_(mt,mt),M(ft,ft,mt);a.halfSize=ft}function et(t,a,e,s,i=w(e)){const n=P(e),o=1+Math.max(0,s)/(n.radius+t.centerZ);t.getCenter(rt),rt[2]+=s,D(rt,e,0,rt,i,0),a.center=rt;const h=t.getQuaternion(O);a.quaternion=h,r(I,h),c(mt,0,0,1),d(mt,mt,I);const _=t.getHalfSize(ht);c(mt,_[0]*Math.abs(mt[0]),_[1]*Math.abs(mt[1]),_[2]*Math.abs(mt[2])),g(mt,mt,n.inverseFlattening),l(mt,_,mt),a.halfSize=g(mt,mt,o)}const st=new Array(24),it=new Z(st,3),rt=q(),nt=q(),ot=q(),ht=q(),ct=e(),dt=s(),_t=[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],mt=q(),ft=q(),ut=q(),lt=C(-1,-1,-1);function gt(t){return Array.from(t)}export{G as Obb,J as compute,K as computeOffsetObb,gt as ensurePackedObbData};
