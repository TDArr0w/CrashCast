/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import t from"../../../core/Logger.js";import{deg2rad as n,rad2deg as r,asinClamped as i}from"../../../core/mathUtils.js";import{throwIfAborted as a}from"../../../core/promiseUtils.js";import{d as o,k as c,F as s,b as l}from"../../../chunks/vec32.js";import{create as u,clone as f}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as m}from"../../../geometry/ellipsoidUtils.js";import p from"../../../geometry/Point.js";import{projectWithZConversion as d,project as h}from"../../../geometry/projectionUtils.js";import g from"../../../geometry/SpatialReference.js";import{projectPointToVectorAsync as y,projectPointToVector as v}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPointAsync as R,projectVectorToPoint as w}from"../../../geometry/projection/projectVectorToPoint.js";import{gcsCyclical as x,webMercatorCyclical as M}from"../../../geometry/support/normalizeUtils.js";import{toRenderCamera as j}from"../webgl.js";import{getGreatCircleSpanAt as T}from"./earthUtils.js";import{getElevationAtPoint as z}from"./ElevationProvider.js";import{viewModeDependentUtil as S,directionToHeadingTilt as C}from"./viewingModeUtils.js";import{isSpatialReferenceSupported as b}from"../../support/spatialReferenceSupport.js";const P=()=>t.getLogger("esri.views.3d.support.cameraUtils"),A=96*39.37,L=1,U=8,H=5,q=1,F=u();function I(e){return e.spatialReference??g.WGS84}function E(e,t,n,r,i){return S(e).headingTiltToDirectionUp(t,n,r,i)}function G(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper;t/=r;return n.width/2/n.pixelRatio/(A/t)/Math.tan(n.fovX/2)}function k(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper,i=t*Math.tan(n.fovX/2),a=n.width/2/n.pixelRatio;return A/(a/i)*r}function O(e,t,n,r){const i=r.levelAtScale(t),a=D(C(e,n.eye,n.viewForward,n.up).tilt),o=Math.max(i-a,0);return r.scaleAtLevel(o)}function X(e,t,n){const r=n.levelAtScale(e),i=D(t);return n.scaleAtLevel(r+i)}function D(e){return 2*((e>90?180-e:e)/90)**2}function V(e,t,n=0){const r=e.basemapTerrain?.tilingScheme;if(!r)return 0;const i=m(e.spatialReference).radius,a=2===e.state.viewingMode?t.eye[2]:l(t.eye)-i;return O(e,k(e,Math.abs(a-n)),t,r)}function W(e,t,n=0){const r=j(e,t);return r?V(e,r,n):0}const Y=1,N=100;function Z(e,t,a,o){if(0===t)return 0;const s=e.state.contentCamera,u=c(s.eye,a),f=e.basemapTerrain?.tilingScheme;if(!f)return P().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),u;let p=u;const d=C(e,s.eye,s.viewForward,s.up),h=d.tilt>90;if(e.state.isLocal){const r=(G(e,X(t,d.tilt,f))-Math.abs(s.eye[2]-o[2]))/Math.cos(n(d.tilt));return p=h?p-r:p+r,p}let g=1/0,y=0,v=te(e,d.heading,d.tilt,a,u,1);if(!v)return p;const R=l(o);for(;g>Y&&y<N;){const o=l(v.eye),u=h?180-v.tilt:v.tilt,w=n(u),x=Math.sin(w)*o,M=Math.cos(w)*o,j=G(e,X(t,v.tilt,f)),T=h?R-j:R+j,z=i(x/T),S=Math.cos(z)*T-M,C=c(v.eye,a);p=h?C-S:C+S,v=te(e,d.heading,d.tilt,a,p,1);const b=Me(e,v,r(s.fov));if(!v||!b)return p;const P=W(e,b,R-m(e.spatialReference).radius);g=Math.abs(t-P),++y}return p}async function B(e,t,n,r,i,a){return K(e,t,G(e,n),r,i,a)}function J(e,t,n,r,i,a){return Me(e,te(e,r.heading,r.tilt,t,n,i),r.fov,a)}async function K(e,t,n,r,i,o){const c=await ne(e,r.heading,r.tilt,t,n,i,o);return a(o),je(e,c,r.fov,o)}function Q(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,F,e.spatialReference)&&e.elevationProvider&&(z(e.elevationProvider,F)??0)>F[2]-q)}async function $(e,t,n){if(Q(e,t))return!0;const{elevationProvider:r,spatialReference:i,renderCoordsHelper:o}=e;if(null==r||!o.fromRenderCoords(t,F,i))return!1;const[c,s,l]=F,u=await r.queryElevation(c,s,l,i,"ground",n)??0;return a(n),u>l-q}async function _(e,t,n){const r=u();if(null==t)return o(r,e.state.camera.center);if(t instanceof p){const{renderSpatialReference:i,basemapTerrain:o,elevationProvider:c}=e,s=t.spatialReference;if(await y(t,r,i,0,{signal:n}),a(n),null==t.z&&null!=o&&null!=c){const i=await c.queryElevation(t.x,t.y,t.z??0,s,"ground",n);a(n),null!=i&&e.renderCoordsHelper.setAltitude(r,i)}return r}return o(r,t)}function ee(e,t){const n=u();if(null==t)return o(n,e.state.camera.center);if(t instanceof p){if(!v(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:i}=e;if(null==t.z&&null!=r&&null!=i){const r=z(i,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return o(n,t)}function te(e,t,n,r,i,a){return re(e,t,n,r instanceof p?r:null,ee(e,r),i,a)}async function ne(e,t,n,r,i,o,c){const s=r instanceof p?r:null,l=await _(e,r,c);return a(c),ie(e,t,n,s,l,i,o,c)}function re(e,t,n,r,i,a,o){if(null==i)return null;if(!r&&(r=new p({spatialReference:I(e)}),!w(i,e.renderSpatialReference,r)))return null;const c=ae(e,t,n,i,a,o);if(oe(e,n,o)&&Q(e,c.eye)){const{tilt:o,mode:c}=ce(e,n,i,a);return re(e,t,o,r,i,a,c)}return se(c,i)}async function ie(e,t,n,r,i,o,c,s){r||(r=new p({spatialReference:I(e)}),await R(i,e.renderSpatialReference,r,{signal:s})||(r=null)),a(s);const l=ae(e,t,n,i,o,c);if(oe(e,n,c)&&await $(e,l.eye,s)){a(s);const{tilt:c,mode:l}=ce(e,n,i,o);return ie(e,t,c,r,i,o,l,s)}return se(l,i)}function ae(e,t,n,r,i,a){const o=ge(e,t,n,r,i=Math.max(i,e.state.constraints.minimumPoiDistance),a);return(0,S(e).eyeForCenterWithHeadingTilt)(r,i,o.heading,o.tilt)}function oe(e,t,n){const r=e.map.ground.navigationConstraint;return 1===n&&e.state.isGlobal&&t>0&&(null==r||"stay-above"===r.type)}function ce(e,t,n,r){const i=we(e,n,r,Re(e,r,t,n));return{tilt:i,mode:t-i<1?0:1}}function se(e,t){return{...e,center:f(t)}}function le(e,t){const{state:n,spatialReference:r}=e,i=t.spatialReference;return n.isGlobal&&b(i,1)||n.isLocal&&r.equals(i)}function ue(e,t){let n,r,i;if(e.state.isGlobal){const e=new p(t.xmin,t.ymin,t.spatialReference),a=new p(t.xmax,t.ymax,t.spatialReference),o=t.spatialReference.isGeographic?x:M;n=new p({x:o.center(e.x,a.x),y:(a.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=m(t.spatialReference),s=T(n,e,a);r=s.lon,i=s.lat,o.diff(e.x,a.x)>o.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),i=Math.min(i,c.halfCircumference)}else{const a=e.renderSpatialReference??t.spatialReference;a.equals(t.spatialReference)||(t=h(t,a)),r=t.xmax-t.xmin,i=t.ymax-t.ymin;const o=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new p({x:t.xmin+.5*r,y:t.ymin+.5*i,z:o,spatialReference:a})}const a=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,o=e.state.camera,c=1/Math.tan(o.fovX/2),s=1/Math.tan(o.fovY/2),l=1/Math.tan(o.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*i*s,.5*a*l)/L}}async function fe(e,t,n,r,i,o){const c=le(e,t)?t:await d(t,e.spatialReference,{signal:o});a(o);const{center:s,distance:l}=ue(e,c),u=await ne(e,n,r,s,l,i,o);return a(o),je(e,u,e.camera.fov,o)}function me(e,t,n,r,i,a){let o;try{o=le(e,t)?t:h(t,e.spatialReference)}catch(u){return null}const{center:c,distance:s}=ue(e,o),l=te(e,n,r,c,s,i);return null==l?null:Me(e,l,e.camera.fov,a)}function pe(e,t,n){const r=e.renderSpatialReference,i=new p({spatialReference:I(e)});if(!w(n,r,i))return null;const a=Math.tan(t.fovX/2),o=Math.tan(t.fovY/2),c=s(t.eye,n),l=2*c*a*L,u=2*c*o*L;return S(e).toExtent(e,i,l,u)}function de(e,t){return S(e).toArea(e,t)}function he(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>U)return!0;const i=t,a=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return c(i,a)/(Math.tan(.5*e.state.camera.fov)*r)>H}function ge(e,t,n,r,i,a){let o=0;return 1===a&&he(e,r,i)?(t=0,o=ve(e,i,n,r)):o=xe(e,r,i,n),o=e.state.constraints.clampTilt(i,o),{heading:t,tilt:n=we(e,r,i,o)}}const ye=.7;function ve(e,t,n,r){const i=xe(e,r,t,n);if(!e.state.constraints.tilt)return i;const a=e.state.constraints.tilt(t);a.max=Math.min(a.max,.5*Math.PI);const o=a.min*(1-ye)+a.max*ye;return Math.min(i,o)}function Re(e,t,n,r){let i=xe(e,r,t,n);if(!e.state.constraints.tilt)return i;const a=e.state.constraints.tilt(t);return i=Math.min(i,.5*Math.PI),a.min*(1-ye)+i*ye}function we(e,t,n,r){return S(e).lookAtTiltToEyeTilt(r,t,n)}function xe(e,t,n,r){return S(e).eyeTiltToLookAtTilt(r,t,n)}function Me(t,n,r,i){if(null==n)return null;const a=t.renderSpatialReference,o=new p({spatialReference:I(t)});return w(n.eye,a,o)?(i??=new e,i.position=o,i.heading=n.heading,i.tilt=n.tilt,i.fov=r,i):null}async function je(t,n,r,i){const o=t.renderSpatialReference,c=new p({spatialReference:I(t)});return await R(n.eye,o,c,{signal:i}),a(i),new e(c,n.heading,n.tilt,r)}function Te(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);P().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function ze(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);P().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}export{O as applyTiltAdjustToScale,k as distanceToScale,K as fromCenterDistanceAsync,J as fromCenterDistanceSync,B as fromCenterScale,fe as fromExtentAsync,me as fromExtentSync,ne as getObserverForPointAtDistanceAsync,te as getObserverForPointAtDistanceSync,I as getViewSR,E as headingTiltToDirectionUp,X as removeTiltAdjustFromScale,Y as scaleErrorThreshold,G as scaleToDistance,Te as scaleToZoom,de as toArea,pe as toExtent,Z as viewScaleToCameraDistance,ze as zoomToScale};
