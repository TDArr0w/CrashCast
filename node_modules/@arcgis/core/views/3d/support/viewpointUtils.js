/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../../Camera.js";import e from"../../../Graphic.js";import n from"../../../Viewpoint.js";import{result as r}from"../../../core/asyncUtils.js";import"../../../core/has.js";import{cyclicalDegrees as a}from"../../../core/Cyclical.js";import o from"../../../core/Error.js";import{throwIfAborted as i}from"../../../core/promiseUtils.js";import{fromMat4 as s,transpose as c}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{create as l}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{create as m}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{h as u,g as f,k as p,d as g,e as y,j as h,o as d}from"../../../chunks/vec32.js";import{create as w}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import x from"../../../geometry/Extent.js";import j from"../../../geometry/Geometry.js";import v from"../../../geometry/Multipoint.js";import b from"../../../geometry/Point.js";import{projectWithZConversion as R,tryProjectWithZConversion as z}from"../../../geometry/projectionUtils.js";import G from"../../../geometry/SpatialReference.js";import{computeTranslationToOriginAndRotation as B}from"../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectPointToVectorAsync as M}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPoint as S}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as Z}from"../../../geometry/projection/projectVectorToVector.js";import{create as F,center as T,toRect as P,isPoint as k,empty as A,expandWithVec3 as E,expandWithAABB as V,width as O,height as U,depth as N}from"../../../geometry/support/aaBoundingBox.js";import{create as I,isPoint as C}from"../../../geometry/support/aaBoundingRect.js";import{polygonCentroidPoint as W}from"../../../geometry/support/centroid.js";import{intersectsPoint as Y}from"../../../geometry/support/frustum.js";import{getResolutionInMetersForScale as q}from"../../../geometry/support/scaleUtils.js";import{fromRenderCamera as D,toRenderCamera as J}from"../webgl.js";import{cameraOnContentAlongViewDirection as X}from"../camera/intersectionUtils.js";import{getViewSR as _,fromExtentAsync as H,scaleToDistance as K,fromCenterDistanceAsync as L,fromExtentSync as Q,distanceToScale as $,fromCenterDistanceSync as tt,fromCenterScale as et,zoomToScale as nt}from"./cameraUtils.js";import{getElevationAtPoint as rt}from"./ElevationProvider.js";import{directionToHeadingTilt as at}from"./viewingModeUtils.js";const ot=.66;function it(t){return 360-a.normalize(t)}function st(t){return a.normalize(360-t)}function ct(t,e,n){const r=e.camera;if(null!=r)return mt(r,_(t));const{targetGeometry:a}=e;if(null==a)return null;const{camera:o,mode:i}=ft(t,e.rotation,n);if("point"===a.type)return pt(t,e,a,o,i);const s=a.extent;return null==s?null:Q(t,s,o.heading,o.tilt,i)}async function lt(t,e,n,r){const a=e.camera;if(null!=a)return ut(a,_(t),r);const{targetGeometry:o}=e;if(null==o)throw new Error("Viewpoint has no targetGeometry!");const{camera:i,mode:s}=ft(t,e.rotation,n);if("point"===o.type)return gt(t,e,o,i,s,r);const c=o.extent;if(null==c)throw new Error("Target geometry has no extent!");return H(t,c,i.heading,i.tilt,s,r)}function mt(t,e){const n=t.position;let r;try{r=z(n,e)}catch(o){return null}if(!r)return null;const a=t.clone();return a.position=r.clone(),a}async function ut(t,e,n){const r=t.position,a=await R(r,e,{signal:n});i(n);const o=t.clone();return o.position=a.clone(),o}function ft(t,e,n){const r=D(t,t.state.camera);let a=1;return null!=e&&(r.heading=it(e),a=0),null!=n&&(r.tilt=n),{camera:r,mode:a}}function pt(t,e,n,r,a){const o=t.spatialReference;let i;try{i=z(n.clone(),o)}catch(c){return null}if(!i)return null;const s=null!=e.scale?K(t,e.scale):t.state.camera.distance;return tt(t,i,s,r,a)}async function gt(t,e,n,r,a,o){const s=t.spatialReference,c=await R(n.clone(),s,{signal:o});i(o);const l=null!=e.scale?K(t,e.scale):t.state.camera.distance;return L(t,c,l,r,a,o)}function yt(t,e,r=null){return null==r&&(r=new n),jt(t,null,e.clone(),r)}async function ht(e,r,a){const i=kt(e,r);if(!i)throw new o("viewpointutils-create:no-target","Missing target for creating viewpoint");const s=new t({fov:e.camera.fov}),c=new n({camera:s});if(i.target instanceof n){return At(await zt(e,i.target,i,a,c))}if(i.target instanceof t)return At(await Gt(e,i.target,a,c));const l=null!=i.scale||null!=i.zoom;if(i.target instanceof x){const t=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return At(l||t?await Mt(e,i,i.target.center,s,a,c):await Ft(e,i,i.target,s,a,c))}const m=new Vt,u=l?wt(e,i):void 0;if(await Rt(e,i.target,u,m,a),isFinite(m.boundingBox[0])){let t;if(T(m.boundingBox,Ot),Jt.x=Ot[0],Jt.y=Ot[1],Jt.z=Ot[2],Jt.spatialReference=e.spatialReference,isFinite(Jt.z)&&m.hasZ?t=k(m.boundingBox):(Jt.z=void 0,t=C(P(m.boundingBox,Ct))),l||t)return At(await Mt(e,i,Jt,s,a,c));const n=Et(e,m.screenSpaceObjects);return At(await Pt(e,i,Jt,m.boundingBox,n,s,a,c))}return i.position?At(await St(e,i,s,c,a)):At(await Zt(e,i,s,a,c))}function dt(t,e){return null==e.scale&&null!=e.zoom?nt(t,e.zoom):e.scale}function wt(t,e){const n=dt(t,e);return n?q(n):void 0}function xt(t,e){let n=!1;return null!=e.heading?(t.heading=e.heading,n=!0):null!=e.rotation&&(t.heading=it(e.rotation),n=!0),null!=e.tilt&&(t.tilt=e.tilt,n=!0),null!=e.fov&&(t.fov=e.fov),n}function jt(t,e,n,r){const a=t.spatialReference||G.WGS84;if(e??=J(t,n),null==e)return r;const o=new b({spatialReference:a});return S(e.center,t.renderSpatialReference,o)?(r.targetGeometry=o,r.scale=$(t,e.distance),r.rotation=st(n.heading),r.camera=n,r):r}async function vt(t,e,n,r){const a=()=>new o("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!e)throw a();"mesh"===e.type&&(e=e.extent);const i=t.basemapTerrain.spatialReference;if(!e.hasZ&&t.basemapTerrain){let n;switch(e.type){case"point":n=e;break;case"multipoint":case"polyline":n=e.extent?.center;break;case"extent":n=e.center;break;case"polygon":{const t=W(e);n=t?b.fromJSON(t):null;break}}null!=n&&i&&t.elevationProvider?(n=await R(n,i,{signal:r}),Ot[2]=rt(t.elevationProvider,n)??0):Ot[2]=0}const s=Xt[e.type],c=new Array;if(s(e,e.hasZ?t=>{c.push([t[0],t[1],t[2]])}:t=>{c.push([t[0],t[1]])},Ot),0===c.length)throw a();const l=e.spatialReference,m=t.spatialReference,u=await R(new v({spatialReference:l,hasZ:e.hasZ,hasM:!1,points:c}),m,{signal:r});if(e.hasZ&&(n.hasZ=!0),e.hasZ)for(const[o,f,p]of u.points)Ot[0]=o,Ot[1]=f,Ot[2]=p,E(n.boundingBox,Ot);else for(const[o,f]of u.points)Ot[0]=o,Ot[1]=f,E(n.boundingBox,Ot)}async function bt(t,e,n,a,o){const i=await r(t.whenViewForGraphic(e));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void await vt(t,e.geometry,a,o);const s=i.value,c=await r(s.whenGraphicBounds(e,{minDemResolution:n}));if(!1===c.ok||!c.value)return void await vt(t,e.geometry,a,o);const{screenSpaceObjects:l,boundingBox:m}=c.value;V(a.boundingBox,m),l&&l.forEach(t=>{a.screenSpaceObjects.push(t)}),isFinite(m[2])&&(a.hasZ=!0)}async function Rt(t,n,r,a,o){if(Array.isArray(n)&&2===n.length){const e=n[0],r=n[1];if("number"==typeof e&&"number"==typeof r)return Jt.x=e,Jt.y=r,Jt.z=void 0,Jt.spatialReference=t.spatialReference?.isGeographic?t.spatialReference:G.WGS84,void await vt(t,Jt,a,o)}n&&"map"in n&&"function"==typeof n.map?await Promise.allSettled(n.map(e=>Rt(t,e,r,a,o))):n instanceof j?await vt(t,n,a,o):n instanceof e&&await bt(t,n,r,a,o)}async function zt(t,e,n,r,a){if(e.camera)return Gt(t,e.camera,r,a);a.scale=e.scale,a.rotation=e.rotation,a.targetGeometry=null!=e.targetGeometry?e.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=st(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const o=dt(t,n);return null!=o&&(a.scale=o),a.camera=await lt(t,a,n.tilt,r),a}async function Gt(t,e,n,r){const a=t.spatialReference,o=await R(e.position,a,{signal:n}),i=e.clone();return i.position=o,jt(t,null,i,r)}async function Bt(t,e,n,r,a,o,i){const s=t.renderSpatialReference;return await M(e,qt,s,0,{signal:i}),await M(n,Yt,s,0,{signal:i}),o.targetGeometry=new b(e),a.position=new b(n),y(Wt,qt,Yt),at(t,Yt,Wt,r.up,a),o.scale=$(t,p(Yt,qt)),o.rotation=st(a.heading),o.camera=a,o}async function Mt(t,e,n,r,a,o){o.targetGeometry=n.clone();const i=X(t);if(e.position)return Bt(t,o.targetGeometry,e.position,i,r,o,a);if(e.zoomFactor){const n=i.distance/e.zoomFactor,r=u(Ot,i.viewForward,-n);i.eye=f(Ot,i.center,r),o.scale=$(t,n)}D(t,i,r);const s=xt(r,e)?0:1;if(!e.zoomFactor){const n=dt(t,e);if(null==n){await M(o.targetGeometry,Ot,t.renderSpatialReference,0,{signal:a});const e=Y(i.frustum,Ot)?p(i.eye,Ot):i.distance;o.camera=await L(t,o.targetGeometry,e,r,s),o.scale=$(t,e)}else o.scale=n,o.camera=await et(t,o.targetGeometry,o.scale,r,s,a)}return o}async function St(t,e,n,r,a){const o=X(t);g(Wt,o.viewForward),at(t,o.eye,Wt,o.up,Dt);const i=t.spatialReference,{position:s}=e;if(s){const t=await R(s,i,{signal:a});n.position=t}else n.position=new b;return n.heading=null!=e.heading?e.heading:Dt.heading,n.tilt=null!=e.tilt?e.tilt:Dt.tilt,jt(t,null,n,r)}async function Zt(t,e,n,r,a){if(null!=e.heading||null!=e.rotation||null!=e.scale||null!=e.tilt||null!=e.zoom||null!=e.zoomFactor){const o=X(t),{spatialReference:i,renderSpatialReference:s}=t,c=new b({spatialReference:i});return S(o.center,s,c)?Mt(t,e,c,n,r,a):a}return a.scale=t.scale,a.camera=t.camera.clone(),xt(a.camera,e),a}async function Ft(t,e,n,r,a,o){o.targetGeometry=n.clone();const i=X(t);D(t,i,r);const s=xt(r,e)?0:1;return o.camera=await H(t,n,r.heading,r.tilt,s,a),o}function Tt(t,e,n,r,a){let o=0;null!=n.z?o=n.z:t.basemapTerrain&&t.elevationProvider&&(o=rt(t.elevationProvider,n)),h(Ot,n.x,n.y,o),B(t.spatialReference,Ot,Ut,t.renderSpatialReference),s(Nt,Ut),c(Nt,Nt),A(It);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let s=0;s<i.length;s++){const e=i[s];let n=r[e[2]];isFinite(n)||(n=o),h(Ot,r[e[0]],r[e[1]],n),Z(Ot,t.spatialReference,Ot,t.renderSpatialReference),E(It,d(Ot,Ot,Nt))}const l=O(It),m=U(It),u=N(It),f=1/Math.tan(e.fovX/2),p=1/Math.tan(e.fovY/2),g=.5*Math.sqrt(l*l+u*u)*Math.max(p,f)+.5*m,y=.5*m*p+.5*Math.max(l,u);return Math.max(g,y)/a}async function Pt(t,e,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=X(t),l=Tt(t,c,n,r,a);D(t,c,o);const m=xt(o,e)?0:1;return s.camera=await L(t,s.targetGeometry,l,o,m,i),s.scale=$(t,l),s}function kt(t,e){if(!e||!t.spatialReference)return null;const n={target:void 0};return"declaredClass"in e||Array.isArray(e)?n.target=e:(Object.assign(n,e),!n.target&&"center"in e&&e.center&&(n.target=e.center)),n}function At(t){return null!=t?.camera&&(t.rotation=st(t.camera.heading)),t}function Et(t,e){const n=ot;if(!e.length)return n;let r=Number.NEGATIVE_INFINITY;for(let a=0;a<e.length;a++){const t=e[a].screenSpaceBoundingRect;r=Math.max(r,Math.abs(t[0]),Math.abs(t[1]),Math.abs(t[2]),Math.abs(t[3]))}return n-r/Math.min(t.width,t.height)*2}class Vt{constructor(){this.hasZ=!1,this.boundingBox=A(),this.screenSpaceObjects=new Array}}const Ot=w(),Ut=m(),Nt=l(),It=F(),Ct=I(),Wt=w(),Yt=w(),qt=w(),Dt={heading:0,tilt:0},Jt=new b,Xt={point(t,e,n){n[0]=t.x,n[1]=t.y,null!=t.z&&(n[2]=t.z),e(n)},polygon(t,e,n){const r=t.hasZ;for(let a=0;a<t.rings.length;a++){const o=t.rings[a];for(let t=0;t<o.length;t++)n[0]=o[t][0],n[1]=o[t][1],r&&(n[2]=o[t][2]),e(n)}},polyline(t,e,n){const r=t.hasZ;for(let a=0;a<t.paths.length;a++){const o=t.paths[a];for(let t=0;t<o.length;t++)n[0]=o[t][0],n[1]=o[t][1],r&&(n[2]=o[t][2]),e(n)}},multipoint(t,e,n){const r=t.points,a=t.hasZ;for(let o=0;o<r.length;o++)n[0]=r[o][0],n[1]=r[o][1],a&&(n[2]=r[o][2]),e(n)},extent(t,e,n){null!=t.zmin&&null!=t.zmax?(e(h(n,t.xmin,t.ymin,t.zmin)),e(h(n,t.xmax,t.ymin,t.zmin)),e(h(n,t.xmin,t.ymax,t.zmin)),e(h(n,t.xmax,t.ymax,t.zmin)),e(h(n,t.xmin,t.ymin,t.zmax)),e(h(n,t.xmax,t.ymin,t.zmax)),e(h(n,t.xmin,t.ymax,t.zmax)),e(h(n,t.xmax,t.ymax,t.zmax))):(e(h(n,t.xmin,t.ymin,n[2])),e(h(n,t.xmax,t.ymin,n[2])),e(h(n,t.xmin,t.ymax,n[2])),e(h(n,t.xmax,t.ymax,n[2])))}};export{ht as create,yt as fromCamera,lt as toCameraAsync,ct as toCameraSync};
