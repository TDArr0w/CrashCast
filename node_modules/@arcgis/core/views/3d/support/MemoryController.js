/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../core/Accessor.js";import has from"../../../core/has.js";import i from"../../../core/Logger.js";import{MemCacheStorage as s,MemCache as r}from"../../../core/MemCache.js";import{addFrameTask as o}from"../../../core/scheduling.js";import{Milliseconds as a}from"../../../core/time.js";import{property as d}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/RandomLCG.js";import{subclass as h}from"../../../core/accessorSupport/decorators/subclass.js";import{isMemoryManagedView as y}from"./MemoryManagedView.js";import{makeBudget as l}from"../../support/Scheduler.js";function m(e){return new w({view:e})}const u=.1,n=1,c=1,_=.75,p=.6,M=1.3,g=!!has("esri-tests-disable-memory-pools");let w=class extends t{constructor(e){super(e),this._quality=1,this._usedMemory=0,this._updating=!1,this._stableQuality=0,this._downscaleMemoryUsed=0,this._canFastRecover=!1,this._predictedMemory=0,this._cacheStorage=new s,this._warnMemoryUsage=null,this._numQualityChanges=0,this._maxMemory=g?4096:750,this._additionalCacheMemory=g?-4096:0,this.addHandles(o({prepare:()=>this._updateMemory()}))}destroy(){this._cacheStorage.destroy()}get maxMemory(){return this._maxMemory}set maxMemory(e){null==e||e<=0||g||(this._stableQuality=0,this._canFastRecover=!1,this._maxMemory<e&&this._updateQuality(n),this._maxMemory=e)}get additionalCacheMemory(){return this._additionalCacheMemory}set additionalCacheMemory(e){null==e||g||(this._additionalCacheMemory=e)}get memoryFactor(){return this._quality}get updating(){return this._updating}get usedMemory(){return this._usedMemory}get usedCacheMemory(){return this._cacheStorage.size}newCache(e,t,i){return new r(e,this._cacheStorage,t,i)}resetStableQuality(){this._stableQuality=0}disableMemCache(){this.additionalCacheMemory=-4096}update(){if(this._predictedMemory<=0&&!this._updating)return;let e=this._layersUpdating();if(this._predictedMemory<p&&this._canFastRecover)this._downscaleMemoryUsed=0,this._stableQuality=0,this._canFastRecover=!1,this._updateQuality(n);else if(e){if(this._predictedMemory>1.1*c||this._usedMemory>c)if(this._stableQuality>0)this._downscaleMemoryUsed=0,this._updateQuality(this._stableQuality);else if(this._quality>u&&this._downscaleMemoryUsed<this._usedMemory){if(this._compactAndUpdate())return;this._updateQuality(this._quality/M),this._downscaleMemoryUsed=this._usedMemory,this._canFastRecover=!1}}else if(this._downscaleMemoryUsed=0,this._usedMemory>c){if(this._compactAndUpdate())return;this._stableQuality=0,this._canFastRecover=!1,e=this._updateQuality(this._quality/M),this._downscaleMemoryUsed=this._predictedMemory}else if(this._stableQuality!==this._quality)if(this._usedMemory<_&&this._quality<n){this._stableQuality=this._quality;const t=.05;e=this._updateQuality(this._quality+t)}else this._quality<1&&(this._canFastRecover=!0);this._updating=e}_compactAndUpdate(){const e=l(a(100)),t=this.view.stage.compact(e);return this.view.overlayManager.renderer.compact(e)||t}_updateQuality(e){return(e=Math.min(Math.max(e,u),n))!==this._quality&&(this._quality=e,++this._numQualityChanges,!0)}_layersUpdating(){return this.view.allLayerViews.some(e=>!!e.updating)}_updateMemory(){if(!this.view?.updating||this.view.destroyed||this.view.destroying)return;this.view.stage?.renderer?.tick();const e=this.view.stage?.renderer?.usedMemory;let t=(this.view.basemapTerrain?.usedMemory??0)+(e?e.fbos+e.edges+e.plugins:0)+this.view.deconflictor?.usedMemory+this.view.labeler?.usedMemory,s=0;this.view.allLayerViews&&this.view.allLayerViews.forEach(e=>{if(y(e)){const i=e.ignoresMemoryFactor?this._quality:1;t+=e.usedMemory*i,s+=e.unloadedMemory*i}});const r=null==this._warnMemoryUsage||Math.round(10*t)!==Math.round(10*this._warnMemoryUsage),o=1048576*this.maxMemory;if(t>o&&r){this._warnMemoryUsage=t;const e=e=>(e/1048576).toLocaleString(void 0,{maximumFractionDigits:1})+" MB",r=Math.round(100*this._quality);i.getLogger(this).warn(`Memory Limit exceeded! Limit: ${e(o)} Current: ${e(t)} Projected: ${e(t+s)} Quality: ${r}%`)}this._usedMemory=t/o,this._predictedMemory=(t+s)/o;const a=o-t;this._cacheStorage.maxSize=Math.max(0,a+1048576*this.additionalCacheMemory)}get test(){}};e([d({constructOnly:!0})],w.prototype,"view",void 0),e([d()],w.prototype,"maxMemory",null),e([d()],w.prototype,"additionalCacheMemory",null),e([d({readOnly:!0})],w.prototype,"memoryFactor",null),e([d({readOnly:!0})],w.prototype,"updating",null),e([d({readOnly:!0})],w.prototype,"usedMemory",null),e([d({readOnly:!0})],w.prototype,"usedCacheMemory",null),e([d()],w.prototype,"_quality",void 0),e([d()],w.prototype,"_usedMemory",void 0),e([d()],w.prototype,"_updating",void 0),e([d()],w.prototype,"_stableQuality",void 0),e([d()],w.prototype,"_maxMemory",void 0),e([d()],w.prototype,"_additionalCacheMemory",void 0),w=e([h("esri.views.3d.support.MemoryController")],w);export{u as minQuality,m as newMemoryController};
