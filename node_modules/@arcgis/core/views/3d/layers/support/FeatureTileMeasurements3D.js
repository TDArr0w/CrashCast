/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{H as e,j as t,n as s,f as i,h as o,d as r,F as a}from"../../../../chunks/vec32.js";import{create as n,freeze as l,ZEROS as c}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{distance as d}from"../../../../geometry/support/aaBoundingRect.js";import{intersectsPoint as h}from"../../../../geometry/support/frustum.js";import{fromValues as m}from"../../../../geometry/support/ray.js";import{FeatureTileVisibility3D as p,minTileLOD as u}from"./FeatureTileVisibility3D.js";import f from"../../webgl/RenderCamera.js";class _{constructor(e,t,s){this._renderCoordsHelper=e,this._tilingScheme=t,this._camera=new f,this._surfaceElevation=0,this._focusOnMap=[0,0],this._visibility=new p(e,s)}set opaqueGround(e){this._visibility.opaqueGround=e}setup(e,t,s){this._camera.copyFrom(e),this._surfaceElevation=s,this._focusOnMap[0]=t.x,this._focusOnMap[1]=t.y,this._visibility.setup(this._camera)}done(){this._visibility.done()}update(e){const{measures:t,extent:s,level:i}=e;s&&(t.visible=this._visibility.compute(e),t.distance=d(s,this._focusOnMap),t.mergeable=!0,t.lodLevel=u,t.splitPriority=Math.max(0,u-i),t.visible&&(this._isGlobal?this._updateSplitAndLodGlobal(e):this._updateSplitAndLodLocal(e)))}_updateSplitAndLodGlobal(r){const a=r.level,n=this._renderCoordsHelper,{eye:l,fov:c}=this._camera,d=n.referenceEllipsoid.radius,h=e(l)-d;if(2*Math.atan(d/h)<c&&h>0)return void(r.measures.lodLevel=Math.max(a,u));const m=v,{extent:p}=r;if(!p)return;const{_surfaceElevation:f}=this;t(m[0],p[0],p[1],f),t(m[1],p[2],p[1],f),t(m[2],p[2],p[3],f),t(m[3],p[0],p[3],f);const _=t(M,.5*(p[0]+p[2]),.5*(p[1]+p[3]),f),y=this._tilingScheme.spatialReference;for(let e=0;e<4;++e)n.toRenderCoords(m[e],y,m[e]);n.toRenderCoords(_,y,_);const b=s(g.direction,_),L=i(l,b),S=o(x,b,L);this._updateSplitAndLod(r,m,_,S)}_updateSplitAndLodLocal(e){const s=v,{extent:i}=e;if(!i)return;const{_surfaceElevation:o}=this;t(s[0],i[0],i[1],o),t(s[1],i[2],i[1],o),t(s[2],i[2],i[3],o),t(s[3],i[0],i[3],o);const a=this._tilingScheme.spatialReference;for(let t=0;t<4;++t)this._renderCoordsHelper.toRenderCoords(s[t],a,s[t]);const n=t(M,.5*(s[0][0]+s[2][0]),.5*(s[0][1]+s[2][1]),.25*(s[0][2]+s[1][2]+s[2][2]+s[3][2])),l=t(y,n[0],n[1],0),{eye:c,far:d}=this._camera,h=t(x,l[0],l[1],c[2]);t(g.origin,l[0],l[1],c[2]-2*d),r(g.direction,b),this._updateSplitAndLod(e,s,n,h)}_updateSplitAndLod(e,t,s,o){const r=Math.max(a(t[0],t[2]),a(t[1],t[3]),a(t[0],s)+a(s,t[2]),a(t[1],s)+a(s,t[3])),{eye:n,near:l,fov:c,viewForward:d,width:m,height:p,pixelRatio:u,frustum:f}=this._camera,_=i(n,d),v=i(s,d)-_,M=a(s,n);let y=v,x=v,b=M,g=M;const C=(e,t)=>t<l?1:Math.sqrt(e*e-t*t)/t;let R=C(M,v);for(const h of t){const e=i(h,d)-_;y=Math.min(y,e),x=Math.max(x,e);const t=a(h,n);g=Math.max(g,t),b=Math.min(b,t);const s=C(t,e);R=Math.min(R,s)}if(x<l)return void(e.measures.lodLevel=0);const w=Math.cos(.5*c),A=a(n,o);R>w&&A>S*r&&(x=j*g,y=j*b);const G=.5*Math.sqrt(m*m+p*p)/u,E=2*Math.tan(.5*c),H=e=>Math.max(l,e)*L/G*E,q=e.level,F=r*2**q*Math.max(1,E),O=H(y),P=Math.ceil(Math.log2(Math.max(1,F/O)));if(e.measures.lodLevel=Math.max(P,e.measures.lodLevel),e.measures.splitPriority+=e.measures.lodLevel-q,q<P){const s=+h(f,t[0])+ +h(f,t[1])+ +h(f,t[2])+ +h(f,t[3]);e.measures.splitPriority+=s}const k=H(x)/O;k>2.5&&(e.measures.splitPriority+=k)}get _isGlobal(){return 1===this._renderCoordsHelper.viewingMode}}const v=[n(),n(),n(),n()],M=n(),y=n(),x=n(),b=l(0,0,1),g=m(c,b),L=312,S=.5,j=2;export{_ as FeatureTileMeasurements3D};
