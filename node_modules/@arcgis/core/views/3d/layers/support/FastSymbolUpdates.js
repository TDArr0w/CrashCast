/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{clamp as t}from"../../../../core/mathUtils.js";import{fromMat4 as o}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as e}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{identity as i,copy as s,set as r,multiply as n,scale as l,translate as a,rotateZ as u,rotateX as c,rotateY as f}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as p}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{j as m,d}from"../../../../chunks/vec32.js";import{ones as z,zeros as v,create as h}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{d as y}from"../../../../chunks/vec42.js";import{ones as S}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{meterIn as b}from"../../../../renderers/support/lengthUtils.js";import{isString as x,isStringOrNull as g,isNumber as C}from"../../../../support/guards.js";import{debugFlags as k}from"../../support/debugFlags.js";import{olidEnabled as V}from"../../webgl-engine/effects/geometry/olidUtils.js";import{NoParameters as w}from"../../../webgl/NoParameters.js";class j{constructor(t){this.field=t}}class M extends j{constructor(t){super(t),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[0,0,0],this.fallback=[0,0,0]}}class I extends j{constructor(t){super(t),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0],this.fallback=[0,0,0,0]}}class N extends j{constructor(t,o=0){super(t),this.fallback=o,this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}}class P extends j{constructor(t){super(t),this.offset=[0,0,0],this.factor=[1,1,1],this.type=[0,0,0]}}class T{}function U(t){return null!=t}function D(t,o){t&&t.push(o)}function F(t,o,e,i=p()){const s=t||0,r=o||0,n=e||0;return 0!==s&&u(i,i,-s/180*Math.PI),0!==r&&c(i,i,r/180*Math.PI),0!==n&&f(i,i,n/180*Math.PI),i}function A(t,o,e,i,s){const r=t.minSize,n=t.maxSize;if(t.useSymbolValue){const t=i.symbolSize[e];return o.minSize[e]=t,o.maxSize[e]=t,o.offset[e]=o.minSize[e],o.factor[e]=0,o.type[e]=1,!0}if(U(t.field))return U(t.stops)?2===t.stops.length&&C(t.stops[0].size)&&C(t.stops[1].size)?(R(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,o,e),o.type[e]=1,!0):(D(s,"Could not convert size info: stops only supported with 2 elements"),!1):C(r)&&C(n)&&U(t.minDataValue)&&U(t.maxDataValue)?(R(r,n,t.minDataValue,t.maxDataValue,o,e),o.type[e]=1,!0):"unknown"===t.valueUnit?(D(s,"Could not convert size info: proportional size not supported"),!1):null!=b[t.valueUnit]?(o.minSize[e]=-1/0,o.maxSize[e]=1/0,o.offset[e]=0,o.factor[e]=1/b[t.valueUnit],o.type[e]=1,!0):(D(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!U(t.field)){if(t.stops?.[0]&&C(t.stops[0].size))return o.minSize[e]=t.stops[0].size,o.maxSize[e]=t.stops[0].size,o.offset[e]=o.minSize[e],o.factor[e]=0,o.type[e]=1,!0;if(C(r))return o.minSize[e]=r,o.maxSize[e]=r,o.offset[e]=r,o.factor[e]=0,o.type[e]=1,!0}return D(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function R(t,o,e,i,s,r){const n=Math.abs(i-e)>0?(o-t)/(i-e):0;s.minSize[r]=n>0?t:o,s.maxSize[r]=n>0?o:t,s.offset[r]=t-e*n,s.factor[r]=n}function E(t,o,e,i){if(t.normalizationField||t.valueRepresentation)return D(i,"Could not convert size info: unsupported property"),null;if(!g(t.field))return D(i,"Could not convert size info: field is not a string"),null;if(o.size){if(t.field)if(o.size.field){if(t.field!==o.size.field)return D(i,"Could not convert size info: multiple fields in use"),null}else o.size.field=t.field}else o.size=new M(t.field),d(o.size.fallback,e.fallbackSize);let s;switch(t.axis){case"width":return s=A(t,o.size,0,e,i),s?o:null;case"height":return s=A(t,o.size,2,e,i),s?o:null;case"depth":return s=A(t,o.size,1,e,i),s?o:null;case"width-and-depth":return s=A(t,o.size,0,e,i),s&&A(t,o.size,1,e,i),s?o:null;case null:case void 0:case"all":return s=A(t,o.size,0,e,i),s=s&&A(t,o.size,1,e,i),s=s&&A(t,o.size,2,e,i),s?o:null;default:return D(i,`Could not convert size info: unknown axis "${t.axis}""`),null}}function O(t,o,e){for(let s=0;s<3;++s){let e=o.unitInMeters;1===t.type[s]&&(e*=o.modelSize[s],t.type[s]=2),t.minSize[s]=t.minSize[s]/e,t.maxSize[s]=t.maxSize[s]/e,t.offset[s]=t.offset[s]/e,t.factor[s]=t.factor[s]/e}let i;if(0!==t.type[0])i=0;else if(0!==t.type[1])i=1;else{if(0===t.type[2])return D(e,"No size axis contains a valid size or scale"),!1;i=2}for(let s=0;s<3;++s)0===t.type[s]&&(t.minSize[s]=t.minSize[i],t.maxSize[s]=t.maxSize[i],t.offset[s]=t.offset[i],t.factor[s]=t.factor[i],t.type[s]=t.type[i]);return!0}function _(t,o,e){t[4*o]=e.r/255,t[4*o+1]=e.g/255,t[4*o+2]=e.b/255,t[4*o+3]=e.a}function q(t,o,e,i){if(t.normalizationField)return D(i,"Could not convert color info: unsupported property"),null;if(x(t.field)){if(!t.stops)return D(i,"Could not convert color info: missing stops or colors"),null;{if(t.stops.length>8)return D(i,"Could not convert color info: too many color stops"),null;o.color=new I(t.field);const s=t.stops;for(let t=0;t<8;++t){const e=s[Math.min(t,s.length-1)];o.color.values[t]=e.value,_(o.color.colors,t,e.color)}y(o.color.fallback,e.fallbackColor)}}else{if(!(t.stops&&t.stops.length>=0))return D(i,"Could not convert color info: no field and no colors/stops"),null;{const i=t.stops&&t.stops.length>=0&&t.stops[0].color;o.color=new I(null);for(let t=0;t<8;t++)o.color.values[t]=1/0,_(o.color.colors,t,i);y(o.color.fallback,e.fallbackColor)}}return o}function $(t,o,e,i){if(t.normalizationField)return D(i,"Could not convert opacity info: unsupported property"),null;if(x(t.field)){if(!t.stops)return D(i,"Could not convert opacity info: missing stops or opacities"),null;{if(t.stops.length>8)return D(i,"Could not convert opacity info: too many opacity stops"),null;o.opacity=new N(t.field,e.fallbackColor[3]);const s=t.stops;for(let t=0;t<8;++t){const e=s[Math.min(t,s.length-1)];o.opacity.values[t]=e.value,o.opacity.opacityValues[t]=e.opacity}}}else{if(!(t.stops&&t.stops.length>=0))return D(i,"Could not convert opacity info: no field and no opacities/stops"),null;{const i=t.stops&&t.stops.length>=0?t.stops[0].opacity:0;o.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0],fallback:e.fallbackColor[3]};for(let t=0;t<8;t++)o.opacity.values[t]=1/0,o.opacity.opacityValues[t]=i}}return o}function B(t,o,e){const i=2===e&&"arithmetic"===t.rotationType;o.offset[e]=i?90:0,o.factor[e]=i?-1:1,o.type[e]=1}function L(t,o,e){if(!x(t.field))return D(e,"Could not convert rotation info: field is not a string"),null;if(o.rotation){if(t.field)if(o.rotation.field){if(t.field!==o.rotation.field)return D(e,"Could not convert rotation info: multiple fields in use"),null}else o.rotation.field=t.field}else o.rotation={field:t.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(t.axis){case"tilt":return B(t,o.rotation,0),o;case"roll":return B(t,o.rotation,1),o;case null:case void 0:case"heading":return B(t,o.rotation,2),o;default:return D(e,`Could not convert rotation info: unknown axis "${t.axis}""`),null}}class G{constructor({supports:t,modelSize:o,symbolSize:e,unitInMeters:i,anchor:s,scale:r,rotation:n,fallbackColor:l,fallbackSize:a}){this.supports=t,this.modelSize=o??z(),this.symbolSize=e??z(),this.unitInMeters=i??1,this.anchor=s??v(),this.scale=r??z(),this.rotation=n??v(),this.fallbackColor=l??S(),this.fallbackSize=a??z()}}function H(t,o,e){if(!t)return null;const i=t.reduce((t,i)=>{if(!t)return t;if(i.valueExpression)return D(e,"Could not convert visual variables: arcade expressions not supported"),null;switch(i.type){case"size":return o.supports.size?E(i,t,o,e):t;case"color":return o.supports.color?q(i,t,o,e):t;case"opacity":return o.supports.opacity?$(i,t,o,e):null;case"rotation":return o.supports.rotation?L(i,t,e):t;default:return null}},new T);return!(t.length>0&&i)||i.size||i.color||i.opacity||i.rotation?i?.size&&!O(i.size,o,e)?null:i:null}class J{constructor(t,o,e){this.visualVariables=t,this.materialParameters=o,this.requiresShaderTransformation=e}}function K(t,o){if(!t)return null;if(V())return null;if(k.TESTS_DISABLE_FAST_UPDATES)return null;const e=H(t.visualVariables,o);return e?new J(e,Y(e,o),!!e.size):null}function Q(t,o,e){if(!o||!t)return!1;const i=t.visualVariables,s=H(o.visualVariables,e);return!!s&&(!!(W(i.size,s.size,"size")&&W(i.color,s.color,"color")&&W(i.rotation,s.rotation,"rotation")&&W(i.opacity,s.opacity,"opacity"))&&(t.visualVariables=s,t.materialParameters=Y(s,e),t.requiresShaderTransformation=!!s.size,!0))}function W(t,o,e){if(!!t!=!!o)return!1;if(t&&t.field!==o?.field)return!1;if(t&&"rotation"===e){const e=t,i=o;for(let t=0;t<3;t++)if(e.type[t]!==i.type[t]||e.offset[t]!==i.offset[t]||e.factor[t]!==i.factor[t])return!1}return!0}class X extends w{constructor(t){super(),this.vvSize=t?.size??null,this.vvColor=t?.color??null,this.vvOpacity=t?.opacity??null}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}function Y(t,s){const r=new X(t);return r.vvSize&&(r.vvSymbolAnchor=s.anchor,i(st),F(s.rotation[2],s.rotation[0],s.rotation[1],st),r.vvSymbolRotationMatrix=r.vvSymbolRotationMatrix||e(),o(r.vvSymbolRotationMatrix,st)),r}function Z(t,o,e){if(!t.vvSize)return e;s(et,e);const i=t.vvSymbolRotationMatrix;return r(st,i[0],i[1],i[2],0,i[3],i[4],i[5],0,i[6],i[7],i[8],0,0,0,0,1),n(et,et,st),tt(it,t,o),l(et,et,it),a(et,et,t.vvSymbolAnchor),et}function tt(o,e,i){if(!e.vvSize)return m(o,1,1,1),o;if(Number.isNaN(i[0]))return d(o,e.vvSize.fallback);for(let s=0;s<3;++s){const r=e.vvSize.offset[s]+i[0]*e.vvSize.factor[s];o[s]=t(r,e.vvSize.minSize[s],e.vvSize.maxSize[s])}return o}function ot(t,o){const e=null==t?0:o.attributes[t];return"number"==typeof e&&isFinite(e)?e:NaN}const et=p(),it=h(),st=p();export{G as ConvertOptions,I as FastColorInfo,N as FastOpacityInfo,P as FastRotationInfo,M as FastSizeInfo,J as FastSymbolUpdatesState,T as FastVisualVariables,X as VisualVariablesParameters,H as convertVisualVariables,Z as evaluateModelTransform,tt as evaluateModelTransformScale,ot as getAttributeValue,Y as getMaterialParameters,K as initFastSymbolUpdatesState,Q as updateFastSymbolUpdatesState};
