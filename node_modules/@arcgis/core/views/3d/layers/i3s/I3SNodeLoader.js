/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{result as e,assertResult as t}from"../../../../core/asyncUtils.js";import has from"../../../../core/has.js";import{clone as r}from"../../../../core/lang.js";import{throwIfAbortError as i}from"../../../../core/promiseUtils.js";import{makeAbsolute as o}from"../../../../core/urlUtils.js";import{readBinaryAttribute as s,createGeometryDescriptor as n}from"./I3SBinaryReader.js";import{getMaterialAndTextures as a,getMaterialAndTexturesFromShared as u,selectEncoding as l}from"./I3SMaterialUtil.js";class f{constructor(e,t,r,i,o,s){if(this._streamDataController=t,this._logger=r,this._defaultGeometrySchema=i,this._requiredAttributes=o,this._options=s,this._logLayer=e,this._layerUrl=e.parsedUrl.path,this._geometryDefinitions=e.geometryDefinitions,e.materialDefinitions){const t=e.textureSetDefinitions;this._materialAndTextures=e.materialDefinitions.map(r=>a(t,r,"integrated-mesh"===e.type))}}_load(e,t,r){return this._streamDataController.request(e,t,r)}_loadAttribute(e,t,r){const i=`${this._layerUrl}/nodes/${e.resources.attributes}/attributes/${t.key}/0`;return this._load(i,1,r).then(e=>s(t,e))}async loadAttributes(e,t,r){const o=await Promise.allSettled(t.map(t=>this._loadAttribute(e,t.attributeStorageInfo,r))),s={};for(let n=0;n<t.length;++n){const r=o[n],a=t[n];if("fulfilled"===r.status){const e=r.value;s[a.name]=e}else{const t=r.reason;i(t),this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${a.name}' on node '${e.id}'`,t)}}return s}async loadNodeData(r,i){const o=null!=this._requiredAttributes&&r.resources.attributes?e(this.loadAttributes(r,this._requiredAttributes,i)):null,{bufferDefinition:s,bufferIndex:a}=g(this._geometryDefinitions,r),l=!!r.resources.geometry,f=l?e(this._loadGeometry(r.resources.geometry,a,i)):null,_=r.resources.hasSharedResource?await this._loadShared(r,i):null,y=r.resources.materialDefinition,D=this._materialAndTextures&&null!=y&&y>=0?this._materialAndTextures[y]:null!=_?u(_):null,b=D?.material,x=D?.textures??[],p=`${r.id}`,A=!l&&this._options.loadFeatureData,$=A?await this._loadFeatureData(p,i):null,T=A?c($):d(b),w=null==T?m($):null,I=x.length>0?e(this.loadTextures(r,x,i)):null;let U=null,j=null;if(f){U=t(await f);const e=h(this._defaultGeometrySchema,_);j=n(s,e)}const S=I?t(await I):null,q=o?t(await o):{},P=q?{attributeData:q,loadedAttributes:this._requiredAttributes}:null;if(null!=T)return{geometryData:T,attributeDataInfo:P,geometryBuffer:U,geometryDescriptor:j,requiredTextures:x,textureData:S};if(null!=w)return{pointData:w,attributeDataInfo:P,geometryBuffer:U,geometryDescriptor:j,requiredTextures:x,textureData:S};throw new Error}static _addAbsoluteHrefTexture(e,t){const r=e.textureDefinitions;if(null!=r)for(const i of Object.keys(r))for(const e of r[i].images)Array.isArray(e.href)?e.hrefConcat=e.href.map(e=>o(e,t)):e.hrefConcat=o(e.href,t)}static _fixTextureEncodings(e){const t=e.textureDefinitions;if(null!=t)for(const r in t){const e=t[r];if(Array.isArray(e.encoding))for(let t=0;t<e.encoding.length;t++){const r=e.encoding[t];r.startsWith("data:")&&(e.encoding[t]=r.slice(5))}else{const t=e.encoding;t.startsWith("data:")&&(e.encoding=t.slice(5))}}}async _loadShared(e,t){if(null==e.resources.geometry)return{};const r=`${this._layerUrl}/nodes/${e.resources.geometry}/shared`,i=await this._load(r,0,t);return f._fixTextureEncodings(i),f._addAbsoluteHrefTexture(i,r),i}_loadTexture(e,t,r,i,o){return 4===i||1===i||2===i?this._load(e,1,o).then(e=>({id:t,usage:r,data:e,encoding:i})):this._load(e,2,o).then(e=>({id:t,usage:r,data:e,encoding:i}))}loadTextures(e,t,r){const i=this._options.textureUsageMask;return Promise.all(t.map(t=>{if(0===(t.usage&i))return null;const o=l(t.encodings,this._options.textureEncodings);if(null==o)return this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${e.id}`),Promise.reject();const s=e.resources.texture||e.id,n=`${this._layerUrl}/nodes/${s}/textures/${o.name}`;return this._loadTexture(n,t.id,t.usage,o.encoding,r)}))}_loadFeatureData(e,t){const r=`${this._layerUrl}/nodes/${e}/features/0`;return this._load(r,0,t)}_loadGeometry(e,t,r){const i=`${this._layerUrl}/nodes/${e}/geometries/${t}`;return this._load(i,1,r)}}function d(e){return{featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:e}}],featureDataPosition:[0,0,0]}}function c(e){if(!e)return null;for(const t of e.featureData){const e=t.geometries;if(null!=e)for(const r of e)return{featureIds:[t.id],featureDataPosition:t.position,geometries:[r]}}return null}function m(e){if(!e)return null;const t=new Array;for(const r of e.featureData)null!=r.position&&t.push({featureIds:[r.id],featureDataPosition:r.position,geometries:[]});return t}function h(e,t){if(!e||!t?.materialDefinitions)return e;const i=Object.keys(t.materialDefinitions)[0];return!t.materialDefinitions[i].params.vertexRegions&&e.vertexAttributes.region&&delete(e=r(e)).vertexAttributes.region,e}function g(e,t){const r={bufferDefinition:null,bufferIndex:0},i=t.resources.geometryDefinition;if(null==e||null==i||i<0)return r;const o=i>=0?e[i].geometryBuffers:null;if(null==o)return r;for(let s=0;s<o.length;s++){const e=o[s];if(null==e.compressedAttributes)r.bufferIndex=s,r.bufferDefinition=o[s];else if("draco"===e.compressedAttributes.encoding&&!has("disable-feature:i3s-draco"))return r.bufferIndex=s,r.bufferDefinition=e,r}return r}export{f as default};
