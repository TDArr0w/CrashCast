/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import{destroyMaybe as r}from"../../../../core/maybe.js";import{watch as t,initial as s,syncAndInitial as o,when as i}from"../../../../core/reactiveUtils.js";import{property as n}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as a}from"../../../../core/accessorSupport/decorators/subclass.js";import{hydrateGeometry as l}from"../../../../layers/graphics/hydratedFeatures.js";import{FeatureTileController3D as c}from"../../../../layers/graphics/controllers/FeatureTileController3D.js";import{FeatureLayerViewPerformanceInfo as u}from"../FeatureLayerViewPerformanceInfo.js";import{Graphics3DGraphicsPipeline as p}from"./Graphics3DGraphicsPipeline.js";import{FeatureTileFetcher3DContext as m}from"../support/FeatureTileFetcher3DContext.js";import{EventedSet as h}from"../../support/EventedSet.js";let d=class extends p{constructor(e){super(e),this._controllerTotal=0,this._processorTotal=0,this._needsRefresh=!1,this.suspendResumeExtentMode="data"}initialize(){this.addHandles(t(()=>({controller:this.controller,suspended:this.suspended}),({controller:e,suspended:r})=>{e&&!r&&this._needsRefresh&&(e.refetch(),this._needsRefresh=!1)}))}destroy(){this._fetcherContext=r(this._fetcherContext)}get maximumNumberOfFeatures(){return this.controller?.maximumNumberOfFeatures??this._get("maximumNumberOfFeatures")}set maximumNumberOfFeatures(e){this._set("maximumNumberOfFeatures",e),this.controller&&(this.controller.maximumNumberOfFeatures=e)}get snappingComplexityExceeded(){return this.controller?.snappingComplexityExceeded??!0}get maximumNumberOfFeaturesExceeded(){return!!this.controller&&!(this.suspended||!this.controller.maximumNumberOfFeaturesExceeded)}get updatingProgressValue(){let e=0;if(this.controller?.updating){const r=this.controller.updatingRemaining,t=Math.max(this.controller.updatingTotal,this._controllerTotal);t>0&&(e=(t-r)/t,this._controllerTotal=t)}let r=0;if(this.processor?.updating){const e=this.processor.updatingRemaining,t=Math.max(e,this._processorTotal);t>0&&(r=(t-e)/t,this._processorTotal=t)}return.5*(e+r)}get updatePolicy(){if(!this.controller)return 0;switch(this.controller.mode){case"snapshot":{const e=f.get(this.layer.geometryType);return null==e||this.controller.serviceDataCount>e?0:1}case"tiles":return 0}}get usedMemory(){return(this.processor?.usedMemory??0)+(this.controller?.memoryForUnusedFeatures??0)}get unloadedMemory(){const e=this.processor?.unprocessedMemoryEstimate??0,r=this.controller?.expectedFeatureDiff??0,t=this.processor?.loadedFeatures??0,s=t+r>0?t/(t+r):1;return e+r*(this.processor?.usedMemoryPerFeature??0)*s}get ignoresMemoryFactor(){return this.controller?.hasMaximumNumberOfFeaturesOverride}get performanceInfo(){const e=this.controller?.displayFeatureLimit,r=null!=e?e.averageSymbolComplexity:void 0,t=null!=r?`f:${r.verticesPerFeature},v:${r.verticesPerCoordinate}`:"n/a";return new u(super.performanceInfo,this.controller?.performanceInfo?.storedFeatures??0,this.controller?.performanceInfo?.totalVertices??0,this.maximumNumberOfFeaturesExceeded,this.controller?.mode??"n/a",t)}async doRefresh(e){const{controller:r,processor:t,suspended:s}=this;e&&r&&(s?this._needsRefresh=!0:(r.refetch(),this._needsRefresh=!1)),t.refreshFilter()}setVisibility(e,r){this.processor?.setObjectIdVisibility(e,r)}getMissingAttributesForFeature(e){return this.controller.getMissingAttributesForFeature(e)}getHydratedGeometry(e){const r=this.graphics3DProcessor;if(null==r)return null;const t=r.graphics3DGraphicsByObjectID;if(null==t)return null;const s=t.get(e);return null==s?null:l(s.graphic.geometry)}createController(){this._fetcherContext=new m({layerView:this.layerView,returnZ:this.hasZ,returnM:this.hasM});const e=new c({layerView:this.layerView,context:this._fetcherContext,graphics:new h,extent:this.clippingExtent});return this.updatingHandles.add(()=>e.serviceDataExtent,e=>{this.processor&&(this.processor.dataExtent=e)},s),this.addHandles(t(()=>this.suspended&&this.layerView.updateSuspended,r=>{r?e.suspend():e.resume()},o)),this.updatingHandles.add(()=>this.processor?.displayFeatureLimit,r=>e.displayFeatureLimit=r,s),this.addHandles(i(()=>!this.updating,()=>{this._controllerTotal=0,this._processorTotal=0})),e}beforeSetController(e){e.maximumNumberOfFeatures=this.maximumNumberOfFeatures}get test(){return{controller:this.controller,graphics3DProcessor:this.graphics3DProcessor,heatmapProcessor:this.heatmapProcessor,loadedGraphics:this.loadedGraphics}}};e([n()],d.prototype,"layerView",void 0),e([n()],d.prototype,"controller",void 0),e([n()],d.prototype,"_controllerTotal",void 0),e([n()],d.prototype,"_processorTotal",void 0),e([n()],d.prototype,"_needsRefresh",void 0),e([n()],d.prototype,"maximumNumberOfFeatures",null),e([n()],d.prototype,"snappingComplexityExceeded",null),e([n()],d.prototype,"maximumNumberOfFeaturesExceeded",null),e([n()],d.prototype,"updatingProgressValue",null),e([n()],d.prototype,"updatePolicy",null),e([n()],d.prototype,"suspendResumeExtentMode",void 0),d=e([a("esri.views.3d.layers.graphics.FeatureGraphics3DGraphicsPipeline")],d);const f=new Map([["point",5e3],["polygon",500],["polyline",1e3]]);export{d as FeatureGraphics3DGraphicsPipeline};
