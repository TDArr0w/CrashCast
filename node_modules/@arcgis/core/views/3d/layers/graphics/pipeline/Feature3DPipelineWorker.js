/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__addDisposableResource as e,__disposeResources as t,__decorate as r}from"tslib";import{EventedAccessor as a}from"../../../../../core/Evented.js";import{throwIfAborted as n}from"../../../../../core/promiseUtils.js";import{watch as i,initial as s}from"../../../../../core/reactiveUtils.js";import{property as o}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as l}from"../../../../../core/accessorSupport/decorators/subclass.js";import c from"../../../../../geometry/Extent.js";import{initializeProjection as d,project as m}from"../../../../../geometry/projectionUtils.js";import u from"../../../../../geometry/SpatialReference.js";import{QueryEngine as h}from"../../../../../layers/graphics/data/QueryEngine.js";import y from"../../../../../rest/support/Query.js";import{FeatureProcessingContext as p}from"./FeatureProcessingContext.js";import{PipelineCommand as f}from"./PipelineCommand.js";import{Tile3DManager as _}from"./Tile3DManager.js";import{TileLocks as C}from"./TileLocks.js";import{TiledFeatureStore as w}from"./featureSet/TiledFeatureStore.js";import{Tile3DFetcher as g}from"./fetching/Tile3DFetcher.js";import{RenderCommandContext as x}from"./rendering/RenderCommandContext.js";import{RenderCoordsHelper as v}from"../../../support/RenderCoordsHelper.js";let R=class extends a{constructor(){super(...arguments),this.remoteClient=null,this._featureStore=new w,this._tileLocks=new C,this._tileManager=null,this._renderer=null,this._fetcher=null,this._queryEngine=null,this._defaultQueryJSON=null,this._mainThreadDelegate=null,this._viewSpatialReference=null,this._renderCommandContext=null,this._context=null}get updating(){return this._tileManager.updating}destroy(){this._featureStore.clear(),this._tileManager?.destroy()}async setup({viewSpatialReference:e,renderSpatialReference:t,viewingMode:r,layerInfo:a,layerViewInfo:n}){const o=u.fromJSON(e);this._viewSpatialReference=o;const l=u.fromJSON(t);this._fetcher=new g(this._viewSpatialReference,y.fromJSON(a.baseQuery),a.url,a.objectIdField,a.capabilities),this._queryEngine=new h({hasZ:!0,hasM:!1,geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:a.objectIdField},fieldsIndex:a.fieldIndex,availableFields:[a.objectIdField],spatialReference:e,featureStore:this._featureStore,timeInfo:a.timeInfo}),this._mainThreadDelegate={createTexture:async(e,t)=>{const r={data:e,parameters:t};return await this.remoteClient.invoke("createTexture",r,{transferList:[e.buffer]})},releaseTexture:async e=>{const t={uid:e};await this.remoteClient.invoke("releaseTexture",t)},createMaterial:async e=>{const t={materialJSON:e};await this.remoteClient.invoke("createMaterial",t)},destroyMaterial:async e=>{const t={materialId:e};await this.remoteClient.invoke("destroyMaterial",t)},createDirectRenderer:async e=>{const t={materialId:e};await this.remoteClient.invoke("createDirectRenderer",t)},destroyDirectRenderer:async e=>{const t={materialId:e};await this.remoteClient.invoke("destroyDirectRenderer",t)},createLodRenderer:async(e,t,r)=>{const a={rendererId:e,lodRenderGeometry:t};await this.remoteClient.invoke("createLoDRenderer",a,{transferList:r})},destroyLodRenderer:async e=>{const t={rendererId:e};await this.remoteClient.invoke("destroyLoDRenderer",t)},executeRenderCommands:async e=>{const t={commands:e.commands};await this.remoteClient.invoke("dispatchRenderCommands",t,{transferList:e.transferList})},applyElevationAlignmentTo:async e=>{const t={mapPoints:e};return await this.remoteClient.invoke("applyElevationAlignment",t,{transferList:[e.buffer]})},setBaseInstance:async(e,t)=>{const r={rendererId:e,baseInstance:t};await this.remoteClient.invoke("setBaseInstance",r,{transferList:null!=t?[t.data]:void 0})}};const f=v.create(r,l),C=new x(r,this._mainThreadDelegate);this._renderCommandContext=C;const w=new p(o,l,this._mainThreadDelegate,f,C,a,n);this._context=w,this._renderer=w.symbolRendererFactory.createSymbolRendererFromJSON(a.renderer),this._defaultQueryJSON=new y({outSpatialReference:o}).toJSON();let R=null;if(null!=a.fullExtent){const e=c.fromJSON(a.fullExtent);await d(e.spatialReference,o),R=m(e,o)}return this._tileManager=new _({loadTile:(e,t)=>this._fetcher.fetch(e,t),createAddCommand:(e,t)=>this._createAddFeatureDataCommand(e,t),createRemoveCommand:e=>this._createRemoveFeatureDataCommand(e),createUpdateCommand:(e,t)=>this._createUpdateFeatureDataVisibilityCommand(e,t),tileLocks:this._tileLocks,extent:R}),this.addHandles(i(()=>this.updating,e=>{this.emit("notify-updating",{updating:e})}),s),null!=this._renderer&&await this._renderer.load(),j}async executeQuery(e,t){return{result:await this._queryEngine.executeQuery(this._ensureQuery(e),t)}}async executeQueryForIds(e,t){const r=await this._queryEngine.executeQueryForIdSet(this._ensureQuery(e),t);return{result:Array.from(r)}}async executeQueryForCount(e,t){return{result:await this._queryEngine.executeQueryForCount(this._ensureQuery(e),t)}}async executeQueryForExtent(e,t){return{result:await this._queryEngine.executeQueryForExtent(this._ensureQuery(e),t)}}async executeQueryForLatestObservations(e,t){return{result:await this._queryEngine.executeQueryForLatestObservations(this._ensureQuery(e),t)}}async executeAttributeBinsQuery(e,t){return{result:await this._queryEngine.executeAttributeBinsQuery(e,t)}}onTileTreeChange(e){return this._tileManager.onTileTreeChange(e),Promise.resolve(j)}async onElevationChange(e){return j}async onLayerViewOpacityChange(e){const{_context:t,_renderer:r}=this;if(t.layerViewInfo.fullOpacity=e,null==r)return j;const a=await r.createUpdateLayerViewOpacityCommand(e);return await a.execute(),j}async onRendererChange(r){const{_context:a}=this,n=a.symbolRendererFactory.createSymbolRendererFromJSON(r);await n.load();const i=this._renderer;this._renderer=n;const s=[...this._tileManager.loadedTiles()],o=s.map(e=>e.tileId);{const r={stack:[],error:void 0,hasError:!1};try{e(r,await this._tileLocks.lock(o),!1);const t=s.flatMap(e=>[i.createRemoveCommand(e.id),n.createAddCommand(e)]),l=await Promise.all(t),c=a.joinPipelineCommands(l);await c.execute()}catch(c){r.error=c,r.hasError=!0}finally{t(r)}}const l=await i.createDestroyCommand();return await l.execute(),j}async _createAddFeatureDataCommand(e,t){const r=this._featureStore,a=this._renderer;let i;return i=null!=a?await a.createAddCommand(e):f.create(this._renderCommandContext),n(t),i.appendPipelineStateCommand(()=>{r.addTile(e)}),i}async _createRemoveFeatureDataCommand(e){const t=this._featureStore,r=this._renderer;let a;return a=null!=r?await r.createRemoveCommand(e):f.create(this._renderCommandContext),a.appendPipelineStateCommand(()=>{t.removeTile(e)}),a}async _createUpdateFeatureDataVisibilityCommand(e,t){const r=this._renderer;let a;return a=null!=r?await r.createUpdateVisibilityCommand(e):f.create(this._renderCommandContext),n(t),a}_ensureQuery(e){return e??this._defaultQueryJSON}};r([o()],R.prototype,"updating",null),R=r([l("esri.views.3d.layers.graphics.pipeline.Feature3DPipelineWorker")],R);const S=R,j={result:void 0};export{S as default};
