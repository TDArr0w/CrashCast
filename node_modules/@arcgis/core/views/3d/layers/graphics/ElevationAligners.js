/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{copy as t}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as e}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{j as o}from"../../../../chunks/vec32.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{computeTranslationToOriginAndRotation as r}from"../../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectBuffer as a}from"../../../../geometry/projection/projectBuffer.js";import{SampleElevationInfo as s,updateVertexPointGroundDistance as i}from"./elevationAlignmentUtils.js";import{debugFlags as l}from"../../support/debugFlags.js";import{SamplePosition as m}from"../../support/ElevationProvider.js";import{isGeometryWithMapPositions as c}from"../../webgl-engine/lib/GeometryWithMapPositions.js";function f(t,e,o,n,r){const a=t.stageObject,s=a.geometries;let i=0;for(const l of s){if(!c(l))continue;const{update:t,averageGeometrySampledElevation:s}=M(l,e,o,n,r);i+=s,t&&a.geometryVertexAttributeUpdated(l,"position")}return i/s.length}function u(e,n,a,s,m,c){const f=e.stageObject,u=n.centerInElevationSR;let g=0;if(s(u,E),f.usesVerticalDistanceToGround)i(f,E.verticalDistanceToGround),g=E.sampledElevation;else{"absolute-height"!==n.mode&&(g=E.sampledElevation)}const d=t(p,c??f.transformation),I=o(v,d[12],d[13],d[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=u[0],T[1]=u[1],T[2]=E.z,r(a,T,d,m.spatialReference)&&(c?t(c,d):f.transformation=d)):m.setAltitudeOfTransformation(E.z,d);const S=b/m.unitInMeters;return(Math.abs(d[12]-I[0])>=S||Math.abs(d[13]-I[1])>=S||Math.abs(d[14]-I[2])>=S)&&(c?t(c,d):f.transformation=d),g}const p=e();function g(t,e,n,a,s){const i=t.graphics3DSymbolLayer.lodRenderer;if(null==i)return 0;const m=e.centerInElevationSR;a(m,E);const c="absolute-height"!==e.mode?E.sampledElevation:0,f=i.instanceData,u=t.instanceIndex,p=h;f.getGlobalTransform(u,p);const g=o(v,p[12],p[13],p[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=m[0],T[1]=m[1],T[2]=E.z,r(n,T,p,s.spatialReference)&&f.setGlobalTransform(u,p)):s.setAltitudeOfTransformation(E.z,p);const d=b/s.unitInMeters;return(l.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(p[12]-g[0])>=d||Math.abs(p[13]-g[1])>=d||Math.abs(p[14]-g[2])>=d)&&f.setGlobalTransform(u,p),c}function d(t,e,o,n,r){const a=t.stageObject,s=a.geometries;if(0===s.length)return 0;let i=0,l=null,m=0,f=!1;for(const u of s){if(!c(u))continue;const t=u.attributes.get("position");if(t!==l){const{update:a,averageGeometrySampledElevation:s}=M(u,e,o,n,r);m=s,l=t,f=a}f&&a.geometryVertexAttributeUpdated(u,"position"),i+=m}return i/s.length}const b=.01,T=n(),I=n(),S=n(),h=e(),v=n(),E=new s;function M(t,e,o,n,r){let s=!1;const i=t.transformation,c=e.requiresSampledElevationInfo;I[0]=i[12],I[1]=i[13],I[2]=i[14],t.invalidateBoundingInfo();const f=t.getMutableAttribute("position"),u=f.data,p=f.size,g=u.length/p,d=new m(t.mapPositions,o);let h=0,v=0;for(let m=0;m<g;m++){if(S[0]=u[h],S[1]=u[h+1],S[2]=u[h+2],n(d,E),c&&(v+=E.sampledElevation),l.TESTS_DISABLE_OPTIMIZATIONS)u[h]=d.array[d.offset],u[h+1]=d.array[d.offset+1],u[h+2]=E.z,a(u,o,h,u,r.spatialReference,h,1),u[h]-=I[0],u[h+1]-=I[1],u[h+2]-=I[2],s=!0;else{T[0]=u[h]+I[0],T[1]=u[h+1]+I[1],T[2]=u[h+2]+I[2],r.setAltitude(T,E.z),u[h]=T[0]-I[0],u[h+1]=T[1]-I[1],u[h+2]=T[2]-I[2];const t=b/r.unitInMeters;(Math.abs(S[0]-u[h])>=t||Math.abs(S[1]-u[h+1])>=t||Math.abs(S[2]-u[h+2])>=t)&&(s=!0)}h+=p,d.offset+=3}return v/=g,{update:s,averageGeometrySampledElevation:v}}export{g as perLodInstanceElevationAligner,u as perObjectElevationAligner,f as perVertexElevationAligner,d as sharedGeometryElevationAligner};
