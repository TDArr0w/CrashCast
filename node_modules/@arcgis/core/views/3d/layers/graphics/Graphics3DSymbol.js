/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/arrayUtils.js";import{forEach as t}from"../../../../core/asyncUtils.js";import"../../../../core/has.js";import{onAbortOrThrow as r,throwIfAborted as s}from"../../../../core/promiseUtils.js";import{totalSymbolComplexities as o}from"./defaultSymbolComplexity.js";import{Graphics3DGraphic as a}from"./Graphics3DGraphic.js";import{Graphics3DObject3DGraphicLayer as i}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayerCreationContext as n}from"./Graphics3DSymbolCreationContext.js";import{Loadable as l}from"./Loadable.js";import{getSymbolMemorySize as y}from"./symbolMemory.js";class h extends l{set symbol(e){this._symbol=e,e.symbolLayers.forEach((t,r)=>{const s=this.symbolLayers[r];null!=s&&(s.symbol=e,s.symbolLayer=t)})}get symbol(){return this._symbol}constructor(e,t,r){super(t.schedule),this._symbol=e,this._context=t,this._backgroundLayers=r,this._destroyed=!1,this.symbolLayers=new Array,this.referenced=0,this._extentPadding=0}async doLoad(e){let o=this._symbol.symbolLayers;this._extentPadding=0,this._backgroundLayers&&(o=this._backgroundLayers.concat(o));const a=o.length;for(;this.symbolLayers.length<o.length;)this.symbolLayers.push(null);this.symbolLayers.length=o.length;const i=[];if(!m){const{make:e}=await import("./Graphics3DSymbolLayerFactory.js");m=e}for(let t=0;t<a;t++){const s=o.at(t);if(!1===s.enabled)continue;c.renderPriority=1-(1+t)/a,c.renderPriorityStep=1/a,c.ignoreDrivers=s.ignoreDrivers;const n=m(this.symbol,s,this._context,c),l=r(e,()=>{this.symbolLayers[t]=null,n.destroy()});l&&i.push(l),this.symbolLayers[t]=n}if(await t(this.symbolLayers,async(e,t)=>{if(null!=e)try{await e.load(),this._extentPadding+=Math.max(this._extentPadding,e.extentPadding)}catch{this.symbolLayers[t]=null}}),i.forEach(e=>e.remove()),s(e),this.symbolLayers.length&&!this.symbolLayers.some(e=>!!e))throw new Error}getSymbolLayerSize(e){const t=this.symbolLayers[e];return null!=t?t.getCachedSize():null}get extentPadding(){return this._extentPadding}get symbologySnappingSupported(){return this.symbolLayers.some(e=>e?.queryForSnapping)}get needsUpdateFocus(){return this.symbolLayers.some(e=>!0===e?.needsUpdateFocus)}createGraphics3DGraphic(e,t){const{graphic:r}=e,s=this.symbolLayers.map(t=>t?.createGraphics3DGraphic(e)??null);return new a(r,t||this,s)}get complexity(){return o(this.symbolLayers.map(e=>e?.complexity))}globalPropertyChanged(e,t){const r=this.symbolLayers.length;for(let s=0;s<r;s++){const r=this.symbolLayers[s],o=e=>{const t=e.layers[s];return t instanceof i?t:null};if(null!=r&&!r.globalPropertyChanged(e,t,o))return!1}return!0}applyRendererDiff(e,t){return 1!==this.loadStatus?0:this.symbolLayers.reduce((r,s)=>0!==r&&null!=s?Math.min(r,s.applyRendererDiff(e,t)):r,2)}prepareSymbolPatch(e){if(2===this.loadStatus)return;if("partial"!==e.diff.type)return;const t=e.diff.diff;if(!t.symbolLayers||"partial"!==t.symbolLayers.type)return;const r=t.symbolLayers.diff;this.symbolLayers.forEach((t,s)=>{if(null==t)return;const o=r[s];if(o){const r={diff:o,graphics3DGraphicPatches:[],symbolLayerStatePatches:[]};t.prepareSymbolLayerPatch(r),e.symbolStatePatches.push(...r.symbolLayerStatePatches),r.graphics3DGraphicPatches.length&&e.graphics3DGraphicPatches.push((e,t)=>{const o=e.layers[s];null!=o&&r.graphics3DGraphicPatches.forEach(e=>e(o,t))})}})}updateGeometry(e){return this._updateGeometryOrTransform(e,(t,r)=>!!t.updateGeometry&&t.updateGeometry(e.graphic,r))}updateTransform(e,t,r,s){return this._updateGeometryOrTransform(e,(e,o)=>!!e.updateTransform&&e.updateTransform(o,t,r,s))}_updateGeometryOrTransform(e,t){for(let r=0;r<this.symbolLayers.length;r++){const s=this.symbolLayers[r];if(null==s)continue;const o=e.layers[r];if(!o||!t(s,o))return!1}return!0}onRemoveGraphic(e){for(let t=0;t<this.symbolLayers.length;t++){const r=this.symbolLayers[t];if(null==r)continue;const s=e.layers[t];null!=s&&r.onRemoveGraphic(s)}}getFastUpdateStatus(){let e=!1,t=!1;for(const r of this.symbolLayers)if(null!=r){if(0===r.loadStatus)return 3;r.isFastUpdatesEnabled()?t=!0:e=!0}return t?e?2:1:e?0:4}async queryForSnapping(t,r,o,a){const i=this.symbolLayers.filter(e).filter(e=>null!=e.queryForSnapping).map(e=>e.queryForSnapping(t,r,o,a)),n=await Promise.all(i);return s(a),n.flat()}destroy(){if(!this.destroyed){super.destroy();for(const e of this.symbolLayers)null!=e&&e.destroy();this.symbolLayers.length=0,this._destroyed=!0}}get destroyed(){return this._destroyed}get usedMemory(){return y(this)}}let m=null;const c=new n;export{h as Graphics3DSymbol};
