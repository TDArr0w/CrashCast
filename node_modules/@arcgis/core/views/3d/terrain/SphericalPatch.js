/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,j as i,g as s,h as o,H as n,i as r,f as a,F as l,a as h}from"../../../chunks/vec32.js";import{create as u}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{lonLatToSphericalPCPF as d}from"../../../geometry/projection/lonLatToSphericalPCPF.js";import{newDoubleArray as c}from"../../../geometry/support/DoubleArray.js";import{intersectsSphere as p,numPlanes as f}from"../../../geometry/support/frustum.js";import{c as m,u as g,a as x,v as $,e as v,n as M}from"../../../chunks/sphere.js";import{createSphericalGlobePatch as _,updateCornerSpherical as b,updateEdgesAndCornersSpherical as j,updateEdgeElevationsAndResolutionsSpherical as y}from"./PatchGeometryFactory.js";import{enableTerrainInternalChecks as B,internalAssert as S,almostEquals as V}from"./terrainUtils.js";import{Tile as H}from"./Tile.js";import{compareTilesByLij as R}from"./tileUtils.js";class T extends H{constructor(t,e,i,s,o){super(),this._convexHull=new Array(24),this._boundingSphere=m(),this._baseUsedMemory=1816,this.init(t,e,i,s,o)}init(i,s,o,n,r){super.init(i,s,o,n,r);const a=this.ellipsoid.radius,l=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],c=this.extentInRadians[3],p=t(h,c,.5),f=t(l,u,.5),m=0===i?0:Math.min(Math.abs(h),Math.abs(c));this._edgeLen=(u-l)*Math.cos(m)*a,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4),d(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),e(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const t=this._center;if(0===this.lij[0])g(t[1],0,0,0),i(t[0],0,0,0),i(t[2],0,0,0),t[1][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const e=t[1],i=this.convexHull;let s=0;const o=x(e);for(let t=0;t<8;++t)s=Math.max(s,I(o,i,3*t));t[1][3]=Math.sqrt(s)}}_calculateFrustumVisibility(t){if(!p(t,this._boundingSphere))return 2;if(this.lij[0]<10)return 1;const e=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let o=0;o<f;o++){const n=4===o,r=t[o],a=r[0],l=r[1],h=r[2],u=r[3]-(n?i:0);let d=!1;for(let t=0;t<8;++t){const i=3*t;if(a*e[i]+l*e[i+1]+h*e[i+2]+u<0){if(d=!0,!s)break}else s=!1}if(!d)return 2}return s?0:1}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){_(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),B&&this._checkBVs()}_updateBoundingSphere(){const t=this._boundingSphere,e=this.elevationBoundsMin,i=this.elevationBoundsMax,r=this.ellipsoid.radius,a=i;if(0===this.level)$(t,0,0,0,r+a);else{const a=this.extentInRadians,l=.5*(a[0]+a[2]),h=a[1],u=a[3];L(k,l,h,r),L(A,l,u,r),s(D,k,A);o(D,D,(r+.5*(e+i))/n(D));const d=this.convexHull;let c=0;const p=(t,e)=>{const i=t[0]-d[3*e],s=t[1]-d[3*e+1],o=t[2]-d[3*e+2];return Math.sqrt(i*i+s*s+o*o)};for(let t=0;t<8;++t){const e=p(D,t);c=Math.max(c,e)}v(t,D,c+2)}}_updateConvexHull(){const t=this.extentInRadians,i=this.ellipsoid.radius;if(0===this.level)return;const l=this.elevationBoundsMin,d=this.elevationBoundsMax,c=this._getPatchType(),p=this.surface.isWebMercator,f=p&&1===c,m=p&&2===c,g=m||f,x=Math.PI/2,$=t[0],v=t[2],M=m?-x:t[1],_=f?x:t[3],b=.5*($+v),j=l,y=i+(g?Math.min(0,j-1):j),B=(t,e,i)=>L(t,e,i,y),H=u(),R=u(),T=u(),C=u();B(H,$,M),B(R,$,_),B(T,v,_),B(C,v,M);const I=(t,e)=>{for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]};I(H,0),I(R,1),I(T,2),I(C,3);const F=d,k=i+(g?Math.max(0,F+1):F),A=u(),D=u(),E=u();L(D,b,_,y),L(E,b,M,y),s(A,D,E),e(A,A);const w=u(),U=u(),q=(t,i)=>{h(U,t,i),e(U,U);const n=-a(t,w)/a(U,w);S(n>=0),o(U,U,n),s(t,t,U)};if(2**this.lij[0]>2*this.lij[1]){const t=E,i=u();r(i,P,t),e(i,i),r(w,t,i),e(w,w),S(V(a(w,t)/n(t),0)),q(H,R),q(C,T),I(H,0),I(C,3)}else if(2**this.lij[0]!==2*this.lij[1]){const t=D,i=u();r(i,P,t),e(i,i),r(w,i,t),e(w,w),q(R,H),q(T,C),I(R,1),I(T,2)}const N=(t,e)=>{const i=k/a(e,A);for(let s=0;s<3;++s)this._convexHull[3*t+s]=e[s]*i};N(4,H),N(5,R),N(6,T),N(7,C)}_getPatchType(){const t=this.lij[1],e=0===t,i=t===(1<<this.level)-1;return e?i?3:1:i?2:0}intersectsRay(t,e,i,s){const o=this._boundingSphere,n=o[3]+i,r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],a=o[0]-t[0],l=o[1]-t[1],h=o[2]-t[2],u=(a*e[0]+l*e[1]+h*e[2])/r,d=e[0]*u-a,c=e[1]*u-l,p=e[2]*u-h;return d*d+c*c+p*p<n*n}get minimumVerticesPerSide(){return this.level<C.length?C[this.level]+1:2}updateCornerElevations(){b(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){j(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){y(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!B)return;if(this.level<=2)return;const t=this._boundingSphere,i=t[3],o=M(t,u()),d=u(),p=this.ellipsoid.radius,f=this.elevationBoundsMin,m=this.elevationBoundsMax,g=p+f,x=1,$=0,v=this._center[1];M(v,u());const _=v[3],b=this.convexHull,j=(t,e)=>{for(let i=0;i<3;++i)t[i]=b[3*e+i]};{const t=u(),i=u(),s=u(),o=u(),n=u(),l=(l,u,d,c)=>{j(i,l),j(s,u),j(o,d),h(i,i,s),h(o,o,s),r(t,i,o),e(t,t);const p=a(t,s);j(n,c);const f=a(t,n),m=Math.abs(f-p);S(V(m,0),`Non coplanar ${l},${u},${d},${c} diff = ${m}`)};l(0,1,2,3),l(4,5,6,7),l(0,1,4,5),l(1,2,5,6),l(2,3,6,7),l(3,0,7,4)}const y=c(24),H=(t,e,i)=>{const s=4*t;for(let o=0;o<3;++o)y[s+o]=e[o];y[s+3]=i},T=u(),C=u(),I=u(),P=u(),k=(t,i,s,o)=>{j(T,i),j(C,s),j(I,o),h(T,T,C),e(T,T),h(I,I,C),e(I,I),r(P,T,I),e(P,P);const n=a(P,C);H(t,P,n)};k(0,0,1,2),k(1,1,0,4),k(2,1,5,2),k(3,3,2,6),k(4,4,0,3),k(5,4,6,5);const A=(t,e,i,s)=>{const o=4*t;return y[o]*e+y[o+1]*i+y[o+2]*s-y[o+3]},D=(t,e,i,s)=>A(t,e,i,s)>=-1,E=(t,e)=>D(t,e[0],e[1],e[2]),w=2**this.lij[0]>2*this.lij[1],U=(t,e,s)=>Math.sqrt(F(t,e,s,o[0],o[1],o[2]))<i,q=t=>U(t[0],t[1],t[2]),N=(t,e)=>U(t[e],t[e+1],t[e+2]),G=this.extentInRadians,z=.5*(G[0]+G[2]),O=G[1],W=G[3],J=u(),K=u();L(J,z,W,g),L(K,z,O,g);const Q=w?"Upper":"Lower";let X=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const i=3*t,s=D(e,b[i],b[i+1],b[i+2]);X&&=s,S(s,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}S(E(e,K),`Tile[${this.lij}] (${Q}) bottom mid outside of plane ${e}`),S(E(e,J),`Tile[${this.lij}] (${Q}) top mid outside of plane ${e}`)}S(X,"Not all convex hull points are inside  convex hull polyhedron"),S(q(K),`Tile[${this.lij}] (${Q}) bottom mid outside of bounding sphere`),S(q(J),`Tile[${this.lij}] (${Q}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=N(b,3*e);S(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}for(let e=0;e<6;++e)for(let t=0;t<8;++t){const i=3*t;D(e,b[i],b[i+1],b[i+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const{extentInRadians:Y}=this,Z=Math.max(Y[2]-Y[0],Y[3]-Y[1]),tt=Math.round(Z*p),{renderData:et}=this;if(!et)return;const{geometry:it,geometryState:st,localOrigin:ot}=et,nt=it.vertexAttributes?.position;if(!nt)return;const rt=u(),at=it.numVerticesPerSide-2,{indices:lt,indexCount:ht,edgeVerticesStartIndex:ut,poleVerticesStartIndex:dt}=it;if(!lt)return;const ct=new Set;for(let e=0;e<ht;++e){const t=lt[e];if(ct.has(t))continue;ct.add(t);const r=t<dt,a=t>=ut;let h=!1,u=-1;if(a){let e=ut;for(let i=0;i<4;++i){const s=st.edgeResolutions[i];if(t===e||t===e+s-1){h=!0;break}if(e+=s,t<e){u=i;break}}}const c=a?st.edgePeerNeighbors[u]:null,g=a&&c&&R(this,c)>0;nt.getVec(t,d),s(rt,d,ot);const v=n(rt)-p;let M=0,b=!1;const j=f-v,y=v-m,B=j>x,S=y>x,V=B||S,H=()=>{const e=r?"internal":a&&!h?"edge":h?"corner":"pole";return`Tile[${this.lij}].vertex[${t}]:${e}`+(B?"(below)":S?"(above)":"")+(g?"(Neighbor)":"")},T=l(rt,o);if(T>=i+$){const t=T-i;V||(console.error(`${H()} is out of the bounding sphere by ${t.toFixed(0)} / ${i.toFixed(0)}[tol=${$}] h=${v.toFixed(0)} / [${f.toFixed(0)}..${m.toFixed(0)}] (${(t/i).toFixed(0)})`),b=!0)}for(let e=0;e<6;++e)if(!D(e,rt[0],rt[1],rt[2])){const s=A(e,rt[0],rt[1],rt[2]),o=t%at,n=(t-o)/at;0===e&&j||5===e&&y||(console.error(`${H()} (${o},${n})|${at}] is out of the bounding trapezoid plane ${e} h=${Math.round(v)} / [${Math.round(f)}..${Math.round(m)}] dist=${Math.round(s)} radii = ${Math.round(i)}/${Math.round(_)}} : maxL = ${tt}`),++M)}if(b||M>0)break}}get convexHull(){return this._convexHull}}const C=[128,64,64,32,16,8,8,4];function I(t,e,i){return F(t[0],t[1],t[2],e[i],e[i+1],e[i+2])}function F(t,e,i,s,o,n){const r=s-t,a=o-e,l=n-i;return r*r+a*a+l*l}const L=(t,e,i,s)=>{const o=Math.cos(e),n=Math.sin(e),r=Math.cos(i),a=Math.sin(i);t[0]=s*r*o,t[1]=s*r*n,t[2]=s*a},P=[0,0,1],k=u(),A=u(),D=u();export{T as SphericalPatch};
