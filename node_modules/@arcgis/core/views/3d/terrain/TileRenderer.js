/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import"../../../core/has.js";import{disposeMaybe as e,releaseMaybe as t}from"../../../core/maybe.js";import{set as r,copy as s}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{ZEROS as o}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{fromValues as i}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{isBaseLayer as a,isGroupLayer as n,isReferenceLayer as c}from"../../../layers/support/layerUtils.js";import{isLayerViewWithFlowRenderer as u}from"../support/flowUtils.js";import{BlendLayersPassParameters as l}from"./BlendLayersTechnique.js";import{isImageWithType as p}from"./TerrainData.js";import{isBlendableLayerView as h,isVectorTileLayerView as d,isVectorTileRenderInfo as m,isImageryTileRenderInfo as f,isImageSourceRenderInfo as _,isTextureTileRenderInfo as x,isVectorTilePerLayerInfo as T}from"./terrainUtils.js";import{TextureReference as b}from"./TextureReference.js";import{TileCompositor as y}from"./TileCompositor.js";import{TileRenderInfo as g}from"./TileRenderInfo.js";import{TileTexture as w,getCacheKey as k}from"./TileTexture.js";import{fallsWithinLayerView as I}from"./tileUtils.js";import{blendModeFromString as j}from"../webgl-engine/core/shaderLibrary/output/BlendOptions.js";import{createEmptyTexture as O}from"../webgl-engine/lib/glUtil3D.js";import{isCompressible as P}from"../../support/TextureCompressionWorkerHandle.js";import{Texture as L}from"../../webgl/Texture.js";import{TextureDescriptor as B}from"../../webgl/TextureDescriptor.js";class C{constructor(e,t,r,s,o,i){this.start=e,this.end=t,this.blendMode=r,this.opacity=s,this.output=o,this.baseOpacity=i}}class M{constructor(e,t,r,s,o){this._rctx=e,this.tileSize=t,this._techniques=r,this._cache=s,this._compressionTracker=o,this._passParameters=new l,this._backgroundColor=null,this._maxAnisotropy=this._rctx.parameters.maxMaxAnisotropy,this._compositor=new y(this._rctx,this._techniques)}dispose(){this._compositor=e(this._compositor),this._backgroundTexture=t(this._backgroundTexture)}get backgroundIsGrid(){return null==this._backgroundColor}get backgroundColor(){return this._backgroundColor}updateHeading(e){this._compositor?.updateHeading(e)}updateTileTexture(e,t){if(!e.renderData)return;const r=e.surface,s=r.baseOpacity;let o=0,i=0,l=this.tileSize,p=!1,m=!1;const f=r.view.state.contentPixelRatio;let _=!1;A.clear(),S.length=0;const x=e.layerInfo[1];let T=0,b=null;for(;T<x.length;T++){const t=r.layerViewByIndex(T,1),y=t.layer,g=!I(e,t),w=y.opacity,k=t.fullOpacity;if(m=m||a(y),u(t))continue;if(h(t)){let e="normal"!==t.layer.blendMode;if(n(y.parent)){const t=y.parent.uid;null!=t&&""!==t&&(e=U(y.parent)||e)}e&&(_=e,p=!1)}if((g||0===w)&&!_){x[T].pendingUpdates&=-1;continue}++i;const j=d(t),O=D(e,T,j);if(O){if(x[T].pendingUpdates&=-1,n(y.parent)){const e=y.parent.uid;null!=e&&""!==e&&v(y.parent,T)}j?l=Math.max(l,this.tileSize*f):1===s&&1===k&&(t.isOpaque||this._dataToTexture(O,c(y))&&O.sourceLayerInfo.data.descriptor.isOpaque)&&(p=!0),++o,null===b&&(b=T)}}const y=l/this.tileSize;0!==o&&null!==b?1===o&&!_&&this._useLayerTexture(e,b)||this._composeLayers(e,t,T-1,m,l,y,!p||_,A,_):this._useBackgroundTexture(e,i,0!==t)}setBackground(e){this._backgroundColor!==e&&(this._backgroundColor=e,this._backgroundTexture&&this._drawBackgroundTexture(this._backgroundTexture))}_ensureBackgroundTexture(){return null==this._backgroundTexture&&(this._backgroundTexture=this._buildTexture(this.tileSize,!1),this._drawBackgroundTexture(this._backgroundTexture)),this._backgroundTexture}_drawBackgroundTexture(e){this._compositor.bind(this.tileSize),this._passParameters.offset=o,this._passParameters.scale=1,this._passParameters.opacity=1,this.backgroundColor&&(this._passParameters.backgroundColor=this.backgroundColor),this._compositor.drawBackground(this._passParameters,null!=this.backgroundColor),this._compositor.copyFBOToTexture(e),this._compositor.unbind()}_useBackgroundTexture(e,t,r){const s=e.renderData,o=!r&&null!=s.textureReference&&(e.surface.view.layerViewManager.updating||t>0)?5e3:0,i=this._ensureBackgroundTexture();s.setTextureReference(new b(i,0,E,e.surface.baseOpacity,0,1),o)}_useLayerTexture(e,t){const r=e.surface.layerViewByIndex(t,1),s=a(r.layer),o=s?e.surface.baseOpacity:1,n=s?1:e.surface.baseOpacity,u=r.fullOpacity,l=D(e,t,!1);return!!this._dataToTexture(l,c(r.layer))&&(e.renderData.setTextureReference(new b(l.sourceLayerInfo.data,0,i(l.offset[0],l.offset[1],l.scale,l.scale),o,n,u)),!0)}_composeLayers(e,t,r,s,i,n,l,p,_){this._compositor.ensureBuffer(i);const x=e.surface.baseOpacity;let T=!1,y=9987,g=!1,w=0;for(let b=r;b>=0;b--){const t=e.surface.layerViewByIndex(b,1),r=t.layer,k=d(t),O=D(e,b,k),P=r.opacity,L=!I(e,t);if(!O||(0===P||L)&&!_)continue;if(u(t))continue;const B=!a(r)&&!T;B&&(T=!0);let C=!1;p.forEach(e=>{e.start===b&&(e.output=s?1:l&&B?this.backgroundIsGrid?3:2:1,e.baseOpacity=B?x:1,S.push(e),this._compositor.openGroup(i),C=!0)});const M=C?4:l&&0===w?this.backgroundIsGrid?3:2:1,U=j[h(t)?t.layer.blendMode:"normal"];for(this._passParameters.baseOpacity=B&&!C&&x<1?x:1,this._passParameters.opacity=P,m(O)?g=this._compositor.drawVectorData(this._passParameters,M,i,U,O,n,this.tileSize,g):f(O)?(this._compositor.drawRasterData(this._passParameters,M,i,U,O),R(O)&&(y=9728)):this._dataToTexture(O,c(r))&&(this._passParameters.texture=O.sourceLayerInfo.data.texture,this._passParameters.offset=O.offset,this._passParameters.scale=O.scale,this._compositor.drawImageData(this._passParameters,M,i,U));S.length>0&&S[S.length-1].end===b;){const e=S.pop();this._passParameters.baseOpacity=e.baseOpacity,this._passParameters.opacity=e.opacity,this._passParameters.offset=o,this._passParameters.scale=1,this._compositor.drawGroup(this._passParameters,e.output,i,j[e.blendMode])}w++}const k=e.renderData,O=_||T&&x<1,P=k.ensureTexture(i,O,t,()=>this._buildTexture(i,O,y));this._compositor.copyFBOToTexture(P),this._compositor.unbind(),k.setTextureReference(new b(P,t,E,T?1:x,0,1))}_dataToTexture(e,t){if(_(e)){const r=e.sourceLayerInfo,s=1===e.scale&&!t;r.data=this._buildTexture(r.data,!0,s,e.tile.onCompressionFinished),e.tile.setMemoryDirty()}return x(e)}_buildTexture(e,t,r=9987,s=()=>{}){if(null==e)return null;const o=new B;o.wrapMode=33071,o.samplingMode="boolean"==typeof r?9987:r,o.maxAnisotropy=this._maxAnisotropy,o.preMultiplyAlpha=!0,o.flipped=!0,o.hasMipmap=!0,t||(o.pixelFormat=6407);const i=this._rctx,a="boolean"==typeof r&&r;let n;if("number"==typeof e)o.width=o.height=e,n=this._buildTileTexture(o);else if(p(e))o.isOpaque=e.isOpaque,o.isOpaque&&(o.pixelFormat=6407),o.width=e.element.width,o.height=e.element.height,n=this._buildTileTexture(o,a,s,e.element);else try{o.width=e.width,o.height=e.height,n=this._buildTileTexture(o,a,s,e)}catch(u){n=new w(O(i)),console.warn("TileRenderer: failed to execute 'texImage2D', cross-origin image may not be loaded.")}const c=i.bindTexture(n.texture,L.TEXTURE_UNIT_FOR_UPDATES);return n.generateMipmap(),i.bindTexture(c,L.TEXTURE_UNIT_FOR_UPDATES),n}_buildTileTexture(e,t=!1,r=()=>{},s){const o=this._cache.pop(k(e,!1))??this._cache.pop(k(e,!0));if(t&&=P(s,e),o)return o.retain(),t?o.texture.enableCompression({compressionTracker:this._compressionTracker,compressionCallback:r}):o.texture.disableCompression(),o.texture.setData(s),o;e.compress=t?{compressionTracker:this._compressionTracker,compressionCallback:r}:void 0;const i=new L(this._rctx,e,s);return new w(i,this._cache)}get test(){}}function D(e,t,o){q.layerIndex=t,q.vtlNeighborInfos.clear();const i=e.layerInfo[1][t];if(r(q.offset,0,0),q.tile=e,q.scale=1,q.sourceLod=e.lij,q.sourceLayerInfo=i,q.isVTLBackground=o,i.data)return o&&e.forEachLoadedNeighbor((r,s)=>{if(r.level!==e.level)return;const o=r.layerInfo[1][t];if(!T(o)||i.data===o.data)return;const a=q.vtlNeighborInfos.pushNew();a.offset=z[s],a.sourceLod=r.lij,a.sourceLayerInfo=o}),q;const a=i.upsampleInfo,n=a?.tile?.layerInfo[1][t];return n&&a.tile?(q.tile=a.tile,s(q.offset,a.offset),q.scale=a.scale,q.sourceLod=a.tile.lij,q.sourceLayerInfo=n,q):o?q:null}function R(e){const t=e.sourceLayerInfo.data;return!!t.source&&"nearest"===t.interpolation}function U(e){let t="normal"!==e.blendMode;return n(e.parent)&&(t=U(e.parent)||t),t}function v(e,t){n(e.parent)&&v(e.parent,t);const r=e.uid;if(null!=r&&""!==r){const s=A.get(r);s?s.start=t:A.set(r,new C(t,t,e.blendMode,e.opacity,1,1))}}const A=new Map,S=new Array,q=new g,E=i(0,0,1,1),z=new Array;function F(){q.sourceLayerInfo=null,q.tile=null,q.vtlNeighborInfos.prune()}z[0]=[0,-1],z[1]=[-1,-1],z[2]=[-1,0],z[3]=[-1,1],z[4]=[0,1],z[5]=[1,1],z[6]=[1,0],z[7]=[1,-1];export{C as GroupInfo,M as TileRenderer,F as cleanupTileRenderer};
