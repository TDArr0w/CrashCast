/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clamp as t,isPowerOfTwo as e}from"../../../core/mathUtils.js";import{maxUint16 as n}from"../../../core/typedArrayUtil.js";import{empty as o}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as s}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as r}from"./ElevationData.js";import{PatchGeometryLUT as i}from"./PatchGeometryLUT.js";import{zeroToFour as a,neighborTileIfLoadedOrSelf as c}from"./PatchRenderData.js";import{internalAssert as l,enableTerrainInternalChecks as u,neighborEdgeIndices as d,almostEquals as f}from"./terrainUtils.js";import{isCornerNeighbor as m}from"./Tile.js";import{compareTilesByLij as g}from"./tileUtils.js";import{compressNormal as h}from"../webgl-engine/lib/Normals.js";const p=65536;function x(t,e){const{tile:n,geometry:s,geometryState:r}=t,{extentInRadians:i,surface:a}=n,{isWebMercator:c,renderer:l}=a,{numVerticesPerSide:u,wireframe:d}=r,f=u-1,m=(u-2)**2,g=c&&(2===e||3===e),h=c&&(1===e||3===e),p=((g?1:0)+(h?1:0))*mt*u,x=ut(r),S=m+p+4*x,v=l.tileGeometryCache.acquire(S);s.numVerticesPerSide=u,s.vertexAttributes=v,s.maxEdgeVertexCount=x;const{boundingBox:V}=s;o(V);const B=P(t);ot.update(f,i,B),y(t),s.poleVerticesStartIndex=m;const b=M(t,g,h);s.edgeVerticesStartIndex=m+p,Q(t),I(t),W(s,b,d),t.intersectionData=null}function M(t,e,o){const{tile:s,localOrigin:r,geometry:i}=t,{extent:a,ellipsoid:c}=s,{boundingBox:l,numVerticesPerSide:u,vertexAttributes:d,poleVerticesStartIndex:f}=i,m=u-1,g=r[0],p=r[1],x=r[2],M=c.radius,y=a[1],S=a[3],v=[];let V=f;const I=(t,e)=>{const o=e*u;lt(-g,-p,t*M-x,l),v.push(new et(1===t,o,1===t?0:2,V,mt));const s=C(-1===t?y:S,M),r=t*Math.PI/2-s,i=.99*(1===t?1:-1),a=M+0,{position:c,uv0:f}=d,{typedBuffer:I,typedBufferStride:B}=d.normalCompressed;for(let u=1;u<=mt;++u){const t=s+r*(u/mt),e=Math.cos(t),o=Math.sin(t);for(let s=0;s<=m;s++){const t=s/m,r=ot.sinLonLUT[s],u=ot.cosLonLUT[s]*e,d=r*e,M=o,y=u*a-g,S=d*a-p,v=M*a-x;lt(y,S,v,l),c.setValues(V,y,S,v),f.setValues(V,Math.round(t*n),Math.round(i*n)),h(I,V,u,d,M,B),++V}}};return e&&I(-1,0),o&&I(1,m),v}function y(t){const{tile:e}=t;if(!e.intersectsClippingArea)return;const{geometry:o,geometryState:s,localOrigin:i}=t,{numVerticesPerSide:a,samplerData:c}=s,l=a-2,u=a-1,{vertexAttributes:d,boundingBox:f}=o,{position:m,uv0:g}=d,{typedBuffer:p,typedBufferStride:x}=d.normalCompressed,{extent:M}=e,y=M[0],S=M[2],v=M[1],V=M[3],I=e.ellipsoid.radius,B=i[0],b=i[1],C=i[2],L=m.typedBuffer,A=m.typedBufferStride,P=1/u;let D=0;if(1<=l){const t=P,e=v*(1-t)+V*t,o=ot.sinLatLUT[1],s=ot.cosLatLUT[1];for(let i=1;i<=l;i++){const a=i*P,l=y*(1-a)+S*a,u=ot.sinLonLUT[i],d=ot.cosLonLUT[i],m=I+r(l,e,c),h=m*d*s-B,p=m*u*s-b,x=m*o-C;lt(h,p,x,f);const M=(i-1)*A;L[M]=h,L[M+1]=p,L[M+2]=x,g.setValues(i-1,Math.round(a*n),Math.round(t*n))}}for(let E=1;E<=l;E++){const t=E*P,e=v*(1-t)+V*t,o=ot.sinLatLUT[E],s=ot.cosLatLUT[E],i=E+1,a=i*P,d=v*(1-a)+V*a,m=ot.sinLatLUT[i],M=ot.cosLatLUT[i],T=ot.sinLonLUT[0],O=ot.cosLonLUT[0],R=I+r(y,e,c);let U=O*s*R-B,w=T*s*R-b,N=o*R-C;const j=D*A;let F=L[j],q=L[j+1],W=L[j+2];for(let V=1;V<=l;V++){const t=V*P,i=y*(1-t)+S*t,T=ot.sinLonLUT[V],O=ot.cosLonLUT[V];let R=0,j=0,k=0;if(V<l){const t=(D+1)*A;R=L[t],j=L[t+1],k=L[t+2]}else{const t=ot.sinLonLUT[u],n=ot.cosLonLUT[u],i=I+r(S,e,c);R=n*s*i-B,j=t*s*i-b,k=o*i-C}const z=U,G=w,H=N;U=F,w=q,N=W,F=R,q=j,W=k;const J=R-z,K=j-G,Q=k-H;let X=0,Y=0,Z=0;if(E>1){const t=(D-l)*A;X=L[t],Y=L[t+1],Z=L[t+2]}else{const t=ot.sinLatLUT[0],e=ot.cosLatLUT[0],n=I+r(i,v,c);X=O*e*n-B,Y=T*e*n-b,Z=t*n-C}const $=I+r(i,d,c),_=O*M*$-B,tt=T*M*$-b,et=m*$-C;if(E<l){const e=D+l,o=e*A;L[o]=_,L[o+1]=tt,L[o+2]=et,lt(_,tt,et,f),g.setValues(e,Math.round(t*n),Math.round(a*n))}const nt=X-_,st=Y-tt,rt=Z-et;let it=O*s,at=T*s,ct=o;ct*ct<.999&&(it=Q*st-K*rt,at=J*rt-Q*nt,ct=K*nt-J*st);const ut=1/Math.sqrt(it*it+at*at+ct*ct);h(p,D,it*ut,at*ut,ct*ut,x),++D}}}function S(t){t.tile.intersectsClippingArea&&(I(t),_(t),t.intersectionData=null)}function v(t){t.tile.intersectsClippingArea&&(X(t),I(t),_(t),tt(t),t.intersectionData=null)}function V(t){t.tile.intersectsClippingArea&&(b(t),B(t,!0),_(t),t.intersectionData=null)}function I(t){t.tile.intersectsClippingArea&&(b(t),B(t))}function B(t,o=!1){const{geometry:s,geometryState:i,tile:a,localOrigin:m}=t,{level:h,extent:p,extentInRadians:x,ellipsoid:M}=a,y=M.radius,S=x[0],v=x[2],V=x[1],I=x[3],{samplerData:B}=i,b=p[0],C=p[2],L=p[1],A=p[3],D=P(t),{boundingBox:E,vertexAttributes:T}=s,O=m[0],R=m[1],U=m[2],{position:w,uv0:N}=T,j=w.typedBuffer,F=w.typedBufferStride;for(let P=0;P<4;++P){const m=1===P||3===P,x=i.edgeResolutions[P];l(e(x));const M=x+1,T=c(a,i.edgePeerNeighbors[P]);if(it(a,T,P)){Y(t,P,T);continue}const w=null!=T;l(!w||T.level===a.level),l(!w||g(a,T)<=0);const q=T?.renderData,W=q?.geometryState;if(u){const t=a.surface;if(!T&&t&&!t.updatingRootTiles){const e=d[P],n=a.findNeighborTile(e,t=>t.loaded||t.leaf||t.level===a.level);n?n.intersectsClippingArea&&(l(!n.loaded),l(!n.leaf),l(n.level===h)):l(null==t?.rootTiles||!a.shouldHaveNeighbor(e))}}const k=1===P?p[2]:p[0],z=T?.extent,G=z&&m?1===P?z[0]:z[2]:k,H=0===P?p[3]:p[1],J=1===P?1:0,K=0===P?1:0,Q=1===P?v:S,X=0===P?I:V,Z=Math.sin(Q),$=Math.cos(Q),_=Math.sin(X),tt=Math.cos(X),et=W?.samplerData,nt=w?(t,e,n)=>.5*(r(t,e,B)+r(n,e,et)):(t,e,n)=>r(t,e,B),ot=s.outerEdgesOffsetAndLength[2*P+0],st=o&&M>3?M-3:1,rt=null!=B&&B.some(t=>null!=t),at=null!=et&&et.some(t=>null!=t),ct=rt||at,ut=1/x,dt=ot;l(!z||f(z[2]-z[0],p[2]-p[0]));(()=>{const t=1===P?-1:3===P?1:0,e=0===P?-1:2===P?1:0,o=(p[2]-p[0])*ut,i=t*o,a=e*o,c=m?t*((v-S)*ut):0,l=m?0:e*ut,u=K,d=m?Q+c:Q,f=m?Math.sin(d):Z,g=m?Math.cos(d):$,h=m?Q-c:Q,x=m?Math.sin(h):Z,V=m?Math.cos(h):$,I=m?X:D(u+l),T=m?_:Math.sin(I),q=m?tt:Math.cos(I),W=m?X:D(u-l),z=m?_:Math.sin(W),Y=m?tt:Math.cos(W);let ot=0,rt=0,it=0;{const t=0*ut,e=m?k:b*(1-t)+C*t,n=m?G:e,o=m?L*(1-t)+A*t:H,s=m?Q:S*(1-t)+v*t,r=m?Z:Math.sin(s),i=m?$:Math.cos(s),a=m?D(t):X,c=m?Math.sin(a):_,l=m?Math.cos(a):tt,u=y+nt(e,o,n);ot=i*l*u,rt=r*l*u,it=c*u}let at=0,ft=0,mt=0;{const t=1*ut,e=m?k:b*(1-t)+C*t,n=m?G:e,o=m?L*(1-t)+A*t:H,s=m?Q:S*(1-t)+v*t,r=m?Z:Math.sin(s),i=m?$:Math.cos(s),a=m?D(t):X,c=m?Math.sin(a):_,l=m?Math.cos(a):tt,u=y+nt(e,o,n);at=i*l*u,ft=r*l*u,mt=c*u}for(let p=1;p<M-1;p+=st){let t=0,e=0,o=0;{const n=(p+1)*ut,s=m?k:b*(1-n)+C*n,r=m?G:s,i=m?L*(1-n)+A*n:H,a=m?Q:S*(1-n)+v*n,c=m?Z:Math.sin(a),l=m?$:Math.cos(a),u=m?D(n):X,d=m?Math.sin(u):_,f=m?Math.cos(u):tt,g=y+nt(s,i,r);t=l*f*g,e=c*f*g,o=d*g}const c=t,l=e,u=o,d=at,h=ft,M=mt;at=c,ft=l,mt=u;{const t=dt+p,e=t*F,o=d-O,s=h-R,r=M-U;j[e]=o,j[e+1]=s,j[e+2]=r,lt(o,s,r,E);const i=p*ut,a=m?J:i,c=m?i:K;N.setValues(t,Math.round(a*n),Math.round(c*n))}const I=ot,W=rt,st=it;ot=d,rt=h,it=M;const gt=d,ht=h,pt=M,xt=1/Math.sqrt(gt*gt+ht*ht+pt*pt),Mt=pt*xt;let yt=0,St=0,vt=0;if(ct&&Mt*Mt<.999){let t=0,e=0,n=0;{const o=0===P?-1:1;t=o*(c-I),e=o*(l-W),n=o*(u-st)}{const o=p*ut,s=m?k:b*(1-o)+C*o,c=m?G:s,l=m?L*(1-o)+A*o:H,u=m?Q:S*(1-o)+v*o,d=m?Z:Math.sin(u),h=m?$:Math.cos(u),M=m?D(o):X,I=m?Math.sin(M):_,E=m?Math.cos(M):tt;let O=gt,R=ht,U=pt;if(w){const t=y+r(c-i,l-a,et),e=m?E:Y;O=(m?V:h)*e*t,R=(m?x:d)*e*t,U=(m?I:z)*t}{const o=y+r(s+i,l+a,B),c=m?E:q,u=(m?g:h)*c*o,p=(m?f:d)*c*o,x=(m?I:T)*o;w||(O=2*gt-u,R=2*ht-p,U=2*pt-x);const M=3===P?-1:1,S=M*(O-u),v=M*(R-p),V=M*(U-x);yt=n*v-e*V,St=t*V-n*S,vt=e*S-t*v;const b=1/Math.sqrt(yt*yt+St*St+vt*vt);yt*=b,St*=b,vt*=b}}}else yt=gt*xt,St=ht*xt,vt=pt*xt;s.setEdgeNormalFromValues(P,p,yt,St,vt)}})()}}function b(t){Z(t)}function C(t,e){return Math.PI/2-2*Math.atan(Math.exp(-t/e))}function L(t,e,n,o){return C(t*(1-o)+e*o,n)}function A(t,e,n){return t*(1-n)+e*n}function P(t){const{tile:e}=t;if(e.surface.isWebMercator){const t=e.extent,n=e.ellipsoid.radius;return e=>L(t[1],t[3],n,e)}const n=e.extentInRadians;return t=>A(n[1],n[3],t)}function D(t,e){const{tile:n,geometryState:s,geometry:r}=t,{extent:i,surface:a}=n,{wireframe:c}=s,l=i[0],u=i[1],d=i[2]-l,f=i[3]-u,{numVerticesPerSide:m,clippingArea:g}=s,h=null!=g?Math.max(0,(g[0]-l)/d):0,p=null!=g?Math.max(0,(g[1]-u)/f):0,x=null!=g?Math.min(1,(g[2]-l)/d):1,M=null!=g?Math.min(1,(g[3]-u)/f):1,y=(m-2)**2,S=ut(s),v=y+4*S,V=a.renderer.tileGeometryCache.acquire(v),{boundingBox:I}=r;o(I),r.numVerticesPerSide=m,r.vertexAttributes=V,r.maxEdgeVertexCount=S,r.minu=h,r.minv=p,r.maxu=x,r.maxv=M,E(t),r.edgeVerticesStartIndex=y,Q(t),U(t),W(r,[],c),t.intersectionData=null}function E(e){const o=e.tile;if(!o.intersectsClippingArea)return;const{geometry:s,geometryState:i,localOrigin:a}=e,{samplerData:c,clippingArea:l,numVerticesPerSide:u}=i,{surface:d,extent:f,ellipsoid:m}=o,{isWebMercatorOnPlateCarree:g}=d,p=null!=l?l:st,x=f[0],M=f[1],y=f[2],S=f[3],v=Math.max(x,p[0]),V=Math.min(y,p[2]),I=Math.max(M,p[1]),B=Math.min(S,p[3]),b=m.radius,C=o.horizontalScale,L=u-1,A=u-2,{minu:P,minv:D,maxu:E,maxv:T,boundingBox:O,vertexAttributes:R}=s,{position:U,uv0:w}=R,{typedBuffer:N,typedBufferStride:j}=R.normalCompressed,F=a[0],q=a[1],W=a[2],k=U.typedBuffer,z=U.typedBufferStride;let G=0;const H=t(M,I,B),J=g?(Math.PI/2-2*Math.atan(Math.exp(-H/b)))*b:H*C,K=1/L,Q=t(M*(1-K)+S*K,I,B);let X=J,Y=g?(Math.PI/2-2*Math.atan(Math.exp(-Q/b)))*b:Q*C;for(let Z=1;Z<=A;Z++){const e=Z/L,o=t(M*(1-e)+S*e,I,B),s=t(e,D,T),i=Y,a=(Z-1)/L,l=t(M*(1-a)+S*a,I,B),u=X,d=(Z+1)/L,f=t(M*(1-d)+S*d,I,B),m=g?(Math.PI/2-2*Math.atan(Math.exp(-f/b)))*b:f*C,p=t(d,D,T);X=Y,Y=m;const R=t(x,v,V);let U=R*C,H=r(R,o,c);const J=1/L,K=t(J,P,E),Q=t(x*(1-K)+y*K,v,V);let $=K,_=Q,tt=Q*C,et=r(Q,o,c);if(1===Z){const e=tt-F,o=X-q,r=et-W,i=0*z;k[i]=e,k[i+1]=o,k[i+2]=r,lt(e,o,r,O);const a=t(J,P,E);w.setValues(G,Math.round(a*n),Math.round(s*n))}for(let g=1;g<=A;g++){const e=tt,a=et,d=(g+1)/L,M=t(d,P,E),S=t(x*(1-d)+y*d,v,V),I=_;_=S;{const t=G+1,e=t*z;if(1===Z||g===A){const a=S*C,l=r(S,o,c);if(1===Z&&g<A){const o=a-F,r=i-q,c=l-W;k[e]=o,k[e+1]=r,k[e+2]=c,lt(o,r,c,O),w.setValues(t,Math.round(M*n),Math.round(s*n))}tt=a,et=l}else tt=k[e]+F,et=k[e+2]+W}const B=tt,b=et,D=U,T=H;U=e,H=a;const R=(G-A)*z,J=1===Z?r(I,l,c):k[R+2]+W,K=r(I,f,c);if(Z<A){const t=G+A,o=t*z,s=e-F,r=m-q,i=K-W;k[o]=s,k[o+1]=r,k[o+2]=i,lt(s,r,i,O);const a=$;$=M,w.setValues(t,Math.round(a*n),Math.round(p*n))}{const t=B-D,e=u-m,n=e*(b-T),o=t*(J-K),s=-e*t,r=n*n+o*o+s*s;if(0===r)h(N,G,0,0,1,j);else{const t=1/Math.sqrt(r);h(N,G,n*t,o*t,s*t,j)}}++G}}}function T(t,e){t.tile.intersectsClippingArea&&(N(t),w(t,!0),_(t),t.intersectionData=null)}function O(t,e){t.tile.intersectsClippingArea&&(X(t),U(t),_(t),tt(t),t.intersectionData=null)}function R(t,e){t.tile.intersectsClippingArea&&(U(t),_(t),t.intersectionData=null)}function U(t,e){t.tile.intersectsClippingArea&&(N(t),w(t,!1))}function w(n,o){const{geometry:s,geometryState:i,localOrigin:a}=n,f=n.tile,{surface:m,extent:h}=f,{clippingArea:p,samplerData:x}=i,M=null!=p?p:st,y=h[0],S=h[2],v=h[1],V=h[3],I=[V>M[3],S>M[2],v<M[1],y<M[0]],B=f.horizontalScale,b=q(m.isWebMercatorOnPlateCarree,f.ellipsoid.radius,B),{minu:C,minv:L,maxu:A,maxv:P,boundingBox:D}=s,E=Math.max(y,M[0]),T=Math.min(S,M[2]),O=Math.max(v,M[1]),R=Math.min(V,M[3]),U=a[0],w=a[1],N=a[2];for(let j=0;j<4;++j){const a=1===j||3===j,h=i.edgeResolutions[j];l(e(h));const p=h+1,M=I[j],F=c(f,i.edgePeerNeighbors[j]);if(!M&&it(f,F,j)){Y(n,j,F);continue}const q=null!=F&&!M,W=F?.renderData,k=W?.geometryState;if(u&&(l(!q||F.level===f.level),l(!q||g(f,F)<=0),f&&!F&&!m.updatingRootTiles)){const t=d[j],e=f.findNeighborTile(t,t=>t.loaded||t.leaf||t.level===f.level);m.updatingRootTiles||(e?e.intersectsClippingArea&&(l(!e.loaded),l(!e.leaf),l(e.level===f.level)):l(null==m?.rootTiles||!f.shouldHaveNeighbor(t)))}const z=t(1===j?S:y,E,T),G=t(0===j?V:v,O,R),H=k?.samplerData,J=o&&p>3?p-3:1,K=t(1===j?1:0,C,A),Q=t(0===j?1:0,L,P),X=q?(t,e)=>.5*(r(t,e,H)+r(t,e,x)):(t,e)=>r(t,e,x),Z=(S-y)/h,$=a?1===j?Z:-Z:0,_=a?0:0===j?Z:-Z,tt=-$,et=-_;let nt=0,ot=0,st=0;{const e=0/h,n=a?z:t(y*(1-e)+S*e,E,T),o=a?t(v*(1-e)+V*e,O,R):G,s=X(n,o);nt=n*B,ot=b(o),st=s}let rt=0,at=0,ct=0;{const e=1/h,n=a?z:t(y*(1-e)+S*e,E,T),o=a?t(v*(1-e)+V*e,O,R):G,s=X(n,o);rt=n*B,at=b(o),ct=s}for(let e=1;e<p-1;e+=J){const n=e/h,o=rt,i=at,c=ct;{const r=a?K:t(n,C,A),l=a?t(n,L,P):Q,u=o-U,d=i-w,f=c-N;lt(o,d,f,D),s.setEdgeVertexFromValuesRawPositionUV(j,e,u,d,f,r,l)}{const n=(e+1)/h,o=a?z:t(y*(1-n)+S*n,E,T),s=a?t(v*(1-n)+V*n,O,R):G,r=X(o,s);rt=o*B,at=b(s),ct=r}const l=rt,u=ct,d=nt,f=ot,m=st;nt=o,ot=i,st=c;let g=0,p=0,M=0;if(a){const e=at-i,s=u-c,a=f-i,l=m-c,d=t(v*(1-n)+V*n,O,R),h=z+tt,y=h*B-o,S=r(h,d,x)-c,I=3===j?-1:1;if(g=I*(-a+e)*S,p=I*y*(-l+s),M=-I*y*(-a+e),q){const t=z+$,n=t*B-o;g=(-a+e)*(S-(r(t,d,H)-c)),p=(y-n)*(-l+s),M=-(y-n)*(-a+e)}}else{const e=l-o,s=u-c,a=d-o,f=m-c,h=t(y*(1-n)+S*n,E,T),v=G+et,V=r(h,v,x)-c,I=b(v)-i,B=2===j?-1:1;if(g=B*I*(-f+s),p=B*(-a+e)*V,M=-B*I*(-a+e),q){const t=h,n=G+_,o=b(n)-i;g=(-I+o)*(-f+s),p=(-a+e)*(-V+(r(t,n,H)-c)),M=-(-I+o)*(-a+e)}}const I=1/Math.sqrt(g*g+p*p+M*M);s.setEdgeNormalFromValues(j,e,g*I,p*I,M*I)}}}function N(t,e){Z(t)}function j(t,e){return(Math.PI/2-2*Math.atan(Math.exp(-t/e)))*e}function F(t,e){return t*e}function q(t,e,n){return t?t=>j(t,e):t=>F(t,n)}function W(t,e,n){const{numVerticesPerSide:o,vertexAttributes:s,maxEdgeVertexCount:r}=t,i=o-1,c=s.count,l=2*(o-3)*(o-3),u=4*(i+r-3),d=a.reduce((e,n)=>e+(i+t.getEdgeCount(n)-3),0),f=e.reduce((t,e)=>t+i*(2*(e.latitudeResolution-1)+1),0),m=3*(n?2:1),g=(l+u+f)*m,h=c>=p?new Uint32Array(g):new Uint16Array(g);for(let a=0;a<g;++a)h[a]=0;t.indices=h,t.indexCount=(l+d+f)*m,t.poleIndicesStartIndex=l*m,t.edgeIndicesStartIndex=(l+f)*m,n?(H(t),J(t,e),K(t)):(k(t),z(t,e),G(t))}function k(t){const{numVerticesPerSide:e,indices:n,vertexAttributes:o}=t,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=e-2,c=e-3,l=0,u=e-3;let d=0;for(let f=0;f<c;++f){const t=f*a;for(let e=l;e<u;++e){const o=t+e,s=o+1,c=s+a,l=c-1;dt(o,s,c,l,i,r)?(n[d]=o,n[d+1]=s,n[d+2]=c,n[d+3]=c,n[d+4]=l,n[d+5]=o):(n[d]=o,n[d+1]=s,n[d+2]=l,n[d+3]=l,n[d+4]=s,n[d+5]=c),d+=6}}}function z(t,e){const{numVerticesPerSide:n,indices:o,poleIndicesStartIndex:s}=t,r=n-1;let i=s;for(const a of e){const e=a.isNorth?1:2,s=a.isNorth?2:1,c=a.isNorth?3:4,l=a.isNorth?4:3;let u=t.getEdgeVertexIndex(a.connectedOuterEdgeOffset,0),d=1;for(let t=0;t<a.latitudeResolution;++t){const f=0===t?a.rowOffset:u+n;for(let n=0;n<r;n++){const r=f+n;o[i]=u,o[i+e]=u+1,o[i+s]=r,t<a.latitudeResolution-1?(o[i+c]=u+1,o[i+l]=r+1,o[i+5]=r,i+=6):i+=3,u+=d}u=f,d=1}}}function G(t){const{indices:e,numVerticesPerSide:n,edgeIndicesStartIndex:o}=t,s=n-1,r=s-2;let i=o;for(let a=0;a<4;++a){const n=ct[a];let o=0,c=0;const u=t.getEdgeCount(a),d=n.count;l(d===s-1);const f=1===a||2===a,m=f?1:2,g=f?2:1,h=t.getEdgeFirstVertexIndex(a),p=1,x=n.vertex0Index,M=n.stride;for(;o<u-1||c<d-1;){const t=x+c*M,n=h+o*p,a=o<u-1,l=c<d-1,f=a&&(!l||(a?0+s*(o+.5)/(u-1):0)<=(l?1+r*(c+.5)/(d-1):0));f?++o:++c;const y=f?n+p:t+M;e[i]=t,e[i+m]=n,e[i+g]=y,i+=3}}t.indexCount=i}function H(t){const{indices:e,numVerticesPerSide:n,vertexAttributes:o}=t,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=n-2;let c=0;for(let l=0;l<n-3;++l){const t=l*a;for(let o=0;o<n-3;++o){const n=l*a+o,s=n+1,u=s+a,d=u-1,f=t+o,m=f+1,g=m+a;dt(f,m,g,g-1,i,r)?(ft(e,c,n,s,u),c+=6,ft(e,c,u,d,n)):(ft(e,c,n,s,d),c+=6,ft(e,c,d,u,s)),c+=6}}}function J(t,e){const{indices:n,numVerticesPerSide:o,poleIndicesStartIndex:s}=t,r=o-1;let i=s;for(const a of e){const e=a.connectedOuterEdgeOffset;let s=t.getEdgeVertexIndex(e,0),c=1;for(let t=0;t<a.latitudeResolution;++t){const e=0===t?a.rowOffset:s+o;for(let o=0;o<r;o++)ft(n,i,s,s+1,e+o),i+=6,t<a.latitudeResolution-1&&(ft(n,i,s+1,e+o+1,e+o),i+=6),s+=c;s=e,c=1}}}function K(t){const{indices:e,numVerticesPerSide:n,edgeIndicesStartIndex:o}=t,s=n-1,r=s-2;let i=o;for(let a=0;a<4;++a){const n=ct[a];let o=0,c=0;const u=t.getEdgeCount(a),d=n.count;l(d===s-1);const f=1===a||2===a,m=f?1:3,g=f?3:1,h=t.getEdgeFirstVertexIndex(a),p=1,x=n.vertex0Index,M=n.stride;for(;o<u-1||c<d-1;){const t=x+c*M,n=h+o*p,a=o<u-1,l=c<d-1,f=a&&(!l||(a?0+s*(o+.5)/(u-1):0)<=(l?1+r*(c+.5)/(d-1):0));f?++o:++c;const y=f?n+p:t+M;e[i]=t,e[i+m]=n,e[i+m+1]=n,e[i+g]=y,e[i+g+1]=y,e[i+5]=t,i+=6}}t.indexCount=i}function Q(t){const{geometry:e,geometryState:n}=t,{edgeResolutions:o}=n,{numVerticesPerSide:s,edgeVerticesStartIndex:r}=e,i=s-2;let a=r;for(let c=0;c<4;++c){{const t=0===c||2===c,e=(0===c?i-1:0)*i+(1===c?i-1:0),n=(t?0:1)*i+(t?1:0),o=ct[c];o.vertex0Index=e,o.stride=n,o.count=i}{const t=o[c]+1;e.outerEdgesOffsetAndLength[2*c+0]=a,e.outerEdgesOffsetAndLength[2*c+1]=t,a+=t}}}function X(t){Q(t),t.geometryState.wireframe?K(t.geometry):G(t.geometry)}function Y(o,s,r){const{geometryState:i,geometry:a,tile:c,localOrigin:u}=o,d=1===s||3===s,f=i.edgeResolutions[s];l(e(f));const m=f+1,{boundingBox:g,minu:h,minv:p,maxu:x,maxv:M,vertexAttributes:y}=a,S=t(1===s?1:0,h,x),v=t(0===s?1:0,p,M),V=r.renderData,I=V.geometryState,B=V.geometry,b=(s+2)%4,C=B.getEdgeCount(b),L=c.getNeighborEdgeStartVertexIndex(s,r)*f,A=f*2**(c.level-r.level);l(I.edgeResolutions[b]===A),l(C-1===A);const P=V.localOrigin[0]-u[0],D=V.localOrigin[1]-u[1],E=V.localOrigin[2]-u[2],T=a.getEdgeFirstVertexIndex(s),{position:O,uv0:R}=y,U=O.typedBuffer,w=O.typedBufferStride,N=y.normalCompressed,j=N.typedBuffer,F=N.typedBufferStride,q=B.vertexAttributes,W=B.getEdgeFirstVertexIndex(b),k=q.position.typedBuffer,z=q.position.typedBufferStride,G=q.normalCompressed.typedBuffer,H=q.normalCompressed.typedBufferStride;for(let e=1;e<m-1;++e){const o=T+e,s=W+(L+e),r=o*w,i=s*z,a=k[i]+P,c=k[i+1]+D,l=k[i+2]+E;U[r]=a,U[r+1]=c,U[r+2]=l,lt(a,c,l,g);const u=o*F,m=s*H;j[u]=G[m],j[u+1]=G[m+1];const y=e/f,V=d?S:t(y,h,x),I=d?t(y,p,M):v;R.setValues(o,Math.round(V*n),Math.round(I*n))}}function Z(e){const{geometry:o,geometryState:s,localOrigin:i}=e,{clippingArea:a,samplerData:c}=s,{minu:u,minv:d,maxu:f,maxv:m,boundingBox:h,vertexAttributes:p}=o,x=e.tile,{surface:M,ellipsoid:y,extent:S,extentInRadians:v,horizontalScale:V}=x,I="local"===M.view?.viewingMode,B=y.radius;let b=0,C=0,L=0;const A=(t,e,n)=>{const o=v[0===e?1:3],s=v[0===t?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),c=Math.cos(s),l=B+n;b=c*r*l,C=a*r*l,L=i*l},D=I?(()=>{const e=a,n=null!=e&&(S[3]>e[3]||S[2]>e[2]||S[1]<e[1]||S[0]<e[0]),o=q(M.isWebMercatorOnPlateCarree,B,V);return(s,r,i)=>{const a=0===s?S[0]:S[2],c=0===r?S[1]:S[3],l=n?t(a,e[0],e[2]):a,u=n?t(c,e[1],e[3]):c,d=i;b=l*V,C=o(u),L=d}})():A;let E=0,T=0,O=0,R=0,U=0,w=0,N=0,j=0,F=0;const W=I&&M.isWebMercatorOnPlateCarree,k=(t,e,n,o,s)=>{let r=0,i=0,a=0;if(I){const t=e*V,s=W?(Math.PI/2-2*Math.atan(Math.exp(-n/B)))*B:n*V;r=t-b,i=s-C,a=o-L}else{const s=P(t),c=t.tile,l=c.extent,u=c.extentInRadians,d=(e-l[0])/(l[2]-l[0]),f=(n-l[1])/(l[3]-l[1]),m=u[0]*(1-d)+u[2]*d,g=s(f),h=Math.cos(g),p=Math.sin(g),x=Math.sin(m),M=Math.cos(m),y=B+o;r=M*h*y-b,i=x*h*y-C,a=p*y-L}switch(s){case 0:N+=r,j+=i,F+=a;break;case 1:R-=r,U-=i,w-=a;break;case 2:N-=r,j-=i,F-=a;break;case 3:R+=r,U+=i,w+=a}},z=a??st,G=S[0],H=S[2],J=S[1],K=S[3],Q=[K>z[3],H>z[2],J<z[1],G<z[0]],X=Math.max(G,z[0]),Y=Math.min(H,z[2]),Z=Math.max(J,z[1]),_=Math.min(K,z[3]),tt=t=>Math.max(z[0],Math.min(z[2],t)),et=t=>Math.max(z[1],Math.min(z[3],t)),ot=t=>{const e=s.cornerNeighborCornerTiles;E=0,T=0,O=1,R=0,U=0,w=0,N=0,j=0,F=0;let n=1/0;for(let s=0;s<4;++s){const o=e[4*t+s];n=Math.min(n,o?.level??1/0)}for(let s=0;s<4;++s){const o=e[4*t+s];rt[s]=o?.level===n?o:null}let o=1,i=0;for(let s=0;s<4;++s){const t=rt[s];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),i=t.extent[2]-t.extent[0])}const a=i,c=o;l(c>1);const u=a/c;for(let s=0;s<4;++s){const t=rt[(s+3)%4],e=rt[s%4];if(!t&&!e)continue;const n=0===s?1:1===s?2:2===s?3:0,o=0===s?2:1===s?3:2===s?0:1;if(t&&e){const i=nt[s][0]*u,a=nt[s][1]*u,c=t.extent,l=tt(c[0===n||1===n?2:0]+i),d=et(c[0===n||3===n?3:1]+a),f=e.extent,m=tt(f[0===o||1===o?2:0]+i),g=et(f[0===o||3===o?3:1]+a),h=t.renderData,p=e.renderData,x=r(l,d,h.geometryState.samplerData),M=r(m,g,p.geometryState.samplerData);k(h,l,d,.5*(x+M),s)}else{const i=t??e,a=t?n:o,c=i.extent,l=nt[s],d=tt(c[0===a||1===a?2:0]+l[0]*u),f=et(c[0===a||3===a?3:1]+l[1]*u),m=i.renderData,g=r(d,f,m.geometryState.samplerData);k(m,d,f,g,s)}}if(!I){const t=Math.sqrt(b*b+C*C+L*L);E=b/t,T=C/t,O=L/t}if(I||O*O<.999){const t=Math.sqrt(R*R+U*U+w*w);R/=t,U/=t,w/=t;const e=Math.sqrt(N*N+j*j+F*F);N/=e,j/=e,F/=e,E=w*j-U*F,T=R*F-w*N,O=U*N-R*j;const n=1/Math.sqrt(E*E+T*T+O*O);E*=n,T*=n,O*=n}},it=s.cornerNeighborCornerTiles;for(let P=0;P<4;++P){const e=P,a=(P+1)%4,M=0===P||1===P?1:0,y=0===P||3===P?1:0,S=t(M,u,f),v=t(y,d,m),V=o.getEdgeFirstVertexIndex(e),I=o.getEdgeCount(e),B=0===P||3===P?I-1:0,A=o.getEdgeFirstVertexIndex(a),R=o.getEdgeCount(a),U=0===P||1===P?R-1:0;let w=-1;for(let t=0;t<4;++t){const e=it[4*P+t],n=it[4*P+w];e&&(-1===w||g(n,e)>0)&&(w=t)}const N=w,j=it[4*P+N];if(j!==x){const t=x.level-j.level,e=2**t,o=[j.lij[0]+t,j.lij[1]*e,j.lij[2]*e],r=[o[1]+e===x.lij[1],0===P&&(1===N||0===N&&j!==it[4*P+3])||1===P&&(0===N||1===N&&j!==it[4*P+2]),o[1]===x.lij[1]+1,2===P&&(3===N||2===N&&j!==it[4*P+1])||3===P&&(2===N||3===N&&j!==it[4*P+0])],a=r.reduce((t,e)=>t+(e?1:0),0);l(1===a||2===a);let c=-1,u=-1;const d=j.renderData;if(1===a){const t=r.findIndex(t=>t);l(0<=t&&t<=3),c=(t+2)%4;const e=s.edgeResolutions[t];u=x.getNeighborEdgeStartVertexIndex(t,j)*e+e*(0===t&&0===P||1===t&&0===P||2===t&&1===P||3===t&&3===P?1:0)}else{l(r[1]||r[3]),c=r[1]?3:1;const t=d.geometryState.edgeResolutions[c];u=0===P||3===P?0:t}const f=d.geometry;{const t=V+B,e=A+U,o=f.getEdgeFirstVertexIndex(c)+u,s=f.vertexAttributes,r=d.localOrigin,a=s.position,l=a.typedBuffer,m=o*a.typedBufferStride,g=l[m]+r[0]-i[0],x=l[m+1]+r[1]-i[1],M=l[m+2]+r[2]-i[2];lt(g,x,M,h);const y=p.position,I=y.typedBuffer,b=t*y.typedBufferStride;I[b]=g,I[b+1]=x,I[b+2]=M;const C=e*y.typedBufferStride;I[C]=g,I[C+1]=x,I[C+2]=M;const L=p.uv0;L.setValues(t,Math.round(S*n),Math.round(v*n)),L.setValues(e,Math.round(S*n),Math.round(v*n));{const n=s.normalCompressed.typedBuffer,r=o*s.normalCompressed.typedBufferStride,i=p.normalCompressed,a=i.typedBuffer;{const e=t*i.typedBufferStride;a[e]=n[r],a[e+1]=n[r+1]}{const t=e*i.typedBufferStride;a[t]=n[r],a[t+1]=n[r+1]}}}}else{const n=Q[e],s=Q[a];let l;if(n||s){const e=t(G*(1-M)+H*M,X,Y),n=t(J*(1-y)+K*y,Z,_);l=r(e,n,c)}else l=$(it,P);D(M,y,l),ot(P);const u=b-i[0],d=C-i[1],f=L-i[2];lt(u,d,f,h),o.setEdgeVertexFromValuesRawPositionUVNormal(e,B,u,d,f,S,v,E,T,O),o.setEdgeVertexFromValuesRawPositionUVNormal(a,U,u,d,f,S,v,E,T,O)}}for(let t=0;t<4;++t)rt[t]=null}function $(t,e){const n=4*e,o=a.reduce((e,o)=>Math.min(e,t[n+o]?.level??1/0),1/0);u&&(l(!t[n+0]||!t[n+2]||m(t[n+0],t[n+2],5)),l(!t[n+1]||!t[n+3]||m(t[n+1],t[n+3],7)));let s=0,i=0;for(let a=0;a<4;++a){const e=t[n+a];if(e&&e.level===o){const t=0===a||1===a,n=0===a||3===a,o=e.extent,c=o[t?0:2],l=o[n?1:3],u=e.renderData?.geometryState?.samplerData;i+=r(c,l,u),s++}}const c=s?i/s:0;return l(null!=c),c}function _(t){const{vao:e,geometry:n}=t,{vertexAttributes:o,edgeVerticesStartIndex:s}=n,r=o.position.typedBuffer;e.buffer()?.setSubData(r,s,s,r.length)}function tt(t){const{vao:e,geometry:n}=t,{indices:o,indexCount:s,edgeIndicesStartIndex:r}=n;e.indexBuffer.setSubData(o,r,r,s)}class et{constructor(t,e,n,o,s){this.isNorth=t,this.connectedRowOffset=e,this.connectedOuterEdgeOffset=n,this.rowOffset=o,this.latitudeResolution=s}}const nt=[[0,1],[1,0],[0,-1],[-1,0]],ot=new i,st=s(-1/0,-1/0,1/0,1/0),rt=[null,null,null,null];function it(t,e,n){if(!e)return!1;const o=g(t,e);return o>0||0===o&&n>=2}class at{constructor(){this.vertex0Index=0,this.stride=1,this.count=0}getVertexIndex(t){return l(0<=t&&t<this.count),this.vertex0Index+this.stride*t}}const ct=[new at,new at,new at,new at];function lt(t,e,n,o){t<o[0]?o[0]=t:t>o[3]&&(o[3]=t),e<o[1]?o[1]=e:e>o[4]&&(o[4]=e),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}function ut(t){const{edgeResolutions:e,numVerticesPerSide:n}=t,o=1+Math.max(...e);return Math.max(n,o)}function dt(t,e,n,o,s,r){const i=t*s,a=r[i],c=r[i+1],l=r[i+2],u=e*s,d=r[u],f=r[u+1],m=r[u+2],g=n*s,h=r[g],p=r[g+1],x=r[g+2],M=o*s,y=r[M],S=r[M+1],v=r[M+2];return(d-y)*(d-y)+(f-S)*(f-S)+(m-v)*(m-v)>(a-h)*(a-h)+(c-p)*(c-p)+(l-x)*(l-x)}function ft(t,e,n,o,s){t[e]=n,t[e+1]=o,t[e+2]=o,t[e+3]=s,t[e+4]=s,t[e+5]=n}const mt=6;export{D as createPlanarGlobePatch,x as createSphericalGlobePatch,V as updateCornerSpherical,T as updateCornersPlanar,O as updateEdgeElevationsAndResolutionsPlanar,v as updateEdgeElevationsAndResolutionsSpherical,R as updateEdgesAndCornersPlanar,S as updateEdgesAndCornersSpherical};
