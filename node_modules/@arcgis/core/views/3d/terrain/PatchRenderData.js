/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import"../../../core/has.js";import{isPowerOfTwo as t}from"../../../core/mathUtils.js";import{disposeMaybe as r,releaseMaybe as i}from"../../../core/maybe.js";import{k as s,F as o,H as a,e as n,n as l,f as d,a as g,G as h}from"../../../chunks/vec32.js";import{create as u,clone as m}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{containsXY as c}from"../../../geometry/support/aaBoundingRect.js";import{earth as f}from"../../../geometry/support/Ellipsoid.js";import{glLayout as p}from"../support/buffer/glUtil.js";import{GeometryState as y}from"./GeometryState.js";import{PatchGeometry as x}from"./PatchGeometry.js";import{maxTileNeighborLevelDelta as _}from"./TerrainConst.js";import{internalAssert as v,neighborEdgeIndices as $,oppositeEdge as C,neighborCornerIndices as E,enableTerrainInternalChecks as S,v32s as D,lij2s as b}from"./terrainUtils.js";import{TextureFader as j}from"./TextureFader.js";import{TextureReference as R}from"./TextureReference.js";import V from"./TileOverlayData.js";import{fallsWithinLayerView as T}from"./tileUtils.js";import{VertexArrayObject as w}from"../webgl-engine/lib/VertexArrayObject.js";import{BufferObject as A}from"../../webgl/BufferObject.js";import{VertexBuffer as P}from"../../webgl/VertexBuffer.js";class F{constructor(){this.geometry=new x,this.geometryState=null,this._texture=null,this._textureOpacity=1,this._textureRef=new j(()=>this._tile.surface.fadeDuration),this.overlay=new V,this._localOrigin=null,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._modifiedFlags=0}get tile(){return this._tile}get localOrigin(){return this._localOrigin}init(e,t){this.clear(),this._tile=e,this.geometry.reset(),this.intersectionData=null,this.geometryState=new y,this._localOrigin=t,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this.wireframeChanged||this.clippingAreaChanged||this.samplerDataChanged||this.numVerticesPerSideChanged||this.dirtyCorners||this.dirtyEdgeResolutions||this.dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),S&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)v(this.geometry.getEdgeCount(t)===this.geometryState.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,o=$[e];if(!t)return v(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(o)),i;if(t.loaded){const r=t,o=r.renderData.geometryState,a=s-r.level;if(v(a>=0),0===a){const e=o.numVerticesPerSide-1;return Math.max(e,i)}const n=2**a,l=o.edgeResolutions[(e+2)%4]/n;return Math.max(1,l)}v(!t.leaf);let a=i;return t.forAllSubtreeOnSide(C(o),e=>e===r||(e.loaded?(a=Math.max(a,2**(e.level-s)),!0):(v(!e.leaf),!1))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const r=e.renderData.geometryState,i=t=>(t.loaded||t.level===e.level)&&t?.intersectsClippingArea,s=r.edgePeerNeighbors,o=r.edgePeerNeighborSamplerVersions;for(let a=0;a<4;++a){const n=e.findNeighborTile($[a],i),l=X(e,n),d=l?.renderData?.geometryState.samplerDataVersion??-1,g=s[a],h=l!==X(e,g),u=o[a]!==d;S&&n&&(v(e.level>=n.level),v(e.level-n.level<=_)),s[a]=n,(h||u)&&(o[a]=d,this._markEdgeDirty(a));const m=r.edgeResolutions[a],c=this._calculateEdgeResolution(a,n);v(t(c)),v(c>=1),r.edgeResolutions[a]=c,m!==c&&this._markEdgeResolutionDirty(a)}for(let t=0;t<4;++t){const o=e.findNeighborTile(E[t],i);r.cornerPeerNeighbors[t]=o;const a=X(e,s[t]),n=X(e,s[(t+1)%4]),l=X(e,o);L[t]=l,L[(t+1)%4]=n,L[(t+2)%4]=e,L[(t+3)%4]=a,v(L.some(t=>t?.loaded||t===e));const d=L.reduce((e,t)=>Math.min(e,t?.level??1/0),1/0);L.forEach((e,t)=>{e&&e?.level>d&&(L[t]=null)}),v(L.some(t=>t?.loaded||t===e));const g=r.cornerNeighborCornerTiles,h=r.cornerNeighborCornerTileSamplerVersions;for(let e=0;e<4;++e){const r=L[e],i=r?.renderData.geometryState.samplerDataVersion??-1,s=4*t+e,o=g[s]!==r,a=!o&&h[s]!==i;(o||a)&&(g[s]=r,h[s]=i,this._markCornerDirty(t))}S&&v(Q.some(r=>g[4*t+r]?.loaded||g[4*t+r]===e))}S&&v(this.geometryState.edgeResolutions.every(e=>e>0));for(let t=0;t<4;++t)L[t]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;S&&v(!this.tile.intersectsClippingArea||this.geometryState.edgeResolutions.every(e=>e>0)),this.intersectionData=null;const{tile:t,_vao:r,geometry:i,geometryState:s}=this,o=!r||!{}||this.wireframeChanged||this.samplerDataChanged||this.clippingAreaChanged||this.numVerticesPerSideChanged,a=0!==this.dirtyEdgeResolutions,n=s.edgeResolutions.reduce((e,t)=>e+t+1,0),l=o||a&&n>(i?.maxEdgeVertexCount??0),d=!l&&a,g=!d&&(0!==this.dirtyEdges||a),h=!g&&0!==this.dirtyCorners;l?(this.releaseGeometry(),this._createGeometry(e)):d?t.updateEdgeElevationsAndResolutions():g||h?t.updateEdgeElevations():h?t.updateCornerElevations():console.warn("Update for no reason?"),this._modifiedFlags=0}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=r(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r,i){const s=t?6408:6407;return null!=this._texture&&(0===r&&this._tile.surface.fadeDuration>0&&this._isTextureVisible(this._texture)||this._texture.descriptor.width!==e||this._texture.descriptor.pixelFormat!==s)&&this.releaseTexture(),null==this._texture&&(this._texture=i(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){this._texture&&(this._texture=i(this._texture),this.tile.setMemoryDirty())}reuseTexture(e,t){return!(!e||!this._texture)&&(e.setTextureReference(new R(this._texture,0,t,this._textureOpacity,0,1)),!0)}get numVerticesPerSideChanged(){return 0!==(this._modifiedFlags&B)}get samplerDataChanged(){return 0!==(this._modifiedFlags&H)}get clippingAreaChanged(){return 0!==(this._modifiedFlags&W)}get wireframeChanged(){return 0!==(this._modifiedFlags&q)}get dirtyEdges(){return this._modifiedFlags>>z&15}get dirtyCorners(){return this._modifiedFlags>>J&15}get dirtyEdgeResolutions(){return this._modifiedFlags>>K&15}_markCornerDirty(e){const t=1<<e<<J;this._modifiedFlags|=t}_markEdgeDirty(e){const t=1<<e<<z;this._modifiedFlags|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e<<K;this._modifiedFlags|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._modifiedFlags|=15<<J|15<<z|15<<K}updateGeometryState(){const t=this._elevationInfo,r=this.tile,i=t.samplerData?r.getElevationVerticesPerSide(t.maxTileLevel):r.minimumVerticesPerSide,s=Math.max(i,5);let o=r.clippingArea;r.intersectsClippingArea&&!r.withinClippingArea||(o=null);const a=this.geometryState;let n=!1;a.numVerticesPerSide!==s&&(this._modifiedFlags|=1,a.numVerticesPerSide=s,a.samplerDataVersion++,n=!0),t.changed&&(this._modifiedFlags|=2,a.samplerData=t.samplerData,a.samplerDataVersion++,n=!0),e(a.clippingArea,o)||(this._modifiedFlags=4,a.clippingArea=o,n=!0);const l=r.surface.wireframe;return a.wireframe!==l&&(this._modifiedFlags=8,a.wireframe=l,n=!0),this._geometryStateChangedSinceLastUpdate||=n,n&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const{vertexAttributes:t,indices:r}=this.geometry,i=e.gl;this._vao=new w(e,new P(e,p(t.layout),t.buffer),A.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=0){e?.texture===this._texture?this._textureOpacity=e.opacities[0]:this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_isTextureVisible(e){return this._textureRef.current?.texture===e||this._textureRef.next?.texture===e&&this._textureRef.fadeFactor<1}get _elevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[0],r=t.length,i=new Array(r);let s=0,o=0,a=!1;for(let d=0;d<r;d++){const r=t[d],n=r.upsampleInfo?.tile;if(n){const t=n.layerInfo[0][d].data,r=t&&t.samplerData;e&&e[s]===r||(a=!0),i[s++]=r,o=Math.max(o,n.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(d,0);if(T(this.tile,t)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,o=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const n=s>0,l=n?i:null;return n&&(i.length=s),{changed:a,samplerData:l,maxTileLevel:o}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){}checkGeometryWaterproofness(){if(!S)return;const e=this.tile;if(!e.loaded||!e.intersectsClippingArea||0===e.level)return void v(e?.loaded);const r=e.surface.extent;if(null!=r&&!e.intersectsExtent(r))return;const i=$.map((t,i)=>null!=r&&(i<2?-1:1)*(e.extent[3-i]-r[3-i])<0),p=e.level;v(0===this.dirtyCorners),v(0===this.dirtyEdges),v(0===this.dirtyEdgeResolutions),v(!this.numVerticesPerSideChanged),v(!this.samplerDataChanged),v(!this.clippingAreaChanged),v(!this.wireframeChanged);const y=E.map(t=>e.findNeighborCornerTileExact(t,t=>!t.intersectsClippingArea||t.loaded||t.level===e.level)??null).map(e=>e?.intersectsClippingArea?e:null),x=this.geometryState;for(let t=0;t<4;++t){const r=x.cornerPeerNeighbors[t],i=y[t];v(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}$.forEach((r,y)=>{if(i[y])return;const x=e.findNeighborTile(r,e=>(e.level===p||e?.loaded)&&e?.intersectsClippingArea);if(!x){const t=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(r);return void v(!t)}v(x.loaded||x.level===e.level),v(x===this.geometryState.edgePeerNeighbors[y]);const _=p-x.level;if(!x.loaded)return v(!x.leaf),void v(0===_);const $=x.renderData;v(e.isEdgeNeighbor(x,r)),v(_>=0);const C=2**_;if(_<0)return void v(!1);const E=e.renderData,S=E.geometry,j=E.localOrigin,R=S.getEdgeCount(y),V=S.numVerticesPerSide-1,T=$.geometry;if(!T)return void v(!1);const w=$.localOrigin,A=this.geometryState.edgePeerNeighbors[y];if(A?.loaded){const e=A.renderData;v(E.geometryState.edgePeerNeighborSamplerVersions[y]===e.geometryState.samplerDataVersion),v(this.geometryState.edgePeerNeighborSamplerVersions[y]===e.geometryState.samplerDataVersion)}const P=(y+2)%4,F=T.getEdgeCount(P),L=R-1,X=F-1;v(L*C===X,`Tile[${e.lij}]:e${y},res=${L} edgeRes mismatch with Neighbor[${x.lij}]:e${P},res=${X} (expected:${L*C})`);const B=e.extent,H=0===r||4===r,W=F-1,q=W>>_,z=R-1;if(q<1)return void v(1===z);v(q===z),v(t(q));const J=T.numVerticesPerSide-1;v(_>0||q===Math.max(J,V));const K=e.getNeighborEdgeStartVertexIndex(y,x);v(0<=K&&K<C);const Q=K*q;v(0<=Q&&Q<=W-q);let Y=0,Z=Q;S.getEdgeVertexPosition(y,N,j,0),S.getEdgeVertexPosition(y,G,j,R-1);const ee=s(N,G),te=Math.max(I,1e-4*ee);for(let t=0;t<=q;++t){S.getEdgeVertexPosition(y,N,j,Y),T.getEdgeVertexPosition(P,G,w,Z);const i=t/q,s=H?B[0]+i*(B[2]-B[0]):6===r?B[0]:B[2],p=H?4===r?B[1]:B[3]:B[1]+i*(B[3]-B[1]),_=e.surface.extent;if(null==_||c(_,s,p)){const t=o(N,G),r=a(N)-f.radius,i=a(G)-f.radius,c=t<te;if(!c){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${y}[${Y}/${R}] and [${x.lij}].edge${P}[${Z}/${F}]`),null!=_&&console.warn("  surface extent= ",_," x,y=",s,",",p);const o=u();n(o,E.localOrigin,$.localOrigin),a(o)>0&&console.warn(`   localOrigins: ${E.localOrigin} vs ${$.localOrigin} d=${a(o)} [${o}]`);(()=>{const t=m(N),r=m(G);e.updateEdgeElevations(),x.updateEdgeElevations(),S.getEdgeVertexPosition(y,N,j,Y),T.getEdgeVertexPosition(P,G,w,Z);const i=u();g(i,N,t),a(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${N} d=${a(i)} [${i}]`),g(i,G,r),a(i)>0&&console.warn(`  XXX Neighbor[${x.lij}] edge out of date: ${r} vs ${G} d=${a(i)} [${i}]`)})();const l=S.getEdgeCount(y),d=T.getEdgeCount(F);v(c,`Mismatch in tile [${e.lij}].edge[${y}][${Y}/${l}] vs neighbor [${x.lij}].edge[${P}][${Z}/${d}] ${D(N)} vs ${D(G)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}S.getEdgeNormal(y,O,Y),T.getEdgeNormal(P,M,Z),l(k,O),l(U,M);const C=d(k,U),V=1-C<.01||!1||e===x;if(!V){const t=u();g(t,O,M);const r=()=>`Mismatch in tile edge normal ${b(e.lij)} (${Y}/${R-1}) edge ${y} vs neighbor ${b(x.lij)}  (${Z}/${F-1}) nedge ${P} :${D(O)} vs ${D(M)}  dot = ${C} : ${D(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),x.updateEdgeElevations();const t=u(),r=u();S.getEdgeNormal(y,t,Y),T.getEdgeNormal(P,r,Z),h(O,t)||console.warn("Missing update in tile normal: ",D(O)," => ",D(t)),h(M,r)||console.warn("Missing update in neighbor normal: ",D(M)," => ",D(r))}v(V,r())}}Y+=1,Z+=1}})}}const N=u(),G=u(),O=u(),M=u(),k=u(),U=u(),I=1,L=[null,null,null,null];function X(e,t){return t?.loaded||t===e?t:null}const B=1,H=2,W=4,q=8,z=4,J=8,K=12,Q=[0,1,2,3];export{F as PatchRenderData,X as neighborTileIfLoadedOrSelf,Q as zeroToFour};
