/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{removeHandles as e,destroyHandle as t,refHandle as o}from"../../../../core/handleUtils.js";import{deg2rad as n}from"../../../../core/mathUtils.js";import{watch as i,initial as l}from"../../../../core/reactiveUtils.js";import{signal as s}from"../../../../core/signal.js";import{j as a}from"../../../../chunks/vec32.js";import{create as r}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectPointToVector as c}from"../../../../geometry/projection/projectPointToVector.js";import{projectVectorToVector as p}from"../../../../geometry/projection/projectVectorToVector.js";import{empty as m,create as u,getMin as h}from"../../../../geometry/support/aaBoundingBox.js";import{containsXY as f}from"../../../../geometry/support/aaBoundingRect.js";import{featureExpressionInfoIsZero as v}from"../../../../support/elevationInfoUtils.js";import{manipulatedObjectGeometry as d}from"./manipulatedObjectUtils.js";import{ManipulatorState as g}from"./ManipulatorState.js";import{Settings as j}from"./settings.js";import{ExtendedLineVisualElement as y}from"../visualElements/ExtendedLineVisualElement.js";import{LaserlineVisualElement as E}from"../visualElements/LaserlineVisualElement.js";import{PointVisualElement as b}from"../visualElements/PointVisualElement.js";import{evaluateElevationAlignmentAtPoint as w}from"../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as x}from"../../layers/graphics/ElevationContext.js";function D(t){const o=[],n=T(t,o);return P(t,o,n),{visualElement:n,remove:()=>e(o)}}function P(e,o,r){const{view:c,object:u}=e,f=new j({getTheme:()=>c.effectiveTheme}),b=new y({view:c,extensionType:f.visualElements.zVerticalLine.extensionType,innerWidth:1,attached:!1,writeDepthEnabled:!1,renderOccluded:4,isDecoration:!0});o.push(i(()=>f.visualElements.zVerticalLine,e=>e.apply(b),l));const D=new E({view:c,intersectsLineInfinite:!0,attached:!1,isDecoration:!0}),P=n(f.visualElements.heightPlaneAngleCutoff),T=new E({view:c,attached:!1,angleCutoff:P,isDecoration:!0}),V=u.elevationInfo,L=x.fromElevationInfo(V),S="on-the-ground"===V.mode||!V.offset&&"absolute-height"!==V.mode,C=new g,M=s(1);o.push(i(()=>({heightPlane:f.visualElements.heightPlane,alpha:M.value}),({heightPlane:e,alpha:t})=>e.apply(T,t),l));const R=s(1);o.push(i(()=>({shadowStyle:f.visualElements.pointObjects.shadowStyle,alpha:R.value}),({shadowStyle:e,alpha:t})=>e.apply(D,t),l));const z=()=>{C.update(e);let t=I(d(u));const o=S&&(u.isDraped||null==t||!t.hasZ);let n=!0;if(o||null==t)n=!1;else{v(u.elevationInfo)&&(t=t.clone(),t.z=0);const e=w(t,c.elevationProvider,L,c.renderCoordsHelper);a(U,t.x,t.y,e),p(U,t.spatialReference,U,c.renderCoordsHelper.spatialReference),b.setStartEndFromWorldDownAtLocation(U),D.intersectsWorldUpAtLocation=U}const i=2&C.grabbingState?f.visualElements.laserlineAlphaMultiplier:1;M.value=i;const l=m(A);!o&&u.visible&&r.calculateMapBounds(l)&&p(h(l,U),c.spatialReference,U,c.renderCoordsHelper.spatialReference)?(T.heightManifoldTarget=U,T.attached=!0):T.attached=!1;const s=4&C.grabbingState?f.visualElements.laserlineAlphaMultiplier:1;R.value=s;const g=n&&u.visible&&!o;D.attached=g,b.attached=g};o.push(i(()=>[u.visible,u.isDraped],z),u.on("committed",z)),e.forEachManipulator(e=>{o.push(e.events.on("grab-changed",z))}),o.push(t(D)),o.push(t(b)),o.push(t(T)),z()}function T(e,o){const{view:n,object:i}=e,l=new b({view:n,geometry:I(d(i)),elevationInfo:i.elevationInfo,isDecoration:!0});return V(e,l,o),o.push(t(l)),l}function I(e){return null==e?null:"point"===e.type?e:"mesh"===e.type?e.origin.clone():null}function V(e,t,o){const{view:n,object:s}=e,a=()=>{t.attached=s.visible},r=new j({getTheme:()=>n.effectiveTheme});L(e,t,o),r.visualElements.pointObjects.outline.apply(t),o.push(i(()=>s.visible,a,l))}function L(e,t,n){const{view:i,object:l}=e;let s=null;const a=e=>{null!=s&&(s.remove(),s=null),l.isDraped&&null!=e&&(s=S(i,e,()=>{t.geometry=e}))},r=()=>{const e=I(d(l));null!=e&&v(l.elevationInfo)&&(e.z=0),a(e),t.geometry=e};n.push(l.on("committed",r),o(()=>s)),r()}function S(e,t,o){const n=e.elevationProvider.spatialReference;c(t,U,n);const i=U[0],l=U[1];return e.elevationProvider.on("elevation-change",e=>{f(e.extent,i,l)&&o()})}const U=r(),A=u();export{D as createVisualElements};
