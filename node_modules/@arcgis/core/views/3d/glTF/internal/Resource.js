/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import t from"../../../../core/Logger.js";import{getOrCreateMapValue as r}from"../../../../core/MapUtils.js";import{getKey as o}from"../../../../core/object.js";import{allSettledValues as n}from"../../../../core/promiseUtils.js";import{isDataProtocol as s,dataComponents as a,dataToArrayBuffer as i,makeAbsolute as u}from"../../../../core/urlUtils.js";import{Version as f}from"../../../../core/Version.js";import{fromXRotation as c,multiply as d,translate as l,rotate as p,scale as m}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as h,clone as b}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{getAxisAngle as w}from"../../../../core/libs/gl-matrix-2/math/quat.js";import{create as y}from"../../../../core/libs/gl-matrix-2/factories/quatf64.js";import{BufferViewVec2f as g,BufferViewVec2u32 as T,BufferViewVec2u16 as _,BufferViewVec2i16 as x,BufferViewVec2u8 as O,BufferViewVec2i8 as N,BufferViewUint32 as S,BufferViewUint16 as C,BufferViewUint8 as A,BufferViewVec3f as L,BufferViewVec4f as E,BufferViewVec4u8 as R,BufferViewVec4u16 as I,BufferViewVec3u8 as v,BufferViewVec3u16 as D}from"../../../../geometry/support/buffer/BufferView.js";import{m as B}from"../../../../chunks/scalar.js";import"../../../../core/has.js";import{getDracoMeshDecoder as U}from"../../../../libs/dracoMeshDecoder/dracoMeshDecoder.js";import{BinaryStreamReader as M}from"./BinaryStreamReader.js";import{material as j,textureSampler as G}from"./fillDefaults.js";import{splitURI as F}from"./pathUtils.js";import{jsonFromBinaryData as H,EncodedMeshTexture as P,imageFromBinaryData as V,isEncodedMeshTexture as z}from"./resourceUtils.js";import{DataType as K}from"../../../webgl/enums.js";const k={MAGIC:1179937895,CHUNK_TYPE_JSON:1313821514,CHUNK_TYPE_BIN:5130562};class Y{constructor(t,r,o,n){if(this._context=t,this.uri=r,this.json=o,this._glbBuffer=n,this._bufferLoaders=new Map,this._textureLoaders=new Map,this._dracoBuffersSize=0,this._textureCache=new Map,this._materialCache=new Map,this._nodeParentMap=new Map,this._nodeTransformCache=new Map,this._supportedExtensions=["KHR_texture_basisu","KHR_texture_transform","KHR_draco_mesh_compression"],this._baseUri=F(this.uri).dirPart,this._checkVersionSupported(),this._checkRequiredExtensionsSupported(),null==o.scenes)throw new e("gltf-loader-unsupported-feature","Scenes must be defined.");if(null==o.meshes)throw new e("gltf-loader-unsupported-feature","Meshes must be defined");if(null==o.nodes)throw new e("gltf-loader-unsupported-feature","Nodes must be defined.");this._computeNodeParents()}static async load(t,r,o){if(s(r)){const e=a(r);if(e&&"model/gltf-binary"!==e.mediaType)try{const o=JSON.parse(e.isBase64?atob(e.data):e.data);return new Y(t,r,o)}catch{}const o=i(r);if(Y._isGLBData(o))return this._fromGLBData(t,r,o)}if(te.test(r)||"gltf"===o?.expectedType){const e=await t.loadJSON(r,o);return new Y(t,r,e)}const n=await t.loadBinary(r,o);if(Y._isGLBData(n))return this._fromGLBData(t,r,n);if(re.test(r)||"glb"===o?.expectedType)throw new e("gltf-loader-invalid-glb","This is not a valid glb file.");const u=await t.loadJSON(r,o);return new Y(t,r,u)}static _isGLBData(e){if(null==e)return!1;const t=new M(e);return t.remainingBytes()>=4&&t.readUint32()===k.MAGIC}static async _fromGLBData(e,t,r){const o=await Y._parseGLBData(r);return new Y(e,t,o.json,o.binaryData)}static async _parseGLBData(r){const o=new M(r);if(o.remainingBytes()<12)throw new e("gltf-loader-error","glb binary data is insufficiently large.");const n=o.readUint32(),s=o.readUint32(),a=o.readUint32();if(n!==k.MAGIC)throw new e("gltf-loader-error","Magic first 4 bytes do not fit to expected glb value.");if(r.byteLength<a)throw new e("gltf-loader-error","glb binary data is smaller than header specifies.");if(2!==s)throw new e("gltf-loader-unsupported-feature","An unsupported glb container version was detected. Only version 2 is supported.");let i,u,f=0;for(;o.remainingBytes()>=8;){const r=o.readUint32(),n=o.readUint32();if(0===f){if(n!==k.CHUNK_TYPE_JSON)throw new e("gltf-loader-error","First glb chunk must be JSON.");if(r<0)throw new e("gltf-loader-error","No JSON data found.");i=await H(o.readUint8Array(r))}else if(1===f){if(n!==k.CHUNK_TYPE_BIN)throw new e("gltf-loader-unsupported-feature","Second glb chunk expected to be BIN.");u=o.readUint8Array(r)}else t.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 glb chunks detected. Skipping.");f+=1}if(!i)throw new e("gltf-loader-error","No glb JSON chunk detected.");return{json:i,binaryData:u}}async getBuffer(t,r){const o=this.json.buffers[t];if(null==o.uri){if(null==this._glbBuffer)throw new e("gltf-loader-error","glb buffer not present");return this._glbBuffer}const n=await this._getBufferLoader(t,r);if(n.byteLength!==o.byteLength)throw new e("gltf-loader-error","Buffer byte lengths should match.");return n}async _getBufferLoader(e,t){const r=this._bufferLoaders.get(e);if(r)return r;const o=this.json.buffers[e].uri,n=this._context.loadBinary(this._resolveUri(o),t).then(e=>new Uint8Array(e));return this._bufferLoaders.set(e,n),n}_validateAccessor(t){if(!this.json.accessors)throw new e("gltf-loader-unsupported-feature","Accessors missing.");const r=this.json.accessors[t];if(r.type in["MAT2","MAT3","MAT4"])throw new e("gltf-loader-unsupported-feature",`AttributeType ${r.type} is not supported`);return r}_getComponentInfo(e,t){const r=$[e.type],o=t?.componentType||e.componentType,n=W[o];return{componentType:o,componentCount:r,componentByteSize:n,denseByteStride:r*n}}getDracoAccessor(e,t){const r=this._validateAccessor(e),o=t.accessorInfos.get(e),{componentType:n,componentCount:s,componentByteSize:a,denseByteStride:i}=this._getComponentInfo(r,o);return{raw:t.data.buffer,byteStride:i,byteOffset:t.data.byteOffset+(o?.byteOffset||0),entryCount:o?.count??r.count,isDenselyPacked:!0,componentCount:s,componentByteSize:a,componentType:n,min:r.min,max:r.max,normalized:!!r.normalized}}async getAccessor(t,r){const o=this._validateAccessor(t);if(null==o?.bufferView)throw new e("gltf-loader-unsupported-feature","Some accessor does not specify a bufferView.");const{componentCount:n,componentByteSize:s,denseByteStride:a}=this._getComponentInfo(o),i=this.json.bufferViews[o.bufferView],u=await this.getBuffer(i.buffer,r),f=i.byteStride||a;return{raw:u.buffer,byteStride:f,byteOffset:u.byteOffset+(i.byteOffset||0)+(o.byteOffset||0),entryCount:o.count,isDenselyPacked:f===a,componentCount:n,componentByteSize:s,componentType:o.componentType,min:o.min,max:o.max,normalized:!!o.normalized}}async getIndexData(e,t,r){if(null==e.indices)return;const o=e.indices,n=r?this.getDracoAccessor(o,r):await this.getAccessor(o,t);if(n.isDenselyPacked)switch(n.componentType){case K.UNSIGNED_BYTE:return new Uint8Array(n.raw,n.byteOffset,n.entryCount);case K.UNSIGNED_SHORT:return new Uint16Array(n.raw,n.byteOffset,n.entryCount);case K.UNSIGNED_INT:return new Uint32Array(n.raw,n.byteOffset,n.entryCount)}else switch(n.componentType){case K.UNSIGNED_BYTE:return B(Z(A,n));case K.UNSIGNED_SHORT:return B(Z(C,n));case K.UNSIGNED_INT:return B(Z(S,n))}}async getPositionData(t,r,n){if(null==t.attributes.POSITION)throw new e("gltf-loader-unsupported-feature","No POSITION vertex data found.");const s=t.attributes.POSITION,a=n?this.getDracoAccessor(s,n):await this.getAccessor(s,r);if(a.componentType!==K.FLOAT)throw new e("gltf-loader-unsupported-feature","Expected type FLOAT for POSITION vertex attribute, but found "+o(K,a.componentType));if(3!==a.componentCount)throw new e("gltf-loader-unsupported-feature","POSITION vertex attribute must have 3 components, but found "+a.componentCount.toFixed());return Z(L,a)}async getNormalData(t,r,n){if(null==t.attributes.NORMAL)throw new e("gltf-loader-error","No NORMAL vertex data found.");const s=t.attributes.NORMAL,a=n?this.getDracoAccessor(s,n):await this.getAccessor(s,r);if(a.componentType!==K.FLOAT)throw new e("gltf-loader-unsupported-feature","Expected type FLOAT for NORMAL vertex attribute, but found "+o(K,a.componentType));if(3!==a.componentCount)throw new e("gltf-loader-unsupported-feature","NORMAL vertex attribute must have 3 components, but found "+a.componentCount.toFixed());return Z(L,a)}async getTangentData(t,r,n){if(null==t.attributes.TANGENT)throw new e("gltf-loader-error","No TANGENT vertex data found.");const s=t.attributes.TANGENT,a=n?this.getDracoAccessor(s,n):await this.getAccessor(s,r);if(a.componentType!==K.FLOAT)throw new e("gltf-loader-unsupported-feature","Expected type FLOAT for TANGENT vertex attribute, but found "+o(K,a.componentType));if(4!==a.componentCount)throw new e("gltf-loader-unsupported-feature","TANGENT vertex attribute must have 4 components, but found "+a.componentCount.toFixed());return Z(E,a)}async getTextureCoordinates(t,r,o){if(null==t.attributes.TEXCOORD_0)throw new e("gltf-loader-error","No TEXCOORD_0 vertex data found.");const n=t.attributes.TEXCOORD_0,s=o?this.getDracoAccessor(n,o):await this.getAccessor(n,r);if(2!==s.componentCount)throw new e("gltf-loader-unsupported-feature","TEXCOORD_0 vertex attribute must have 2 components, but found "+s.componentCount.toFixed());if(s.componentType===K.FLOAT)return Z(g,s);if(!s.normalized)throw new e("gltf-loader-unsupported-feature","Integer component types are only supported for a normalized accessor for TEXCOORD_0.");return Q(s)}async getVertexColors(t,r,n){if(null==t.attributes.COLOR_0)throw new e("gltf-loader-error","No COLOR_0 vertex data found.");const s=t.attributes.COLOR_0,a=n?this.getDracoAccessor(s,n):await this.getAccessor(s,r);if(4!==a.componentCount&&3!==a.componentCount)throw new e("gltf-loader-unsupported-feature","COLOR_0 attribute must have 3 or 4 components, but found "+a.componentCount.toFixed());if(4===a.componentCount){if(a.componentType===K.FLOAT)return Z(E,a);if(a.componentType===K.UNSIGNED_BYTE)return Z(R,a);if(a.componentType===K.UNSIGNED_SHORT)return Z(I,a)}else if(3===a.componentCount){if(a.componentType===K.FLOAT)return Z(L,a);if(a.componentType===K.UNSIGNED_BYTE)return Z(v,a);if(a.componentType===K.UNSIGNED_SHORT)return Z(D,a)}throw new e("gltf-loader-unsupported-feature","Unsupported component type for COLOR_0 attribute: "+o(K,a.componentType))}hasPositions(e){return void 0!==e.attributes.POSITION}hasNormals(e){return void 0!==e.attributes.NORMAL}hasVertexColors(e){return void 0!==e.attributes.COLOR_0}hasTextureCoordinates(e){return void 0!==e.attributes.TEXCOORD_0}hasTangents(e){return void 0!==e.attributes.TANGENT}async getMaterial(e,t,r){let o=e.material?this._materialCache.get(e.material):void 0;if(!o){const n=null!=e.material?j(this.json.materials[e.material]):j(),s=n.pbrMetallicRoughness,a=this.hasVertexColors(e),i=this.getTexture(s.baseColorTexture,t),u=this.getTexture(n.normalTexture,t),f=r?this.getTexture(n.occlusionTexture,t):void 0,c=r?this.getTexture(n.emissiveTexture,t):void 0,d=r?this.getTexture(s.metallicRoughnessTexture,t):void 0,l=null!=e.material?e.material:-1;o={alphaMode:n.alphaMode,alphaCutoff:n.alphaCutoff,color:s.baseColorFactor,doubleSided:!!n.doubleSided,colorTexture:await i,normalTexture:await u,name:n.name,id:l,occlusionTexture:await f,emissiveTexture:await c,emissiveFactor:n.emissiveFactor,metallicFactor:s.metallicFactor,roughnessFactor:s.roughnessFactor,metallicRoughnessTexture:await d,hasVertexColors:a,ESRI_externalColorMixMode:n.extras.ESRI_externalColorMixMode,colorTextureTransform:s?.baseColorTexture?.extensions?.KHR_texture_transform,normalTextureTransform:n.normalTexture?.extensions?.KHR_texture_transform,occlusionTextureTransform:n.occlusionTexture?.extensions?.KHR_texture_transform,emissiveTextureTransform:n.emissiveTexture?.extensions?.KHR_texture_transform,metallicRoughnessTextureTransform:s?.metallicRoughnessTexture?.extensions?.KHR_texture_transform,receiveAmbientOcclusion:n.extras.ESRI_receiveAmbientOcclusion,receiveShadows:n.extras.ESRI_receiveShadows}}return o}async decode(t,r){const o=t.extensions?.KHR_draco_mesh_compression;if(!o)return;if(null==t.indices)throw new e("gltf-loader-error","Found Draco compressed primitive without indices.");const n=this.json.bufferViews[o.bufferView],s=await this.getBuffer(n.buffer,r),a=(await U()).decode(new Uint8Array(s.buffer,s.byteOffset+(n.byteOffset||0),n.byteLength));this._bufferLoaders.delete(n.buffer);const i=new Map([[t.indices,a.indices],[t.attributes.POSITION,a.positions]]);return t.attributes.TEXCOORD_0&&i.set(t.attributes.TEXCOORD_0,a.uvs),t.attributes.NORMAL&&i.set(t.attributes.NORMAL,a.normals),t.attributes.COLOR_0&&i.set(t.attributes.COLOR_0,a.colors),t.attributes.TANGENT&&i.set(t.attributes.TANGENT,a.tangents),this._dracoBuffersSize+=a.buffer.byteLength,{data:a.buffer,accessorInfos:i}}async getTexture(t,o){if(!t)return;if(0!==(t.texCoord||0))throw new e("gltf-loader-unsupported-feature","Only TEXCOORD with index 0 is supported.");const n=t.index,s=this.json.textures[n],a=G(null!=s.sampler?this.json.samplers[s.sampler]:{}),i=ee(s),u=this.json.images[i],f=await this._loadTextureImageData(n,s,o);return r(this._textureCache,n,()=>{const t=e=>33071===e||33648===e||10497===e,r=t=>{throw new e("gltf-loader-error",`Unexpected TextureSampler WrapMode: ${t}`)};return{data:f,wrapS:t(a.wrapS)?a.wrapS:r(a.wrapS),wrapT:t(a.wrapT)?a.wrapT:r(a.wrapT),minFilter:a.minFilter,name:u.name,id:n}})}getNodeTransform(e){if(void 0===e)return X;let t=this._nodeTransformCache.get(e);if(!t){const r=this.getNodeTransform(this._getNodeParent(e)),o=this.json.nodes[e];o.matrix?t=d(h(),r,o.matrix):o.translation||o.rotation||o.scale?(t=b(r),o.translation&&l(t,t,o.translation),o.rotation&&(J[3]=w(J,o.rotation),p(t,t,J[3],J)),o.scale&&m(t,t,o.scale)):t=b(r),this._nodeTransformCache.set(e,t)}return t}_resolveUri(e){return u(e,this._baseUri)}_getNodeParent(e){return this._nodeParentMap.get(e)}_checkVersionSupported(){const e=f.parse(this.json.asset.version,"glTF");q.validate(e)}_checkRequiredExtensionsSupported(){const t=this.json;if(t.extensionsRequired){if(!t.extensionsRequired.every(e=>this._supportedExtensions.includes(e)))throw new e("gltf-loader-unsupported-feature","gltf loader was not able to load unsupported feature. Required extensions: "+t.extensionsRequired.join(", "))}}_computeNodeParents(){this.json.nodes.forEach((e,t)=>{e.children&&e.children.forEach(e=>{this._nodeParentMap.set(e,t)})})}async _loadTextureImageData(e,t,r){const o=this._textureLoaders.get(e);if(o)return o;const n=this._createTextureLoader(t,r);return this._textureLoaders.set(e,n),n}async _createTextureLoader(t,r){const o=ee(t),n=this.json.images[o];if(n.uri){if(n.uri.endsWith(".ktx2")){const e=await this._context.loadBinary(this._resolveUri(n.uri),r);return new P(new Uint8Array(e))}return this._context.loadImage(this._resolveUri(n.uri),r)}if(null==n.bufferView)throw new e("gltf-loader-unsupported-feature","Image bufferView must be defined.");if(null==n.mimeType)throw new e("gltf-loader-unsupported-feature","Image mimeType must be defined.");const s=this.json.bufferViews[n.bufferView],a=await this.getBuffer(s.buffer,r);if(null!=s.byteStride)throw new e("gltf-loader-unsupported-feature","byteStride not supported for image buffer");const i=a.byteOffset+(s.byteOffset||0);return V(new Uint8Array(a.buffer,i,s.byteLength),n.mimeType)}async getLoadedBuffersSize(){if(this._glbBuffer)return this._glbBuffer.byteLength;const e=await n(Array.from(this._bufferLoaders.values())),t=await n(Array.from(this._textureLoaders.values()));return e.reduce((e,t)=>e+(t?.byteLength??0),0)+this._dracoBuffersSize+t.reduce((e,t)=>e+(t?z(t)?t.data.byteLength:t.width*t.height*4:0),0)}}const X=c(h(),Math.PI/2),q=new f(2,0,"glTF"),J=y(),$={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},W={[K.BYTE]:1,[K.UNSIGNED_BYTE]:1,[K.SHORT]:2,[K.UNSIGNED_SHORT]:2,[K.HALF_FLOAT]:2,[K.FLOAT]:4,[K.INT]:4,[K.UNSIGNED_INT]:4};function Q(e){switch(e.componentType){case K.BYTE:return new N(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case K.UNSIGNED_BYTE:return new O(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case K.SHORT:return new x(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case K.UNSIGNED_SHORT:return new _(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case K.UNSIGNED_INT:return new T(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case K.FLOAT:return new g(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount)}}function Z(e,t){return new e(t.raw,t.byteOffset,t.byteStride,t.byteOffset+t.byteStride*(t.entryCount-1)+t.componentByteSize*t.componentCount)}function ee(t){if(null!=t.extensions?.KHR_texture_basisu)return t.extensions.KHR_texture_basisu.source;if(null!==t.source)return t.source;throw new e("gltf-loader-unsupported-feature","Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.")}const te=/\.gltf$/i,re=/\.glb$/i;export{Y as GLTFResource,X as transformGltfToEngine};
