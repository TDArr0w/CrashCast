/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import e from"../../../core/Accessor.js";import{min as o}from"../../../core/arrayUtils.js";import{createTask as i}from"../../../core/asyncUtils.js";import{dedupeResult as s}from"../../../core/dedupeResult.js";import{makeHandle as r}from"../../../core/handleUtils.js";import{equalsShallow as a}from"../../../core/lang.js";import{LRUCache as n}from"../../../core/LRUCache.js";import{mapCollection as l}from"../../../core/mapCollectionUtils.js";import{destroyMaybe as p,abortMaybe as u,equalsMaybe as c}from"../../../core/maybe.js";import{throwIfAborted as m,throwIfAbortError as h}from"../../../core/promiseUtils.js";import{watch as _,syncAndInitial as d,on as f}from"../../../core/reactiveUtils.js";import{throttle as v}from"../../../core/throttle.js";import{adaptiveVerticalLengthUnit as y,adaptiveLengthUnit as g}from"../../../core/unitUtils.js";import{property as C}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import{subclass as P}from"../../../core/accessorSupport/decorators/subclass.js";import{ElevationQueryTileCache as j}from"../../../layers/support/ElevationQueryTileCache.js";import{absoluteHeightElevationInfo as T}from"../../../support/elevationInfoUtils.js";import{getDefaultUnitForView as U}from"../../../support/getDefaultUnitForView.js";import b from"../../../symbols/support/ElevationInfo.js";import{getConfig as w}from"./constants.js";import R from"./ElevationProfileError.js";import{InvalidGeometryError as S,UnknownError as I}from"./elevationProfileErrors.js";import{createProfileQueue as E,sanitizeProgress as D,generateProfiles as q}from"./elevationProfileGenerationUtils.js";import{mergeStatistics as x,getBoundsInMeters as O}from"./elevationProfileStatisticsUtils.js";let k=class extends e{constructor(t){super(t),this.error=null,this._getStableEffectiveUnits=s(()=>{const t=O(this._activeComputations.map(t=>t.result.rawResult)),e=this.analysis.displayUnits,o=U(this.view);return{distance:g(t.maxDistance,"meters",e.distance??o),elevation:y(t.maxElevation,"meters",e.elevation??o)}},a),this._updateTask=null,this._queue=null,this._currentTileCache=null,this._parametersPerComputation=new Map,this._getStableUpdateParameters=s(()=>({stationary:this.view.stationary??!0,activeComputations:this._activeComputations,generationParameters:this._generationParameters}),a),this._getStableGenerationParameters=s(()=>{const{view:t,analysis:e}=this;return t?.ready&&this._queue?{view:t,geometry:e.geometry,geometryIsValid:e.valid,elevationInfo:this.elevationInfo,queue:this._queue,cache:this._tileCache,options:this._options,slicePlane:"3d"===t.type?t.slice.plane:null}:null},a),this._getStableElevationInfo=s(()=>this.analysis.elevationInfo??V,c),this._getStableOptions=s(()=>{const{densificationMaxSamples:t,defaultDemResolution:e,maxTotalSamples:o}=w();let i=this._minDemResolution??e;return i=parseFloat(i.toFixed(2)),{samplingDistance:i,densificationMaxSamples:Math.round(t/this._activeComputations.length),maxTotalSamples:o}},a),this._updateThrottled=v(t=>this._update(t),w().updateThrottleMillis)}initialize(){this._computationsCollection=l(()=>this.analysis.profiles,t=>this.computationFactory.create({controller:this,profile:t,onInvalidate:t=>this._invalidateComputation(t)}),{recycleItems:!0}),this.addHandles([this._computationsCollection.on("change",()=>{this._parametersPerComputation.clear(),this._updateThrottled(this._updateParameters)}),_(()=>this._updateParameters,t=>this._updateThrottled(t),d),this._updateThrottled]);const t="3d"===this.view.type?this.view.resourceController:void 0;this._queue=E(t?.scheduler),t?.addUpdatingObject(this)}destroy(){this._abortUpdate(),this._parametersPerComputation.clear(),this._computationsCollection?.destroy(),this._queue=p(this._queue),this._currentTileCache=p(this._currentTileCache)}get effectiveDisplayUnits(){return this._getStableEffectiveUnits()}get progress(){let t=0,e=0;for(const o of this._activeComputations)t++,e+=o.progress;return D(t>0?e/t:0)}get updating(){const{progress:t}=this,e=!!this._queue?.updating,o=this._updateThrottled.hasPendingUpdates(),i=null!=this._updateTask&&!this._updateTask.finished;return e||o||i||t>0&&t<1}get results(){return this._computations.map(t=>t.result)}get statistics(){return x(this._activeComputations.map(t=>t.result.statistics))}get hoveredPoints(){return this._computations.map(t=>t.hoveredPoint)}onElevationChange(t){const{view:e}=this;return"3d"===e?.type?f(()=>e.elevationProvider,"elevation-change",t,{onListenerAdd:t,onListenerRemove:t}):r()}get _tileCache(){this._currentTileCache=p(this._currentTileCache);const t=this.view;if("3d"===t?.type){const e=t.basemapTerrain?.elevationQueryCache;if(null!=e)return e}return null==this._currentTileCache&&(this._currentTileCache=new j(new n(20971520))),this._currentTileCache}get _computations(){return this._computationsCollection?.toArray()??[]}get _activeComputations(){return this._computations.filter(t=>t.profile.enabled&&t.available)}get _minDemResolution(){const t=this._minDemResolutions;return t.length>0?o(t):null}get _minDemResolutions(){const t=[];for(const{minDemResolution:e}of this._activeComputations)null!=e&&t.push(e);return t}get _updateParameters(){return this._getStableUpdateParameters()}get _generationParameters(){return this._getStableGenerationParameters()}get elevationInfo(){return this._getStableElevationInfo()}get _options(){return this._getStableOptions()}_update({stationary:t,activeComputations:e,generationParameters:o}){this._abortUpdate(),t&&(null!=o?this._updateTask=i(async t=>{this.error=null;const i=e.filter(t=>!this._isComputationValid(t,o));try{if(!o.geometryIsValid)throw new S;const e=q({...o,providers:i},{signal:t});let s=!1;for await(const r of e){m(t),s||(this._clearInvalidResults(o),s=!0);for(let t=0;t<i.length;t++)i[t].setResult(r[t])}for(const t of i)this._parametersPerComputation.set(t,o)}catch(s){h(s),this._abortUpdate(),this.error=s instanceof R?s:new I,i.forEach(t=>{t.clearResult()})}}):this._clearResults())}_abortUpdate(){this._updateTask=u(this._updateTask)}_isComputationValid(t,e){return this._parametersPerComputation.has(t)&&this._parametersPerComputation.get(t)===e}_invalidateComputation(t){this._parametersPerComputation.delete(t),this._updateThrottled(this._updateParameters)}_clearInvalidResults(t){for(const e of this._computations)this._isComputationValid(e,t)||(e.clearResult(),this._parametersPerComputation.delete(e))}_clearResults(){for(const t of this._computations)t.clearResult(),this._parametersPerComputation.delete(t)}};t([C({constructOnly:!0})],k.prototype,"analysis",void 0),t([C({constructOnly:!0})],k.prototype,"analysisViewData",void 0),t([C({constructOnly:!0})],k.prototype,"computationFactory",void 0),t([C({constructOnly:!0})],k.prototype,"view",void 0),t([C()],k.prototype,"error",void 0),t([C({readOnly:!0})],k.prototype,"effectiveDisplayUnits",null),t([C()],k.prototype,"progress",null),t([C()],k.prototype,"updating",null),t([C()],k.prototype,"results",null),t([C()],k.prototype,"statistics",null),t([C()],k.prototype,"hoveredPoints",null),t([C()],k.prototype,"_updateTask",void 0),t([C()],k.prototype,"_queue",void 0),t([C()],k.prototype,"_tileCache",null),t([C()],k.prototype,"_computationsCollection",void 0),t([C()],k.prototype,"_computations",null),t([C()],k.prototype,"_activeComputations",null),t([C({readOnly:!0})],k.prototype,"_minDemResolution",null),t([C()],k.prototype,"_minDemResolutions",null),t([C()],k.prototype,"_updateParameters",null),t([C()],k.prototype,"_generationParameters",null),t([C()],k.prototype,"elevationInfo",null),t([C()],k.prototype,"_options",null),k=t([P("esri.views.analysis.ElevationProfile.ElevationProfileController")],k);const V=new b({...T});export{k as ElevationProfileController};
