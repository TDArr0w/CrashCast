/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{cyclicalDegrees as e,Cyclical as r}from"../../core/Cyclical.js";import{createAngle as t,convertRotationType as o}from"../../core/quantityUtils.js";import{convertUnit as i}from"../../core/unitUtils.js";import{angle as n}from"../../core/libs/gl-matrix-2/math/vec2.js";import{create as s,UNIT_Y as a}from"../../core/libs/gl-matrix-2/factories/vec2f64.js";import{q as c,d as l,j as u}from"../../chunks/vec32.js";import{create as f}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as m}from"../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as g,inverseGeodeticSolver as p,InverseGeodeticSolverResult as d,directGeodeticSolver as h}from"../../geometry/support/geodesicUtils.js";import{equals as v}from"../../geometry/support/spatialReferenceUtils.js";function j(e,r){if(null==e||null==r)return;const o=b(e,r);return null!=o?t(o,"radians","geographic"):void 0}const b=(()=>{const e=f(),r=f();return(t,o)=>(u(e,t.x,t.y,t.z??0),u(r,o.x,o.y,o.z??0),y(e,r,t.spatialReference,o.spatialReference))})(),y=(()=>{const e=s(),r=f(),t=f();return(o,s,l,u)=>{if(c(o,s))return;const f=g(l),d=g(u);if(f&&d&&v(f,d)&&m(o,l,r,f)&&m(s,u,t,d)){const{azimuth:e}=p(k,r,t,f);return null!=e?i(e,"degrees","radians"):void 0}e[0]=s[0]-o[0],e[1]=s[1]-o[1];let h=n(a,e);return e[0]<0&&(h=C-h),h}})();function x(e,r,t,o="absolute"){if(r&&t)switch(o){case"absolute":return j(r,t);case"relative":return w(z(e,r,t),"relative");case"relative-bilateral":return w(z(e,r,t),"relative-bilateral")}}function z(e,r,o){if(!e||!r||!o)return;const i=b(e,r),n=b(r,o);return null!=i&&null!=n?t(n-i,"radians","geographic"):void 0}function w(e,r){if(null!=e)switch(r){case"absolute":return M(e);case"relative":{const r=R(e);let o=P.normalize(r,0,!0);return-180===o&&(o=180),t(o,"degrees","geographic")}case"relative-bilateral":{const r=R(e),o=Math.abs(P.normalize(r,0,!0));return t(o,"degrees","geographic")}}}function M(e){const r=R(e),o=I.normalize(r,0,!0);return t(o,"degrees","geographic")}function T(e,r,n){let s=i(e.value,e.unit,"degrees");return s=o(s,e.rotationType,n),s=i(s,"degrees",r),t(s,r,n)}const U=(()=>{const e=f();return(r,t,n,s,a,c="geodesic")=>{l(e,t);const f=R(a);if("geodesic"===c){const o=g(n);if(o&&m(e,n,e,o))return h(r,e,f,s,o),r[2]=t[2],!!m(r,o,r,n)}const p=o(f,"geographic","arithmetic"),d=i(p,"degrees","radians"),v=t[0]+s*Math.cos(d),j=t[1]+s*Math.sin(d),b=t[2];return u(r,v,j,b),!0}})();function R(e){if(null!=e)return o(V(e),e.rotationType,"geographic")}function q(e){if(null!=e)return o(V(e),e.rotationType,"arithmetic")}function V(e){return i(e.value,e.unit,"degrees")}const k=new d,C=2*Math.PI,I=e,P=new r(-180,180);export{T as convertAngle,j as directionBetweenPoints,x as directionForVertices,q as getDegreesArithmetic,R as getDegreesGeographic,w as getNormalizedDirection,M as getNormalizedGeographicOrientation,U as pointFromDistanceAlongAzimuth,y as radiansGeographicBetweenVec};
