/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../Graphic.js";import{equals as t}from"../../../core/arrayUtils.js";import o from"../../../geometry/Point.js";import r from"../../../geometry/Polyline.js";import{getMidpoint as n}from"../../../geometry/support/coordsUtils.js";import{isMultipoint as i,isPolygon as s,isPolyline as l}from"../../../geometry/support/typeUtils.js";import{interpolateBezierCurve as c,splitBezierCurve as a}from"../../../geometry/support/curves/bezierCurveUtils.js";import{interpolateCircle as p}from"../../../geometry/support/curves/circleUtils.js";import{deriveCircleFromCircularArc as u,splitCircularArc as m}from"../../../geometry/support/curves/circularArcUtils.js";import{getEndpoint as d,isCoordinate as f,isBezierCurve as h,isEllipticArc4 as y,isCircularArc as v,isEllipticArc as g,isEllipticArc7 as x}from"../../../geometry/support/curves/curveUtils.js";import{deriveCircleFromEllipticArc4 as b,splitEllipticArc4 as w}from"../../../geometry/support/curves/ellipticArc4Utils.js";import{deriveEllipse as z,interpolateEllipse as I,splitEllipticArc7 as j}from"../../../geometry/support/curves/ellipticArc7Utils.js";import P from"../../../symbols/SimpleLineSymbol.js";import S from"../../../symbols/SimpleMarkerSymbol.js";import{settings as C}from"./settings.js";const R={pathIndex:"pathIndex",pointIndex:"pointIndex",pointIndexStart:"pointIndexStart",pointIndexEnd:"pointIndexEnd",controlPointKind:"kind",relatedGraphicIndices:"relatedGraphicIndices",curveFromStraightEdgeFlag:"curveFromStraightEdgeFlag",tool:"esriSketchTool"},U={bezier:{cp1:"bezier-cp-1",cp2:"bezier-cp-2",line1:"bezier-line-1",line2:"bezier-line-2"},circle:{interior:"circle-interior"}},k="box",E=C.reshapeGraphics,T={vertices:{default:new S({style:"circle",size:E.vertex.size,color:E.vertex.color,outline:{color:E.vertex.outlineColor,width:1}}),hover:new S({style:"circle",size:E.vertex.hoverSize,color:E.vertex.hoverColor,outline:{color:E.vertex.hoverOutlineColor,width:1}}),selected:new S({style:"circle",size:E.selected.size,color:E.selected.color,outline:{color:E.selected.outlineColor,width:1}})},controlPoints:{default:new S({style:"diamond",size:E.vertex.size,color:E.vertex.color,outline:{color:E.vertex.outlineColor,width:1}}),hover:new S({style:"diamond",size:E.vertex.hoverSize,color:E.vertex.hoverColor,outline:{color:E.vertex.hoverOutlineColor,width:1}}),selected:new S({style:"diamond",size:E.selected.size,color:E.selected.color,outline:{color:E.selected.outlineColor,width:1}})},midpoints:{default:new S({style:"circle",size:E.midpoint.size,color:E.midpoint.color,outline:{color:E.midpoint.outlineColor,width:1}}),hover:new S({style:"circle",size:E.midpoint.size,color:E.midpoint.color,outline:{color:E.midpoint.outlineColor,width:1}})},constructionLines:new P({style:"solid",width:1,color:E.vertex.color})};function K(t,o,r){const n=[];return t?.forEach((t,i)=>{t.forEach((t,s)=>{n.push(new e({geometry:r.arrayToPoint(d(t)),symbol:o?.vertices?.default,attributes:{[R.tool]:k,[R.pathIndex]:i,[R.pointIndex]:s}}))})}),n}function F(t,o,r){const n=[];for(let i=0;i<t.length;i++){const s=t[i];if(!Z(t,i))for(let t=1;t<s.length;t++){const l=s[t];if(f(l))continue;const c=d(s[t-1]),a={[R.tool]:k,[R.pathIndex]:i,[R.pointIndex]:t};if(h(l)){const t=l.b.slice(1);n.push(...t.map((t,n)=>new e({geometry:r.arrayToPoint(t),symbol:o?.controlPoints?.default,attributes:{...a,[R.controlPointKind]:0===n?U.bezier.cp1:U.bezier.cp2}})))}const m=v(l),g=y(l);if(m||g){const t=m?u(c,l):b(c,l),i=p(t,.25);n.push(new e({geometry:r.arrayToPoint(i),symbol:o?.controlPoints?.default,attributes:{...a,[R.controlPointKind]:U.circle.interior}}))}}}return n}function G(t,o,n){const i=[],{spatialReference:s}=n;for(let l=0;l<t.length;l++){const n=t[l];for(let t=1;t<n.length;t++){const c=n[t];if(!h(c))continue;const[a,p,u]=c.b,m=d(n[t-1]),f={[R.tool]:k,[R.pathIndex]:l,[R.pointIndex]:t};i.push(new e({geometry:new r({paths:[[[m[0],m[1]],p]],spatialReference:s}),symbol:o?.constructionLines,attributes:{...f,[R.controlPointKind]:U.bezier.line1}}),new e({geometry:new r({paths:[[[a[0],a[1]],u]],spatialReference:s}),symbol:o?.constructionLines,attributes:{...f,[R.controlPointKind]:U.bezier.line2}}))}}return i}function L(t,o,r,n){const i=[];for(let s=0;s<t.length;s++){const l=t[s],c=O(t,s);for(let t=0;t<l.length;t++){const a=(t+1)%l.length;if((!n||c)&&0===a)continue;const p=M(l[t],l[a],r);i.push(new e({geometry:p,symbol:o.midpoints.default,attributes:{[R.tool]:k,[R.pathIndex]:s,[R.pointIndexStart]:t,[R.pointIndexEnd]:a}}))}}return i}function M(e,t,r){const i=d(e),s=d(t),{spatialReference:l}=r,a=r.arrayToVector(i),m=r.arrayToVector(s),g=r.toXYZ(a),x=r.toXYZ(m),[w,j,P]=n(g,x),S=r.hasM()?0:void 0;if(f(t))return new o({x:w,y:j,z:P,m:S,spatialReference:l});if(h(t)){const[e,r]=c(i,t,.5);return new o({x:e,y:r,z:P,m:S,spatialReference:l})}if(v(t)){const e=u(i,t),[r,n]=p(e,.5);return new o({x:r,y:n,z:P,m:S,spatialReference:l})}if(y(t)){const e=b(i,t),[r,n]=p(e,.5);return new o({x:r,y:n,z:P,m:S,spatialReference:l})}const C=z(i,t),[R,U]=I(C,.5);return new o({x:R,y:U,z:P,m:S,spatialReference:l})}function Z(e,o){const r=e.at(o);return 2===r?.length&&t(d(r[1]),d(r[0]))&&y(r[1])}function A(e,o){const r=e.at(o);return 2===r?.length&&t(d(r[1]),d(r[0]))&&x(r[1])}function O(e,o){const r=e.at(o);return 2===r?.length&&t(d(r[1]),d(r[0]))&&g(r[1])}function V(e,t){if(i(e))return void(e.points=t.flat());const o=t.some(e=>e.some(e=>!f(e)));s(e)?o?(e.curveRings=t,e.rings=[]):(e.rings=t,e.curveRings=void 0):l(e)&&(o?(e.curvePaths=t,e.paths=[]):(e.curvePaths=void 0,e.paths=t))}function X(e,t,o,r){const n=d(t);let i=[];switch(!0){case h(t):i=a(e,t,o);break;case v(t):{const r=u(e,t);i=m(r,t,o);break}case y(t):{const r=b(e,t);i=w(r,t,o);break}default:{const r=z(e,t);i=j(r,t,o);break}}if(i.length<2)return i;if(r.hasZ()){const t=e.at(2)??0,r=n.at(2)??0,s=t+(r-t)*o;d(i[0])[2]=s,d(i[1])[2]=r}if(r.hasM()){const e=r.hasZ()?3:2;d(i[0])[e]=0,d(i[1])[e]=n.at(-1)??0}return i}export{R as attributeKeys,U as controlPointKinds,G as createCurveConstructionLineGraphics,F as createCurveControlPointGraphics,L as createMidpointGraphics,K as createVertexGraphics,T as defaultSymbols,M as getMidpoint,Z as isSingleSegmentCircle,A as isSingleSegmentEllipse,O as isSingleSegmentPolygon,V as saveUpdatedCurveOrCoordinate,X as splitCurve,k as toolIdAttribute};
