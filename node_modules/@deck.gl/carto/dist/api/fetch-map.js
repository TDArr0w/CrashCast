import ClusterTileLayer from "../layers/cluster-tile-layer.js";
import H3TileLayer from "../layers/h3-tile-layer.js";
import HeatmapTileLayer from "../layers/heatmap-tile-layer.js";
import VectorTileLayer from "../layers/vector-tile-layer.js";
import QuadbinTileLayer from "../layers/quadbin-tile-layer.js";
import RasterTileLayer from "../layers/raster-tile-layer.js";
import { fetchMap as _fetchMap } from '@carto/api-client';
// Layer factory to create deck.gl layers from layer descriptors
const layerClasses = {
    clusterTile: ClusterTileLayer,
    h3: H3TileLayer,
    heatmapTile: HeatmapTileLayer,
    mvt: VectorTileLayer,
    quadbin: QuadbinTileLayer,
    raster: RasterTileLayer,
    tileset: VectorTileLayer
};
export function LayerFactory(descriptor) {
    const LayerClass = layerClasses[descriptor.type];
    if (!LayerClass) {
        throw new Error(`No layer class found for type: ${descriptor.type}`);
    }
    return new LayerClass(descriptor.props);
}
function createResult(result) {
    return {
        ...result,
        layers: result.layers.map(descriptor => LayerFactory(descriptor))
    };
}
/**
 * fetchMap is a wrapper around the @carto/api-client fetchMap function, with additions for convenience and backward-compatibility.
 * Where @carto/api-client fetchMap returns layer props, @deck.gl/carto fetchMap returns Layer instances ready for use.
 * For greater control, use the @carto/api-client fetchMap function directly and use LayerFactory to create layers manually.
 */
export async function fetchMap(options) {
    const { onNewData, ...rest } = options;
    const _options = {
        ...rest,
        onNewData: typeof onNewData === 'function'
            ? result => {
                onNewData(createResult(result));
            }
            : undefined
    };
    // For backwards compatibility, provide a shim for the old API
    const _result = await _fetchMap(_options);
    const result = createResult(_result);
    return result;
}
//# sourceMappingURL=fetch-map.js.map